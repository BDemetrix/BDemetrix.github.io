// Automatic generation on 2021-05-01 10:26:57
var aRouter = new Array();
aRouter['error'] = '/error/';
aRouter['registration'] = '/registration/';
aRouter['profile'] = '/profile/';
aRouter['blog'] = '/blog/';
aRouter['top'] = '/top/';
aRouter['index'] = '/index/';
aRouter['topic'] = '/topic/';
aRouter['login'] = '/login/';
aRouter['people'] = '/people/';
aRouter['settings'] = '/settings/';
aRouter['tag'] = '/tag/';
aRouter['talk'] = '/talk/';
aRouter['allcomments'] = '/allcomments/';
aRouter['rss'] = '/rss/';
aRouter['link'] = '/link/';
aRouter['question'] = '/question/';
aRouter['blogs'] = '/blogs/';
aRouter['search'] = '/search/';
aRouter['admin'] = '/admin/';
aRouter['page'] = '/page/';
aRouter['allblog'] = '/allblog/';
aRouter['news'] = '/news/';
aRouter['allsignals'] = '/allsignals/';
aRouter['disclosure'] = '/disclosure/';
aRouter['votes'] = '/votes/';
aRouter['vopros'] = '/vopros/';
aRouter['pushes'] = '/pushes/';
aRouter['tags'] = '/tags/';
aRouter['flow'] = '/flow/';
aRouter['smm'] = '/smm/';
aRouter['zen'] = '/zen/';
aRouter['thisday'] = '/thisday/';
aRouter['print'] = '/print/';
aRouter['maintheme'] = '/maintheme/';
aRouter['my'] = '/my/';
aRouter['allvotes'] = '/allvotes/';
aRouter['money'] = '/money/';
aRouter['tradingreads'] = '/tradingreads/';
aRouter['friends'] = '/friends/';
aRouter['my-trading-account'] = '/my-trading-account/';
aRouter['user-trading-account'] = '/user-trading-account/';
aRouter['finansoviy-slovar'] = '/finansoviy-slovar/';
aRouter['forums'] = '/forums/';
aRouter['forum'] = '/forum/';
aRouter['kompanii'] = '/kompanii/';
aRouter['bonds'] = '/bonds/';
aRouter['banki'] = '/banki/';
aRouter['options'] = '/options/';
aRouter['algotrading'] = '/algotrading/';
aRouter['brokers-rating'] = '/brokers-rating/';
aRouter['brokers'] = '/brokers/';
aRouter['forex'] = '/forex/';
aRouter['trading-software'] = '/trading-software/';
aRouter['dividends'] = '/dividends/';
aRouter['trading'] = '/trading/';
aRouter['crypto'] = '/crypto/';
aRouter['chat'] = '/chat/';
aRouter['stocks'] = '/stocks/';
aRouter['company'] = '/company/';
aRouter['companytag'] = '/companytag/';
aRouter['panel'] = '/panel/';
aRouter['books'] = '/books/';
aRouter['review'] = '/review/';
aRouter['e'] = '/e/';
aRouter['g'] = '/g/';
aRouter['gr'] = '/gr/';
aRouter['q'] = '/q/';
aRouter['poll'] = '/poll/';
aRouter['consumer-confidence-russia'] = '/consumer-confidence-russia/';
aRouter['console'] = '/console/';
aRouter['oil'] = '/oil/';
aRouter['lchi2016'] = '/lchi2016/';
aRouter['lchi2017'] = '/lchi2017/';
aRouter['lchi2018'] = '/lchi2018/';
aRouter['lchi2019'] = '/lchi2019/';
aRouter['lchi2020'] = '/lchi2020/';
aRouter['summoner'] = '/summoner/';
aRouter['calendar'] = '/calendar/';
aRouter['stat'] = '/stat/';
aRouter['statx'] = '/statx/';
aRouter['favtop'] = '/favtop/';
aRouter['vtop'] = '/vtop/';
aRouter['smartlab-tv'] = '/smartlab-tv/';
aRouter['blacklist'] = '/blacklist/';
aRouter['abuse'] = '/abuse/';
aRouter['mobile'] = '/mobile/';
aRouter['read'] = '/read/';
aRouter['rest'] = '/rest/';
;
/**
 * JsHttpRequest: JavaScript "AJAX" data loader
 * Minimized version: see debug directory for the complete one.
 *
 * @license LGPL
 * @author Dmitry Koterov, http://en.dklab.ru/lib/JsHttpRequest/
 * @version 5.x $Id$
 */
function JsHttpRequest() {
  var t = this;
  t.onreadystatechange = null;
  t.readyState = 0;
  t.responseText = null;
  t.responseXML = null;
  t.status = 200;
  t.statusText = "OK";
  t.responseJS = null;
  t.caching = false;
  t.loader = null;
  t.session_name = "PHPSESSID";
  t._ldObj = null;
  t._reqHeaders = [];
  t._openArgs = null;
  t._errors = { inv_form_el: "Invalid FORM element detected: name=%, tag=%", must_be_single_el: "If used, <form> must be a single HTML element in the list.", js_invalid: "JavaScript code generated by backend is invalid!\n%", url_too_long: "Cannot use so long query with GET request (URL is larger than % bytes)", unk_loader: "Unknown loader: %", no_loaders: "No loaders registered at all, please check JsHttpRequest.LOADERS array", no_loader_matched: "Cannot find a loader which may process the request. Notices are:\n%" };
  t.abort = function () {
    with (this) {
      if (_ldObj && _ldObj.abort) {
        _ldObj.abort();
      }
      _cleanup();
      if (readyState == 0) {
        return;
      }
      if (readyState == 1 && !_ldObj) {
        readyState = 0;
        return;
      }
      _changeReadyState(4, true);
    }
  };
  t.open = function (_2, _3, _4, _5, _6) {
    with (this) {
      if (_3.match(/^((\w+)\.)?(GET|POST)\s+(.*)/i)) {
        this.loader = RegExp.$2 ? RegExp.$2 : null;
        _2 = RegExp.$3;
        _3 = RegExp.$4;
      }
      try {
        if (document.location.search.match(new RegExp("[&?]" + session_name + "=([^&?]*)")) || document.cookie.match(new RegExp("(?:;|^)\\s*" + session_name + "=([^;]*)"))) {
          _3 += (_3.indexOf("?") >= 0 ? "&" : "?") + session_name + "=" + this.escape(RegExp.$1);
        }
      }
      catch (e) {
      }
      _openArgs = { method: (_2 || "").toUpperCase(), url: _3, asyncFlag: _4, username: _5 != null ? _5 : "", password: _6 != null ? _6 : "" };
      _ldObj = null;
      _changeReadyState(1, true);
      return true;
    }
  };
  t.send = function (_7) {
    if (!this.readyState) {
      return;
    }
    this._changeReadyState(1, true);
    this._ldObj = null;
    var _8 = [];
    var _9 = [];
    if (!this._hash2query(_7, null, _8, _9)) {
      return;
    }
    var _a = null;
    if (this.caching && !_9.length) {
      _a = this._openArgs.username + ":" + this._openArgs.password + "@" + this._openArgs.url + "|" + _8 + "#" + this._openArgs.method;
      var _b = JsHttpRequest.CACHE[_a];
      if (_b) {
        this._dataReady(_b[0], _b[1]);
        return false;
      }
    }
    var _c = (this.loader || "").toLowerCase();
    if (_c && !JsHttpRequest.LOADERS[_c]) {
      return this._error("unk_loader", _c);
    }
    var _d = [];
    var _e = JsHttpRequest.LOADERS;
    for (var _f in _e) {
      var ldr = _e[_f].loader;
      if (!ldr) {
        continue;
      }
      if (_c && _f != _c) {
        continue;
      }
      var _11 = new ldr(this);
      JsHttpRequest.extend(_11, this._openArgs);
      JsHttpRequest.extend(_11, { queryText: _8.join("&"), queryElem: _9, id: (new Date().getTime()) + "" + JsHttpRequest.COUNT++, hash: _a, span: null });
      var _12 = _11.load();
      if (!_12) {
        this._ldObj = _11;
        JsHttpRequest.PENDING[_11.id] = this;
        return true;
      }
      if (!_c) {
        _d[_d.length] = "- " + _f.toUpperCase() + ": " + this._l(_12);
      } else {
        return this._error(_12);
      }
    }
    return _f ? this._error("no_loader_matched", _d.join("\n")) : this._error("no_loaders");
  };
  t.getAllResponseHeaders = function () {
    with (this) {
      return _ldObj && _ldObj.getAllResponseHeaders ? _ldObj.getAllResponseHeaders() : [];
    }
  };
  t.getResponseHeader = function (_13) {
    with (this) {
      return _ldObj && _ldObj.getResponseHeader ? _ldObj.getResponseHeader(_13) : null;
    }
  };
  t.setRequestHeader = function (_14, _15) {
    with (this) {
      _reqHeaders[_reqHeaders.length] = [_14, _15];
    }
  };
  t._dataReady = function (_16, js) {
    with (this) {
      if (caching && _ldObj) {
        JsHttpRequest.CACHE[_ldObj.hash] = [_16, js];
      }
      responseText = responseXML = _16;
      responseJS = js;
      if (js !== null) {
        status = 200;
        statusText = "OK";
      } else {
        status = 500;
        statusText = "Internal Server Error";
      }
      _changeReadyState(2);
      _changeReadyState(3);
      _changeReadyState(4);
      _cleanup();
    }
  };
  t._l = function (_18) {
    var i = 0, p = 0, msg = this._errors[_18[0]];
    while ((p = msg.indexOf("%", p)) >= 0) {
      var a = _18[++i] + "";
      msg = msg.substring(0, p) + a + msg.substring(p + 1, msg.length);
      p += 1 + a.length;
    }
    return msg;
  };
  t._error = function (msg) {
    msg = this._l(typeof (msg) == "string" ? arguments : msg);
    msg = "JsHttpRequest: " + msg;
    if (!window.Error) {
      throw msg;
    } else {
      if ((new Error(1, "test")).description == "test") {
        throw new Error(1, msg);
      } else {
        throw new Error(msg);
      }
    }
  };
  t._hash2query = function (_1e, _1f, _20, _21) {
    if (_1f == null) {
      _1f = "";
    }
    if (("" + typeof (_1e)).toLowerCase() == "object") {
      var _22 = false;
      if (_1e && _1e.parentNode && _1e.parentNode.appendChild && _1e.tagName && _1e.tagName.toUpperCase() == "FORM") {
        _1e = { form: _1e };
      }
      for (var k in _1e) {
        var v = _1e[k];
        if (v instanceof Function) {
          continue;
        }
        var _25 = _1f ? _1f + "[" + this.escape(k) + "]" : this.escape(k);
        var _26 = v && v.parentNode && v.parentNode.appendChild && v.tagName;
        if (_26) {
          var tn = v.tagName.toUpperCase();
          if (tn == "FORM") {
            _22 = true;
          } else {
            if (tn == "INPUT" || tn == "TEXTAREA" || tn == "SELECT") {
            } else {
              return this._error("inv_form_el", (v.name || ""), v.tagName);
            }
          }
          _21[_21.length] = { name: _25, e: v };
        } else {
          if (v instanceof Object) {
            this._hash2query(v, _25, _20, _21);
          } else {
            if (v === null) {
              continue;
            }
            if (v === true) {
              v = 1;
            }
            if (v === false) {
              v = "";
            }
            _20[_20.length] = _25 + "=" + this.escape("" + v);
          }
        }
        if (_22 && _21.length > 1) {
          return this._error("must_be_single_el");
        }
      }
    } else {
      _20[_20.length] = _1e;
    }
    return true;
  };
  t._cleanup = function () {
    var _28 = this._ldObj;
    if (!_28) {
      return;
    }
    JsHttpRequest.PENDING[_28.id] = false;
    var _29 = _28.span;
    if (!_29) {
      return;
    }
    _28.span = null;
    var _2a = function () {
      _29.parentNode.removeChild(_29);
    };
    JsHttpRequest.setTimeout(_2a, 50);
  };
  t._changeReadyState = function (s, _2c) {
    with (this) {
      if (_2c) {
        status = statusText = responseJS = null;
        responseText = "";
      }
      readyState = s;
      if (onreadystatechange) {
        onreadystatechange();
      }
    }
  };
  t.escape = function (s) {
    return escape(s).replace(new RegExp("\\+", "g"), "%2B");
  };
}
JsHttpRequest.COUNT = 0;
JsHttpRequest.MAX_URL_LEN = 2000;
JsHttpRequest.CACHE = {};
JsHttpRequest.PENDING = {};
JsHttpRequest.LOADERS = {};
JsHttpRequest._dummy = function () {
};
JsHttpRequest.TIMEOUTS = { s: window.setTimeout, c: window.clearTimeout };
JsHttpRequest.setTimeout = function (_2e, dt) {
  window.JsHttpRequest_tmp = JsHttpRequest.TIMEOUTS.s;
  if (typeof (_2e) == "string") {
    id = window.JsHttpRequest_tmp(_2e, dt);
  } else {
    var id = null;
    var _31 = function () {
      _2e();
      delete JsHttpRequest.TIMEOUTS[id];
    };
    id = window.JsHttpRequest_tmp(_31, dt);
    JsHttpRequest.TIMEOUTS[id] = _31;
  }
  window.JsHttpRequest_tmp = null;
  return id;
};
JsHttpRequest.clearTimeout = function (id) {
  window.JsHttpRequest_tmp = JsHttpRequest.TIMEOUTS.c;
  delete JsHttpRequest.TIMEOUTS[id];
  var r = window.JsHttpRequest_tmp(id);
  window.JsHttpRequest_tmp = null;
  return r;
};
JsHttpRequest.query = function (url, _35, _36, _37) {
  var req = new this();
  req.caching = !_37;
  req.onreadystatechange = function () {
    if (req.readyState == 4) {
      _36(req.responseJS, req.responseText);
    }
  };
  req.open(null, url, true);
  req.send(_35);
};
JsHttpRequest.dataReady = function (d) {
  var th = this.PENDING[d.id];
  delete this.PENDING[d.id];
  if (th) {
    th._dataReady(d.text, d.js);
  } else {
    if (th !== false) {
      throw "dataReady(): unknown pending id: " + d.id;
    }
  }
};
JsHttpRequest.extend = function (_3b, src) {
  for (var k in src) {
    _3b[k] = src[k];
  }
};
JsHttpRequest.LOADERS.xml = {
  loader: function (req) {
    JsHttpRequest.extend(req._errors, { xml_no: "Cannot use XMLHttpRequest or ActiveX loader: not supported", xml_no_diffdom: "Cannot use XMLHttpRequest to load data from different domain %", xml_no_headers: "Cannot use XMLHttpRequest loader or ActiveX loader, POST method: headers setting is not supported, needed to work with encodings correctly", xml_no_form_upl: "Cannot use XMLHttpRequest loader: direct form elements using and uploading are not implemented" });
    this.load = function () {
      if (this.queryElem.length) {
        return ["xml_no_form_upl"];
      }
      if (this.url.match(new RegExp("^([a-z]+://[^\\/]+)(.*)", "i"))) {
        if (RegExp.$1.toLowerCase() != document.location.protocol + "//" + document.location.hostname.toLowerCase()) {
          return ["xml_no_diffdom", RegExp.$1];
        }
      }
      var xr = null;
      if (window.XMLHttpRequest) {
        try {
          xr = new XMLHttpRequest();
        }
        catch (e) {
        }
      } else {
        if (window.ActiveXObject) {
          try {
            xr = new ActiveXObject("Microsoft.XMLHTTP");
          }
          catch (e) {
          }
          if (!xr) {
            try {
              xr = new ActiveXObject("Msxml2.XMLHTTP");
            }
            catch (e) {
            }
          }
        }
      }
      if (!xr) {
        return ["xml_no"];
      }
      var _40 = window.ActiveXObject || xr.setRequestHeader;
      if (!this.method) {
        this.method = _40 && this.queryText.length ? "POST" : "GET";
      }
      if (this.method == "GET") {
        if (this.queryText) {
          this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + this.queryText;
        }
        this.queryText = "";
        if (this.url.length > JsHttpRequest.MAX_URL_LEN) {
          return ["url_too_long", JsHttpRequest.MAX_URL_LEN];
        }
      } else {
        if (this.method == "POST" && !_40) {
          return ["xml_no_headers"];
        }
      }
      this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + "JsHttpRequest=" + (req.caching ? "0" : this.id) + "-xml";
      var id = this.id;
      xr.onreadystatechange = function () {
        if (xr.readyState != 4) {
          return;
        }
        xr.onreadystatechange = JsHttpRequest._dummy;
        req.status = null;
        try {
          req.status = xr.status;
          req.responseText = xr.responseText;
        }
        catch (e) {
        }
        if (!req.status) {
          return;
        }
        try {
          eval("JsHttpRequest._tmp = function(id) { var d = " + req.responseText + "; d.id = id; JsHttpRequest.dataReady(d); }");
        }
        catch (e) {
          return req._error("js_invalid", req.responseText);
        }
        JsHttpRequest._tmp(id);
        JsHttpRequest._tmp = null;
      };
      xr.open(this.method, this.url, true, this.username, this.password);
      if (_40) {
        for (var i = 0; i < req._reqHeaders.length; i++) {
          xr.setRequestHeader(req._reqHeaders[i][0], req._reqHeaders[i][1]);
        }
        xr.setRequestHeader("Content-Type", "application/octet-stream");
      }
      xr.send(this.queryText);
      this.span = null;
      this.xr = xr;
      return null;
    };
    this.getAllResponseHeaders = function () {
      return this.xr.getAllResponseHeaders();
    };
    this.getResponseHeader = function (_43) {
      return this.xr.getResponseHeader(_43);
    };
    this.abort = function () {
      this.xr.abort();
      this.xr = null;
    };
  }
};
JsHttpRequest.LOADERS.script = {
  loader: function (req) {
    JsHttpRequest.extend(req._errors, { script_only_get: "Cannot use SCRIPT loader: it supports only GET method", script_no_form: "Cannot use SCRIPT loader: direct form elements using and uploading are not implemented" });
    this.load = function () {
      if (this.queryText) {
        this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + this.queryText;
      }
      this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + "JsHttpRequest=" + this.id + "-" + "script";
      this.queryText = "";
      if (!this.method) {
        this.method = "GET";
      }
      if (this.method !== "GET") {
        return ["script_only_get"];
      }
      if (this.queryElem.length) {
        return ["script_no_form"];
      }
      if (this.url.length > JsHttpRequest.MAX_URL_LEN) {
        return ["url_too_long", JsHttpRequest.MAX_URL_LEN];
      }
      var th = this, d = document, s = null, b = d.body;
      if (!window.opera) {
        this.span = s = d.createElement("SCRIPT");
        var _49 = function () {
          s.language = "JavaScript";
          if (s.setAttribute) {
            s.setAttribute("src", th.url);
          } else {
            s.src = th.url;
          }
          b.insertBefore(s, b.lastChild);
        };
      } else {
        this.span = s = d.createElement("SPAN");
        s.style.display = "none";
        b.insertBefore(s, b.lastChild);
        s.innerHTML = "Workaround for IE.<s" + "cript></" + "script>";
        var _49 = function () {
          s = s.getElementsByTagName("SCRIPT")[0];
          s.language = "JavaScript";
          if (s.setAttribute) {
            s.setAttribute("src", th.url);
          } else {
            s.src = th.url;
          }
        };
      }
      JsHttpRequest.setTimeout(_49, 10);
      return null;
    };
  }
};
JsHttpRequest.LOADERS.form = {
  loader: function (req) {
    JsHttpRequest.extend(req._errors, { form_el_not_belong: "Element \"%\" does not belong to any form!", form_el_belong_diff: "Element \"%\" belongs to a different form. All elements must belong to the same form!", form_el_inv_enctype: "Attribute \"enctype\" of the form must be \"%\" (for IE), \"%\" given." });
    this.load = function () {
      var th = this;
      if (!th.method) {
        th.method = "POST";
      }
      th.url += (th.url.indexOf("?") >= 0 ? "&" : "?") + "JsHttpRequest=" + th.id + "-" + "form";
      if (th.method == "GET") {
        if (th.queryText) {
          th.url += (th.url.indexOf("?") >= 0 ? "&" : "?") + th.queryText;
        }
        if (th.url.length > JsHttpRequest.MAX_URL_LEN) {
          return ["url_too_long", JsHttpRequest.MAX_URL_LEN];
        }
        var p = th.url.split("?", 2);
        th.url = p[0];
        th.queryText = p[1] || "";
      }
      var _4d = null;
      var _4e = false;
      if (th.queryElem.length) {
        if (th.queryElem[0].e.tagName.toUpperCase() == "FORM") {
          _4d = th.queryElem[0].e;
          _4e = true;
          th.queryElem = [];
        } else {
          _4d = th.queryElem[0].e.form;
          for (var i = 0; i < th.queryElem.length; i++) {
            var e = th.queryElem[i].e;
            if (!e.form) {
              return ["form_el_not_belong", e.name];
            }
            if (e.form != _4d) {
              return ["form_el_belong_diff", e.name];
            }
          }
        }
        if (th.method == "POST") {
          var _51 = "multipart/form-data";
          var _52 = (_4d.attributes.encType && _4d.attributes.encType.nodeValue) || (_4d.attributes.enctype && _4d.attributes.enctype.value) || _4d.enctype;
          if (_52 != _51) {
            return ["form_el_inv_enctype", _51, _52];
          }
        }
      }
      var d = _4d && (_4d.ownerDocument || _4d.document) || document;
      var _54 = "jshr_i_" + th.id;
      var s = th.span = d.createElement("DIV");
      s.style.position = "absolute";
      s.style.display = "none";
      s.style.visibility = "hidden";
      s.innerHTML = (_4d ? "" : "<form" + (th.method == "POST" ? " enctype=\"multipart/form-data\" method=\"post\"" : "") + "></form>") + "<iframe name=\"" + _54 + "\" id=\"" + _54 + "\" style=\"width:0px; height:0px; overflow:hidden; border:none\"></iframe>";
      if (!_4d) {
        _4d = th.span.firstChild;
      }
      d.body.insertBefore(s, d.body.lastChild);
      var _56 = function (e, _58) {
        var sv = [];
        var _5a = e;
        if (e.mergeAttributes) {
          var _5a = d.createElement("form");
          _5a.mergeAttributes(e, false);
        }
        for (var i = 0; i < _58.length; i++) {
          var k = _58[i][0], v = _58[i][1];
          sv[sv.length] = [k, _5a.getAttribute(k)];
          _5a.setAttribute(k, v);
        }
        if (e.mergeAttributes) {
          e.mergeAttributes(_5a, false);
        }
        return sv;
      };
      var _5e = function () {
        top.JsHttpRequestGlobal = JsHttpRequest;
        var _5f = [];
        if (!_4e) {
          for (var i = 0, n = _4d.elements.length; i < n; i++) {
            _5f[i] = _4d.elements[i].name;
            _4d.elements[i].name = "";
          }
        }
        var qt = th.queryText.split("&");
        for (var i = qt.length - 1; i >= 0; i--) {
          var _63 = qt[i].split("=", 2);
          var e = d.createElement("INPUT");
          e.type = "hidden";
          e.name = unescape(_63[0]);
          e.value = _63[1] != null ? unescape(_63[1]) : "";
          _4d.appendChild(e);
        }
        for (var i = 0; i < th.queryElem.length; i++) {
          th.queryElem[i].e.name = th.queryElem[i].name;
        }
        var sv = _56(_4d, [["action", th.url], ["method", th.method], ["onsubmit", null], ["target", _54]]);
        _4d.submit();
        _56(_4d, sv);
        for (var i = 0; i < qt.length; i++) {
          _4d.lastChild.parentNode.removeChild(_4d.lastChild);
        }
        if (!_4e) {
          for (var i = 0, n = _4d.elements.length; i < n; i++) {
            _4d.elements[i].name = _5f[i];
          }
        }
      };
      JsHttpRequest.setTimeout(_5e, 100);
      return null;
    };
  }
};

;
/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function (e, t) { "use strict"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n.indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call(Object), h = {}, g = function e(t) { return "function" == typeof t && "number" != typeof t.nodeType }, y = function e(t) { return null != t && t === t.window }, v = { type: !0, src: !0, noModule: !0 }; function m(e, t, n) { var i, o = (t = t || r).createElement("script"); if (o.text = e, n) for (i in v) n[i] && (o[i] = n[i]); t.head.appendChild(o).parentNode.removeChild(o) } function x(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? l[c.call(e)] || "object" : typeof e } var b = "3.3.1", w = function (e, t) { return new w.fn.init(e, t) }, T = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; w.fn = w.prototype = { jquery: "3.3.1", constructor: w, length: 0, toArray: function () { return o.call(this) }, get: function (e) { return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = w.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return w.each(this, e) }, map: function (e) { return this.pushStack(w.map(this, function (t, n) { return e.call(t, n, t) })) }, slice: function () { return this.pushStack(o.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: s, sort: n.sort, splice: n.splice }, w.extend = w.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || g(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) n = a[t], a !== (r = e[t]) && (l && r && (w.isPlainObject(r) || (i = Array.isArray(r))) ? (i ? (i = !1, o = n && Array.isArray(n) ? n : []) : o = n && w.isPlainObject(n) ? n : {}, a[t] = w.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a }, w.extend({ expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== c.call(e)) && (!(t = i(e)) || "function" == typeof (n = f.call(t, "constructor") && t.constructor) && p.call(n) === d) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e) { m(e) }, each: function (e, t) { var n, r = 0; if (C(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, trim: function (e) { return null == e ? "" : (e + "").replace(T, "") }, makeArray: function (e, t) { var n = t || []; return null != e && (C(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : s.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : u.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e }, grep: function (e, t, n) { for (var r, i = [], o = 0, a = e.length, s = !n; o < a; o++)(r = !t(e[o], o)) !== s && i.push(e[o]); return i }, map: function (e, t, n) { var r, i, o = 0, s = []; if (C(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && s.push(i); else for (o in e) null != (i = t(e[o], o, n)) && s.push(i); return a.apply([], s) }, guid: 1, support: h }), "function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { l["[object " + t + "]"] = t.toLowerCase() }); function C(e) { var t = !!e && "length" in e && e.length, n = x(e); return !g(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e) } var E = function (e) { var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v, m, x, b = "sizzle" + 1 * new Date, w = e.document, T = 0, C = 0, E = ae(), k = ae(), S = ae(), D = function (e, t) { return e === t && (f = !0), 0 }, N = {}.hasOwnProperty, A = [], j = A.pop, q = A.push, L = A.push, H = A.slice, O = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, P = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", R = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", I = "\\[" + M + "*(" + R + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + R + "))|)" + M + "*\\]", W = ":(" + R + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + I + ")*)|.*)\\)|)", $ = new RegExp(M + "+", "g"), B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), F = new RegExp("^" + M + "*," + M + "*"), _ = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), z = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"), X = new RegExp(W), U = new RegExp("^" + R + "$"), V = { ID: new RegExp("^#(" + R + ")"), CLASS: new RegExp("^\\.(" + R + ")"), TAG: new RegExp("^(" + R + "|[*])"), ATTR: new RegExp("^" + I), PSEUDO: new RegExp("^" + W), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + P + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, G = /^(?:input|select|textarea|button)$/i, Y = /^h\d$/i, Q = /^[^{]+\{\s*\[native \w/, J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, K = /[+~]/, Z = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"), ee = function (e, t, n) { var r = "0x" + t - 65536; return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320) }, te = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ne = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, re = function () { p() }, ie = me(function (e) { return !0 === e.disabled && ("form" in e || "label" in e) }, { dir: "parentNode", next: "legend" }); try { L.apply(A = H.call(w.childNodes), w.childNodes), A[w.childNodes.length].nodeType } catch (e) { L = { apply: A.length ? function (e, t) { q.apply(e, H.call(t)) } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1 } } } function oe(e, t, r, i) { var o, s, l, c, f, h, v, m = t && t.ownerDocument, T = t ? t.nodeType : 9; if (r = r || [], "string" != typeof e || !e || 1 !== T && 9 !== T && 11 !== T) return r; if (!i && ((t ? t.ownerDocument || t : w) !== d && p(t), t = t || d, g)) { if (11 !== T && (f = J.exec(e))) if (o = f[1]) { if (9 === T) { if (!(l = t.getElementById(o))) return r; if (l.id === o) return r.push(l), r } else if (m && (l = m.getElementById(o)) && x(t, l) && l.id === o) return r.push(l), r } else { if (f[2]) return L.apply(r, t.getElementsByTagName(e)), r; if ((o = f[3]) && n.getElementsByClassName && t.getElementsByClassName) return L.apply(r, t.getElementsByClassName(o)), r } if (n.qsa && !S[e + " "] && (!y || !y.test(e))) { if (1 !== T) m = t, v = e; else if ("object" !== t.nodeName.toLowerCase()) { (c = t.getAttribute("id")) ? c = c.replace(te, ne) : t.setAttribute("id", c = b), s = (h = a(e)).length; while (s--) h[s] = "#" + c + " " + ve(h[s]); v = h.join(","), m = K.test(e) && ge(t.parentNode) || t } if (v) try { return L.apply(r, m.querySelectorAll(v)), r } catch (e) { } finally { c === b && t.removeAttribute("id") } } } return u(e.replace(B, "$1"), t, r, i) } function ae() { var e = []; function t(n, i) { return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i } return t } function se(e) { return e[b] = !0, e } function ue(e) { var t = d.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function le(e, t) { var n = e.split("|"), i = n.length; while (i--) r.attrHandle[n[i]] = t } function ce(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1 } function fe(e) { return function (t) { return "input" === t.nodeName.toLowerCase() && t.type === e } } function pe(e) { return function (t) { var n = t.nodeName.toLowerCase(); return ("input" === n || "button" === n) && t.type === e } } function de(e) { return function (t) { return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && ie(t) === e : t.disabled === e : "label" in t && t.disabled === e } } function he(e) { return se(function (t) { return t = +t, se(function (n, r) { var i, o = e([], n.length, t), a = o.length; while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i])) }) }) } function ge(e) { return e && "undefined" != typeof e.getElementsByTagName && e } n = oe.support = {}, o = oe.isXML = function (e) { var t = e && (e.ownerDocument || e).documentElement; return !!t && "HTML" !== t.nodeName }, p = oe.setDocument = function (e) { var t, i, a = e ? e.ownerDocument || e : w; return a !== d && 9 === a.nodeType && a.documentElement ? (d = a, h = d.documentElement, g = !o(d), w !== d && (i = d.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", re, !1) : i.attachEvent && i.attachEvent("onunload", re)), n.attributes = ue(function (e) { return e.className = "i", !e.getAttribute("className") }), n.getElementsByTagName = ue(function (e) { return e.appendChild(d.createComment("")), !e.getElementsByTagName("*").length }), n.getElementsByClassName = Q.test(d.getElementsByClassName), n.getById = ue(function (e) { return h.appendChild(e).id = b, !d.getElementsByName || !d.getElementsByName(b).length }), n.getById ? (r.filter.ID = function (e) { var t = e.replace(Z, ee); return function (e) { return e.getAttribute("id") === t } }, r.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && g) { var n = t.getElementById(e); return n ? [n] : [] } }) : (r.filter.ID = function (e) { var t = e.replace(Z, ee); return function (e) { var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return n && n.value === t } }, r.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && g) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o] } return [] } }), r.find.TAG = n.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r } return o }, r.find.CLASS = n.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && g) return t.getElementsByClassName(e) }, v = [], y = [], (n.qsa = Q.test(d.querySelectorAll)) && (ue(function (e) { h.appendChild(e).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && y.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || y.push("\\[" + M + "*(?:value|" + P + ")"), e.querySelectorAll("[id~=" + b + "-]").length || y.push("~="), e.querySelectorAll(":checked").length || y.push(":checked"), e.querySelectorAll("a#" + b + "+*").length || y.push(".#.+[+~]") }), ue(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = d.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && y.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && y.push(":enabled", ":disabled"), h.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && y.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), y.push(",.*:") })), (n.matchesSelector = Q.test(m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue(function (e) { n.disconnectedMatch = m.call(e, "*"), m.call(e, "[s!='']:x"), v.push("!=", W) }), y = y.length && new RegExp(y.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(h.compareDocumentPosition), x = t || Q.test(h.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1 }, D = t ? function (e, t) { if (e === t) return f = !0, 0; var r = !e.compareDocumentPosition - !t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === d || e.ownerDocument === w && x(w, e) ? -1 : t === d || t.ownerDocument === w && x(w, t) ? 1 : c ? O(c, e) - O(c, t) : 0 : 4 & r ? -1 : 1) } : function (e, t) { if (e === t) return f = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e === d ? -1 : t === d ? 1 : i ? -1 : o ? 1 : c ? O(c, e) - O(c, t) : 0; if (i === o) return ce(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? ce(a[r], s[r]) : a[r] === w ? -1 : s[r] === w ? 1 : 0 }, d) : d }, oe.matches = function (e, t) { return oe(e, null, null, t) }, oe.matchesSelector = function (e, t) { if ((e.ownerDocument || e) !== d && p(e), t = t.replace(z, "='$1']"), n.matchesSelector && g && !S[t + " "] && (!v || !v.test(t)) && (!y || !y.test(t))) try { var r = m.call(e, t); if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r } catch (e) { } return oe(t, d, null, [e]).length > 0 }, oe.contains = function (e, t) { return (e.ownerDocument || e) !== d && p(e), x(e, t) }, oe.attr = function (e, t) { (e.ownerDocument || e) !== d && p(e); var i = r.attrHandle[t.toLowerCase()], o = i && N.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0; return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null }, oe.escape = function (e) { return (e + "").replace(te, ne) }, oe.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, oe.uniqueSort = function (e) { var t, r = [], i = 0, o = 0; if (f = !n.detectDuplicates, c = !n.sortStable && e.slice(0), e.sort(D), f) { while (t = e[o++]) t === e[o] && (i = r.push(o)); while (i--) e.splice(r[i], 1) } return c = null, e }, i = oe.getText = function (e) { var t, n = "", r = 0, o = e.nodeType; if (o) { if (1 === o || 9 === o || 11 === o) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += i(e) } else if (3 === o || 4 === o) return e.nodeValue } else while (t = e[r++]) n += i(t); return n }, (r = oe.selectors = { cacheLength: 50, createPseudo: se, match: V, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(Z, ee), e[3] = (e[3] || e[4] || e[5] || "").replace(Z, ee), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || oe.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && oe.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return V.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = a(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(Z, ee).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = E[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && E(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "") }) }, ATTR: function (e, t, n) { return function (r) { var i = oe.attr(r, e); return null == i ? "!=" === t : !t || (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i.replace($, " ") + " ").indexOf(n) > -1 : "|=" === t && (i === n || i.slice(0, n.length + 1) === n + "-")) } }, CHILD: function (e, t, n, r, i) { var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t; return 1 === r && 0 === i ? function (e) { return !!e.parentNode } : function (t, n, u) { var l, c, f, p, d, h, g = o !== a ? "nextSibling" : "previousSibling", y = t.parentNode, v = s && t.nodeName.toLowerCase(), m = !u && !s, x = !1; if (y) { if (o) { while (g) { p = t; while (p = p[g]) if (s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1; h = g = "only" === e && !h && "nextSibling" } return !0 } if (h = [a ? y.firstChild : y.lastChild], a && m) { x = (d = (l = (c = (f = (p = y)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]) && l[2], p = d && y.childNodes[d]; while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if (1 === p.nodeType && ++x && p === t) { c[e] = [T, d, x]; break } } else if (m && (x = d = (l = (c = (f = (p = t)[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] || [])[0] === T && l[1]), !1 === x) while (p = ++d && p && p[g] || (x = d = 0) || h.pop()) if ((s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) && ++x && (m && ((c = (f = p[b] || (p[b] = {}))[p.uniqueID] || (f[p.uniqueID] = {}))[e] = [T, x]), p === t)) break; return (x -= i) === r || x % r == 0 && x / r >= 0 } } }, PSEUDO: function (e, t) { var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || oe.error("unsupported pseudo: " + e); return i[b] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? se(function (e, n) { var r, o = i(e, t), a = o.length; while (a--) e[r = O(e, o[a])] = !(n[r] = o[a]) }) : function (e) { return i(e, 0, n) }) : i } }, pseudos: { not: se(function (e) { var t = [], n = [], r = s(e.replace(B, "$1")); return r[b] ? se(function (e, t, n, i) { var o, a = r(e, null, i, []), s = e.length; while (s--) (o = a[s]) && (e[s] = !(t[s] = o)) }) : function (e, i, o) { return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop() } }), has: se(function (e) { return function (t) { return oe(e, t).length > 0 } }), contains: se(function (e) { return e = e.replace(Z, ee), function (t) { return (t.textContent || t.innerText || i(t)).indexOf(e) > -1 } }), lang: se(function (e) { return U.test(e || "") || oe.error("unsupported lang: " + e), e = e.replace(Z, ee).toLowerCase(), function (t) { var n; do { if (n = g ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-") } while ((t = t.parentNode) && 1 === t.nodeType); return !1 } }), target: function (t) { var n = e.location && e.location.hash; return n && n.slice(1) === t.id }, root: function (e) { return e === h }, focus: function (e) { return e === d.activeElement && (!d.hasFocus || d.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: de(!1), disabled: de(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !r.pseudos.empty(e) }, header: function (e) { return Y.test(e.nodeName) }, input: function (e) { return G.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: he(function () { return [0] }), last: he(function (e, t) { return [t - 1] }), eq: he(function (e, t, n) { return [n < 0 ? n + t : n] }), even: he(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e }), odd: he(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e }), lt: he(function (e, t, n) { for (var r = n < 0 ? n + t : n; --r >= 0;)e.push(r); return e }), gt: he(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e }) } }).pseudos.nth = r.pseudos.eq; for (t in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) r.pseudos[t] = fe(t); for (t in { submit: !0, reset: !0 }) r.pseudos[t] = pe(t); function ye() { } ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, a = oe.tokenize = function (e, t) { var n, i, o, a, s, u, l, c = k[e + " "]; if (c) return t ? 0 : c.slice(0); s = e, u = [], l = r.preFilter; while (s) { n && !(i = F.exec(s)) || (i && (s = s.slice(i[0].length) || s), u.push(o = [])), n = !1, (i = _.exec(s)) && (n = i.shift(), o.push({ value: n, type: i[0].replace(B, " ") }), s = s.slice(n.length)); for (a in r.filter) !(i = V[a].exec(s)) || l[a] && !(i = l[a](i)) || (n = i.shift(), o.push({ value: n, type: a, matches: i }), s = s.slice(n.length)); if (!n) break } return t ? s.length : s ? oe.error(e) : k(e, u).slice(0) }; function ve(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function me(e, t, n) { var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, s = C++; return t.first ? function (t, n, i) { while (t = t[r]) if (1 === t.nodeType || a) return e(t, n, i); return !1 } : function (t, n, u) { var l, c, f, p = [T, s]; if (u) { while (t = t[r]) if ((1 === t.nodeType || a) && e(t, n, u)) return !0 } else while (t = t[r]) if (1 === t.nodeType || a) if (f = t[b] || (t[b] = {}), c = f[t.uniqueID] || (f[t.uniqueID] = {}), i && i === t.nodeName.toLowerCase()) t = t[r] || t; else { if ((l = c[o]) && l[0] === T && l[1] === s) return p[2] = l[2]; if (c[o] = p, p[2] = e(t, n, u)) return !0 } return !1 } } function xe(e) { return e.length > 1 ? function (t, n, r) { var i = e.length; while (i--) if (!e[i](t, n, r)) return !1; return !0 } : e[0] } function be(e, t, n) { for (var r = 0, i = t.length; r < i; r++)oe(e, t[r], n); return n } function we(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a } function Te(e, t, n, r, i, o) { return r && !r[b] && (r = Te(r)), i && !i[b] && (i = Te(i, o)), se(function (o, a, s, u) { var l, c, f, p = [], d = [], h = a.length, g = o || be(t || "*", s.nodeType ? [s] : s, []), y = !e || !o && t ? g : we(g, p, e, s, u), v = n ? i || (o ? e : h || r) ? [] : a : y; if (n && n(y, v, s, u), r) { l = we(v, d), r(l, [], s, u), c = l.length; while (c--) (f = l[c]) && (v[d[c]] = !(y[d[c]] = f)) } if (o) { if (i || e) { if (i) { l = [], c = v.length; while (c--) (f = v[c]) && l.push(y[c] = f); i(null, v = [], l, u) } c = v.length; while (c--) (f = v[c]) && (l = i ? O(o, f) : p[c]) > -1 && (o[l] = !(a[l] = f)) } } else v = we(v === a ? v.splice(h, v.length) : v), i ? i(null, a, v, u) : L.apply(a, v) }) } function Ce(e) { for (var t, n, i, o = e.length, a = r.relative[e[0].type], s = a || r.relative[" "], u = a ? 1 : 0, c = me(function (e) { return e === t }, s, !0), f = me(function (e) { return O(t, e) > -1 }, s, !0), p = [function (e, n, r) { var i = !a && (r || n !== l) || ((t = n).nodeType ? c(e, n, r) : f(e, n, r)); return t = null, i }]; u < o; u++)if (n = r.relative[e[u].type]) p = [me(xe(p), n)]; else { if ((n = r.filter[e[u].type].apply(null, e[u].matches))[b]) { for (i = ++u; i < o; i++)if (r.relative[e[i].type]) break; return Te(u > 1 && xe(p), u > 1 && ve(e.slice(0, u - 1).concat({ value: " " === e[u - 2].type ? "*" : "" })).replace(B, "$1"), n, u < i && Ce(e.slice(u, i)), i < o && Ce(e = e.slice(i)), i < o && ve(e)) } p.push(n) } return xe(p) } function Ee(e, t) { var n = t.length > 0, i = e.length > 0, o = function (o, a, s, u, c) { var f, h, y, v = 0, m = "0", x = o && [], b = [], w = l, C = o || i && r.find.TAG("*", c), E = T += null == w ? 1 : Math.random() || .1, k = C.length; for (c && (l = a === d || a || c); m !== k && null != (f = C[m]); m++) { if (i && f) { h = 0, a || f.ownerDocument === d || (p(f), s = !g); while (y = e[h++]) if (y(f, a || d, s)) { u.push(f); break } c && (T = E) } n && ((f = !y && f) && v--, o && x.push(f)) } if (v += m, n && m !== v) { h = 0; while (y = t[h++]) y(x, b, a, s); if (o) { if (v > 0) while (m--) x[m] || b[m] || (b[m] = j.call(u)); b = we(b) } L.apply(u, b), c && !o && b.length > 0 && v + t.length > 1 && oe.uniqueSort(u) } return c && (T = E, l = w), x }; return n ? se(o) : o } return s = oe.compile = function (e, t) { var n, r = [], i = [], o = S[e + " "]; if (!o) { t || (t = a(e)), n = t.length; while (n--) (o = Ce(t[n]))[b] ? r.push(o) : i.push(o); (o = S(e, Ee(i, r))).selector = e } return o }, u = oe.select = function (e, t, n, i) { var o, u, l, c, f, p = "function" == typeof e && e, d = !i && a(e = p.selector || e); if (n = n || [], 1 === d.length) { if ((u = d[0] = d[0].slice(0)).length > 2 && "ID" === (l = u[0]).type && 9 === t.nodeType && g && r.relative[u[1].type]) { if (!(t = (r.find.ID(l.matches[0].replace(Z, ee), t) || [])[0])) return n; p && (t = t.parentNode), e = e.slice(u.shift().value.length) } o = V.needsContext.test(e) ? 0 : u.length; while (o--) { if (l = u[o], r.relative[c = l.type]) break; if ((f = r.find[c]) && (i = f(l.matches[0].replace(Z, ee), K.test(u[0].type) && ge(t.parentNode) || t))) { if (u.splice(o, 1), !(e = i.length && ve(u))) return L.apply(n, i), n; break } } } return (p || s(e, d))(i, t, !g, n, !t || K.test(e) && ge(t.parentNode) || t), n }, n.sortStable = b.split("").sort(D).join("") === b, n.detectDuplicates = !!f, p(), n.sortDetached = ue(function (e) { return 1 & e.compareDocumentPosition(d.createElement("fieldset")) }), ue(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") }) || le("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) }), n.attributes && ue(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") }) || le("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue }), ue(function (e) { return null == e.getAttribute("disabled") }) || le(P, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null }), oe }(e); w.find = E, w.expr = E.selectors, w.expr[":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; var k = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && w(e).is(n)) break; r.push(e) } return r }, S = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, D = w.expr.match.needsContext; function N(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function j(e, t, n) { return g(t) ? w.grep(e, function (e, r) { return !!t.call(e, r, e) !== n }) : t.nodeType ? w.grep(e, function (e) { return e === t !== n }) : "string" != typeof t ? w.grep(e, function (e) { return u.call(t, e) > -1 !== n }) : w.filter(t, e, n) } w.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, function (e) { return 1 === e.nodeType })) }, w.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(w(e).filter(function () { for (t = 0; t < r; t++)if (w.contains(i[t], this)) return !0 })); for (n = this.pushStack([]), t = 0; t < r; t++)w.find(e, i[t], n); return r > 1 ? w.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(j(this, e || [], !1)) }, not: function (e) { return this.pushStack(j(this, e || [], !0)) }, is: function (e) { return !!j(this, "string" == typeof e && D.test(e) ? w(e) : e || [], !1).length } }); var q, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (w.fn.init = function (e, t, n) { var i, o; if (!e) return this; if (n = n || q, "string" == typeof e) { if (!(i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : L.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (i[1]) { if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : r, !0)), A.test(i[1]) && w.isPlainObject(t)) for (i in t) g(this[i]) ? this[i](t[i]) : this.attr(i, t[i]); return this } return (o = r.getElementById(i[2])) && (this[0] = o, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : g(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this) }).prototype = w.fn, q = w(r); var H = /^(?:parents|prev(?:Until|All))/, O = { children: !0, contents: !0, next: !0, prev: !0 }; w.fn.extend({ has: function (e) { var t = w(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (w.contains(this, t[e])) return !0 }) }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && w(e); if (!D.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && w.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(o.length > 1 ? w.uniqueSort(o) : o) }, index: function (e) { return e ? "string" == typeof e ? u.call(w(e), this[0]) : u.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }); function P(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e } w.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return k(e, "parentNode") }, parentsUntil: function (e, t, n) { return k(e, "parentNode", n) }, next: function (e) { return P(e, "nextSibling") }, prev: function (e) { return P(e, "previousSibling") }, nextAll: function (e) { return k(e, "nextSibling") }, prevAll: function (e) { return k(e, "previousSibling") }, nextUntil: function (e, t, n) { return k(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return k(e, "previousSibling", n) }, siblings: function (e) { return S((e.parentNode || {}).firstChild, e) }, children: function (e) { return S(e.firstChild) }, contents: function (e) { return N(e, "iframe") ? e.contentDocument : (N(e, "template") && (e = e.content || e), w.merge([], e.childNodes)) } }, function (e, t) { w.fn[e] = function (n, r) { var i = w.map(this, t, n); return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = w.filter(r, i)), this.length > 1 && (O[e] || w.uniqueSort(i), H.test(e) && i.reverse()), this.pushStack(i) } }); var M = /[^\x20\t\r\n\f]+/g; function R(e) { var t = {}; return w.each(e.match(M) || [], function (e, n) { t[n] = !0 }), t } w.Callbacks = function (e) { e = "string" == typeof e ? R(e) : w.extend({}, e); var t, n, r, i, o = [], a = [], s = -1, u = function () { for (i = i || e.once, r = t = !0; a.length; s = -1) { n = a.shift(); while (++s < o.length) !1 === o[s].apply(n[0], n[1]) && e.stopOnFalse && (s = o.length, n = !1) } e.memory || (n = !1), t = !1, i && (o = n ? [] : "") }, l = { add: function () { return o && (n && !t && (s = o.length - 1, a.push(n)), function t(n) { w.each(n, function (n, r) { g(r) ? e.unique && l.has(r) || o.push(r) : r && r.length && "string" !== x(r) && t(r) }) }(arguments), n && !t && u()), this }, remove: function () { return w.each(arguments, function (e, t) { var n; while ((n = w.inArray(t, o, n)) > -1) o.splice(n, 1), n <= s && s-- }), this }, has: function (e) { return e ? w.inArray(e, o) > -1 : o.length > 0 }, empty: function () { return o && (o = []), this }, disable: function () { return i = a = [], o = n = "", this }, disabled: function () { return !o }, lock: function () { return i = a = [], n || t || (o = n = ""), this }, locked: function () { return !!i }, fireWith: function (e, n) { return i || (n = [e, (n = n || []).slice ? n.slice() : n], a.push(n), t || u()), this }, fire: function () { return l.fireWith(this, arguments), this }, fired: function () { return !!r } }; return l }; function I(e) { return e } function W(e) { throw e } function $(e, t, n, r) { var i; try { e && g(i = e.promise) ? i.call(e).done(t).fail(n) : e && g(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } w.extend({ Deferred: function (t) { var n = [["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2], ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]], r = "pending", i = { state: function () { return r }, always: function () { return o.done(arguments).fail(arguments), this }, "catch": function (e) { return i.then(null, e) }, pipe: function () { var e = arguments; return w.Deferred(function (t) { w.each(n, function (n, r) { var i = g(e[r[4]]) && e[r[4]]; o[r[1]](function () { var e = i && i.apply(this, arguments); e && g(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, i ? [e] : arguments) }) }), e = null }).promise() }, then: function (t, r, i) { var o = 0; function a(t, n, r, i) { return function () { var s = this, u = arguments, l = function () { var e, l; if (!(t < o)) { if ((e = r.apply(s, u)) === n.promise()) throw new TypeError("Thenable self-resolution"); l = e && ("object" == typeof e || "function" == typeof e) && e.then, g(l) ? i ? l.call(e, a(o, n, I, i), a(o, n, W, i)) : (o++, l.call(e, a(o, n, I, i), a(o, n, W, i), a(o, n, I, n.notifyWith))) : (r !== I && (s = void 0, u = [e]), (i || n.resolveWith)(s, u)) } }, c = i ? l : function () { try { l() } catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, c.stackTrace), t + 1 >= o && (r !== W && (s = void 0, u = [e]), n.rejectWith(s, u)) } }; t ? c() : (w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook()), e.setTimeout(c)) } } return w.Deferred(function (e) { n[0][3].add(a(0, e, g(i) ? i : I, e.notifyWith)), n[1][3].add(a(0, e, g(t) ? t : I)), n[2][3].add(a(0, e, g(r) ? r : W)) }).promise() }, promise: function (e) { return null != e ? w.extend(e, i) : i } }, o = {}; return w.each(n, function (e, t) { var a = t[2], s = t[5]; i[t[1]] = a.add, s && a.add(function () { r = s }, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), a.add(t[3].fire), o[t[0]] = function () { return o[t[0] + "With"](this === o ? void 0 : this, arguments), this }, o[t[0] + "With"] = a.fireWith }), i.promise(o), t && t.call(o, o), o }, when: function (e) { var t = arguments.length, n = t, r = Array(n), i = o.call(arguments), a = w.Deferred(), s = function (e) { return function (n) { r[e] = this, i[e] = arguments.length > 1 ? o.call(arguments) : n, --t || a.resolveWith(r, i) } }; if (t <= 1 && ($(e, a.done(s(n)).resolve, a.reject, !t), "pending" === a.state() || g(i[n] && i[n].then))) return a.then(); while (n--) $(i[n], s(n), a.reject); return a.promise() } }); var B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; w.Deferred.exceptionHook = function (t, n) { e.console && e.console.warn && t && B.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n) }, w.readyException = function (t) { e.setTimeout(function () { throw t }) }; var F = w.Deferred(); w.fn.ready = function (e) { return F.then(e)["catch"](function (e) { w.readyException(e) }), this }, w.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || F.resolveWith(r, [w])) } }), w.ready.then = F.then; function _() { r.removeEventListener("DOMContentLoaded", _), e.removeEventListener("load", _), w.ready() } "complete" === r.readyState || "loading" !== r.readyState && !r.documentElement.doScroll ? e.setTimeout(w.ready) : (r.addEventListener("DOMContentLoaded", _), e.addEventListener("load", _)); var z = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === x(n)) { i = !0; for (s in n) z(e, t, s, n[s], !0, o, a) } else if (void 0 !== r && (i = !0, g(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(w(e), n) })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o }, X = /^-ms-/, U = /-([a-z])/g; function V(e, t) { return t.toUpperCase() } function G(e) { return e.replace(X, "ms-").replace(U, V) } var Y = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function Q() { this.expando = w.expando + Q.uid++ } Q.uid = 1, Q.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, Y(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[G(t)] = n; else for (r in t) i[G(r)] = t[r]; return i }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][G(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(G) : (t = G(t)) in r ? [t] : t.match(M) || []).length; while (n--) delete r[t[n]] } (void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !w.isEmptyObject(t) } }; var J = new Q, K = new Q, Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, ee = /[A-Z]/g; function te(e) { return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : Z.test(e) ? JSON.parse(e) : e) } function ne(e, t, n) { var r; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(ee, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = te(n) } catch (e) { } K.set(e, t, n) } else n = void 0; return n } w.extend({ hasData: function (e) { return K.hasData(e) || J.hasData(e) }, data: function (e, t, n) { return K.access(e, t, n) }, removeData: function (e, t) { K.remove(e, t) }, _data: function (e, t, n) { return J.access(e, t, n) }, _removeData: function (e, t) { J.remove(e, t) } }), w.fn.extend({ data: function (e, t) { var n, r, i, o = this[0], a = o && o.attributes; if (void 0 === e) { if (this.length && (i = K.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) { n = a.length; while (n--) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = G(r.slice(5)), ne(o, r, i[r])); J.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof e ? this.each(function () { K.set(this, e) }) : z(this, function (t) { var n; if (o && void 0 === t) { if (void 0 !== (n = K.get(o, e))) return n; if (void 0 !== (n = ne(o, e))) return n } else this.each(function () { K.set(this, e, t) }) }, null, t, arguments.length > 1, null, !0) }, removeData: function (e) { return this.each(function () { K.remove(this, e) }) } }), w.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = J.get(e, t), n && (!r || Array.isArray(n) ? r = J.access(e, t, w.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = w.queue(e, t), r = n.length, i = n.shift(), o = w._queueHooks(e, t), a = function () { w.dequeue(e, t) }; "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return J.get(e, n) || J.access(e, n, { empty: w.Callbacks("once memory").add(function () { J.remove(e, [t + "queue", n]) }) }) } }), w.fn.extend({ queue: function (e, t) { var n = 2; return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each(function () { var n = w.queue(this, e, t); w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e) }) }, dequeue: function (e) { return this.each(function () { w.dequeue(this, e) }) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, i = w.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]) }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = J.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var re = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ie = new RegExp("^(?:([+-])=|)(" + re + ")([a-z%]*)$", "i"), oe = ["Top", "Right", "Bottom", "Left"], ae = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && w.contains(e.ownerDocument, e) && "none" === w.css(e, "display") }, se = function (e, t, n, r) { var i, o, a = {}; for (o in t) a[o] = e.style[o], e.style[o] = t[o]; i = n.apply(e, r || []); for (o in t) e.style[o] = a[o]; return i }; function ue(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur() } : function () { return w.css(e, t, "") }, u = s(), l = n && n[3] || (w.cssNumber[t] ? "" : "px"), c = (w.cssNumber[t] || "px" !== l && +u) && ie.exec(w.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) w.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, w.style(e, t, c + l), n = n || [] } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i } var le = {}; function ce(e) { var t, n = e.ownerDocument, r = e.nodeName, i = le[r]; return i || (t = n.body.appendChild(n.createElement(r)), i = w.css(t, "display"), t.parentNode.removeChild(t), "none" === i && (i = "block"), le[r] = i, i) } function fe(e, t) { for (var n, r, i = [], o = 0, a = e.length; o < a; o++)(r = e[o]).style && (n = r.style.display, t ? ("none" === n && (i[o] = J.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && ae(r) && (i[o] = ce(r))) : "none" !== n && (i[o] = "none", J.set(r, "display", n))); for (o = 0; o < a; o++)null != i[o] && (e[o].style.display = i[o]); return e } w.fn.extend({ show: function () { return fe(this, !0) }, hide: function () { return fe(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? w(this).show() : w(this).hide() }) } }); var pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, he = /^$|^module$|\/(?:java|ecma)script/i, ge = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; function ye(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && N(e, t) ? w.merge([e], n) : n } function ve(e, t) { for (var n = 0, r = e.length; n < r; n++)J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval")) } var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === x(o)) w.merge(p, o.nodeType ? [o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + w.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; w.merge(p, a.childNodes), (a = f.firstChild).textContent = "" } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && w.inArray(o, r) > -1) i && i.push(o); else if (l = w.contains(o.ownerDocument, o), a = ye(f.appendChild(o), "script"), l && ve(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o) } return f } !function () { var e = r.createDocumentFragment().appendChild(r.createElement("div")), t = r.createElement("input"); t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), e.appendChild(t), h.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", h.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue }(); var be = r.documentElement, we = /^key/, Te = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Ce = /^([^.]*)(?:\.(.+)|)/; function Ee() { return !0 } function ke() { return !1 } function Se() { try { return r.activeElement } catch (e) { } } function De(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { "string" != typeof n && (r = r || n, n = void 0); for (s in t) De(e, s, n, r, t[s], o); return e } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = ke; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return w().off(e), a.apply(this, arguments) }).guid = a.guid || (a.guid = w.guid++)), e.each(function () { w.event.add(this, t, i, r, n) }) } w.event = { global: {}, add: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, y = J.get(e); if (y) { n.handler && (n = (o = n).handler, i = o.selector), i && w.find.matchesSelector(be, i), n.guid || (n.guid = w.guid++), (u = y.events) || (u = y.events = {}), (a = y.handle) || (a = y.handle = function (t) { return "undefined" != typeof w && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0 }), l = (t = (t || "").match(M) || [""]).length; while (l--) d = g = (s = Ce.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = w.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = w.event.special[d] || {}, c = w.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && w.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(d, a)), f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), w.event.global[d] = !0) } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, y = J.hasData(e) && J.get(e); if (y && (u = y.events)) { l = (t = (t || "").match(M) || [""]).length; while (l--) if (s = Ce.exec(t[l]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) { f = w.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, y.handle) || w.removeEvent(e, d, y.handle), delete u[d]) } else for (d in u) w.event.remove(e, d + t[l], n, r, !0); w.isEmptyObject(u) && J.remove(e, "handle events") } }, dispatch: function (e) { var t = w.event.fix(e), n, r, i, o, a, s, u = new Array(arguments.length), l = (J.get(this, "events") || {})[t.type] || [], c = w.event.special[t.type] || {}; for (u[0] = t, n = 1; n < arguments.length; n++)u[n] = arguments[n]; if (t.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, t)) { s = w.event.handlers.call(this, t, l), n = 0; while ((o = s[n++]) && !t.isPropagationStopped()) { t.currentTarget = o.elem, r = 0; while ((a = o.handlers[r++]) && !t.isImmediatePropagationStopped()) t.rnamespace && !t.rnamespace.test(a.namespace) || (t.handleObj = a, t.data = a.data, void 0 !== (i = ((w.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, u)) && !1 === (t.result = i) && (t.preventDefault(), t.stopPropagation())) } return c.postDispatch && c.postDispatch.call(this, t), t.result } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && e.button >= 1)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? w(i, this).index(l) > -1 : w.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }) } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s }, addProp: function (e, t) { Object.defineProperty(w.Event.prototype, e, { enumerable: !0, configurable: !0, get: g(t) ? function () { if (this.originalEvent) return t(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[e] }, set: function (t) { Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) } }) }, fix: function (e) { return e[w.expando] ? e : new w.Event(e) }, special: { load: { noBubble: !0 }, focus: { trigger: function () { if (this !== Se() && this.focus) return this.focus(), !1 }, delegateType: "focusin" }, blur: { trigger: function () { if (this === Se() && this.blur) return this.blur(), !1 }, delegateType: "focusout" }, click: { trigger: function () { if ("checkbox" === this.type && this.click && N(this, "input")) return this.click(), !1 }, _default: function (e) { return N(e.target, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, w.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, w.Event = function (e, t) { if (!(this instanceof w.Event)) return new w.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ee : ke, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0 }, w.Event.prototype = { constructor: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = Ee, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = Ee, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, w.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (e) { var t = e.button; return null == e.which && we.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Te.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which } }, w.event.addProp), w.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, t) { w.event.special[e] = { delegateType: t, bindType: t, handle: function (e) { var n, r = this, i = e.relatedTarget, o = e.handleObj; return i && (i === r || w.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n } } }), w.fn.extend({ on: function (e, t, n, r) { return De(this, e, t, n, r) }, one: function (e, t, n, r) { return De(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = ke), this.each(function () { w.event.remove(this, e, n, t) }) } }); var Ne = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, Ae = /<script|<style|<link/i, je = /checked\s*(?:[^=]|=\s*.checked.)/i, qe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function Le(e, t) { return N(e, "table") && N(11 !== t.nodeType ? t : t.firstChild, "tr") ? w(e).children("tbody")[0] || e : e } function He(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function Oe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Pe(e, t) { var n, r, i, o, a, s, u, l; if (1 === t.nodeType) { if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), l = o.events)) { delete a.handle, a.events = {}; for (i in l) for (n = 0, r = l[i].length; n < r; n++)w.event.add(t, i, l[i][n]) } K.hasData(e) && (s = K.access(e), u = w.extend({}, s), K.set(t, u)) } } function Me(e, t) { var n = t.nodeName.toLowerCase(); "input" === n && pe.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue) } function Re(e, t, n, r) { t = a.apply([], t); var i, o, s, u, l, c, f = 0, p = e.length, d = p - 1, y = t[0], v = g(y); if (v || p > 1 && "string" == typeof y && !h.checkClone && je.test(y)) return e.each(function (i) { var o = e.eq(i); v && (t[0] = y.call(this, i, o.html())), Re(o, t, n, r) }); if (p && (i = xe(t, e[0].ownerDocument, !1, e, r), o = i.firstChild, 1 === i.childNodes.length && (i = o), o || r)) { for (u = (s = w.map(ye(i, "script"), He)).length; f < p; f++)l = i, f !== d && (l = w.clone(l, !0, !0), u && w.merge(s, ye(l, "script"))), n.call(e[f], l, f); if (u) for (c = s[s.length - 1].ownerDocument, w.map(s, Oe), f = 0; f < u; f++)l = s[f], he.test(l.type || "") && !J.access(l, "globalEval") && w.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? w._evalUrl && w._evalUrl(l.src) : m(l.textContent.replace(qe, ""), c, l)) } return e } function Ie(e, t, n) { for (var r, i = t ? w.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || w.cleanData(ye(r)), r.parentNode && (n && w.contains(r.ownerDocument, r) && ve(ye(r, "script")), r.parentNode.removeChild(r)); return e } w.extend({ htmlPrefilter: function (e) { return e.replace(Ne, "<$1></$2>") }, clone: function (e, t, n) { var r, i, o, a, s = e.cloneNode(!0), u = w.contains(e.ownerDocument, e); if (!(h.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || w.isXMLDoc(e))) for (a = ye(s), r = 0, i = (o = ye(e)).length; r < i; r++)Me(o[r], a[r]); if (t) if (n) for (o = o || ye(e), a = a || ye(s), r = 0, i = o.length; r < i; r++)Pe(o[r], a[r]); else Pe(e, s); return (a = ye(s, "script")).length > 0 && ve(a, !u && ye(e, "script")), s }, cleanData: function (e) { for (var t, n, r, i = w.event.special, o = 0; void 0 !== (n = e[o]); o++)if (Y(n)) { if (t = n[J.expando]) { if (t.events) for (r in t.events) i[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle); n[J.expando] = void 0 } n[K.expando] && (n[K.expando] = void 0) } } }), w.fn.extend({ detach: function (e) { return Ie(this, e, !0) }, remove: function (e) { return Ie(this, e) }, text: function (e) { return z(this, function (e) { return void 0 === e ? w.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function () { return Re(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Le(this, e).appendChild(e) }) }, prepend: function () { return Re(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = Le(this, e); t.insertBefore(e, t.firstChild) } }) }, before: function () { return Re(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function () { return Re(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (w.cleanData(ye(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return w.clone(this, e, t) }) }, html: function (e) { return z(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !Ae.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = w.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (w.cleanData(ye(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function () { var e = []; return Re(this, arguments, function (t) { var n = this.parentNode; w.inArray(this, e) < 0 && (w.cleanData(ye(this)), n && n.replaceChild(t, this)) }, e) } }), w.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, t) { w.fn[e] = function (e) { for (var n, r = [], i = w(e), o = i.length - 1, a = 0; a <= o; a++)n = a === o ? this : this.clone(!0), w(i[a])[t](n), s.apply(r, n.get()); return this.pushStack(r) } }); var We = new RegExp("^(" + re + ")(?!px)[a-z%]+$", "i"), $e = function (t) { var n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle(t) }, Be = new RegExp(oe.join("|"), "i"); !function () { function t() { if (c) { l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", be.appendChild(l).appendChild(c); var t = e.getComputedStyle(c); i = "1%" !== t.top, u = 12 === n(t.marginLeft), c.style.right = "60%", s = 36 === n(t.right), o = 36 === n(t.width), c.style.position = "absolute", a = 36 === c.offsetWidth || "absolute", be.removeChild(l), c = null } } function n(e) { return Math.round(parseFloat(e)) } var i, o, a, s, u, l = r.createElement("div"), c = r.createElement("div"); c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", h.clearCloneStyle = "content-box" === c.style.backgroundClip, w.extend(h, { boxSizingReliable: function () { return t(), o }, pixelBoxStyles: function () { return t(), s }, pixelPosition: function () { return t(), i }, reliableMarginLeft: function () { return t(), u }, scrollboxSize: function () { return t(), a } })) }(); function Fe(e, t, n) { var r, i, o, a, s = e.style; return (n = n || $e(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || w.contains(e.ownerDocument, e) || (a = w.style(e, t)), !h.pixelBoxStyles() && We.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a } function _e(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } var ze = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ue = { position: "absolute", visibility: "hidden", display: "block" }, Ve = { letterSpacing: "0", fontWeight: "400" }, Ge = ["Webkit", "Moz", "ms"], Ye = r.createElement("div").style; function Qe(e) { if (e in Ye) return e; var t = e[0].toUpperCase() + e.slice(1), n = Ge.length; while (n--) if ((e = Ge[n] + t) in Ye) return e } function Je(e) { var t = w.cssProps[e]; return t || (t = w.cssProps[e] = Qe(e) || e), t } function Ke(e, t, n) { var r = ie.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function Ze(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += w.css(e, n + oe[a], !0, i)), r ? ("content" === n && (u -= w.css(e, "padding" + oe[a], !0, i)), "margin" !== n && (u -= w.css(e, "border" + oe[a] + "Width", !0, i))) : (u += w.css(e, "padding" + oe[a], !0, i), "padding" !== n ? u += w.css(e, "border" + oe[a] + "Width", !0, i) : s += w.css(e, "border" + oe[a] + "Width", !0, i)); return !r && o >= 0 && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5))), u } function et(e, t, n) { var r = $e(e), i = Fe(e, t, r), o = "border-box" === w.css(e, "boxSizing", !1, r), a = o; if (We.test(i)) { if (!n) return i; i = "auto" } return a = a && (h.boxSizingReliable() || i === e.style[t]), ("auto" === i || !parseFloat(i) && "inline" === w.css(e, "display", !1, r)) && (i = e["offset" + t[0].toUpperCase() + t.slice(1)], a = !0), (i = parseFloat(i) || 0) + Ze(e, t, n || (o ? "border" : "content"), a, r, i) + "px" } w.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Fe(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = G(t), u = Xe.test(t), l = e.style; if (u || (t = Je(s)), a = w.cssHooks[t] || w.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" == (o = typeof n) && (i = ie.exec(n)) && i[1] && (n = ue(e, t, i), o = "number"), null != n && n === n && ("number" === o && (n += i && i[3] || (w.cssNumber[s] ? "" : "px")), h.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var i, o, a, s = G(t); return Xe.test(t) || (t = Je(s)), (a = w.cssHooks[t] || w.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Fe(e, t, r)), "normal" === i && t in Ve && (i = Ve[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i } }), w.each(["height", "width"], function (e, t) { w.cssHooks[t] = { get: function (e, n, r) { if (n) return !ze.test(w.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? et(e, t, r) : se(e, Ue, function () { return et(e, t, r) }) }, set: function (e, n, r) { var i, o = $e(e), a = "border-box" === w.css(e, "boxSizing", !1, o), s = r && Ze(e, t, r, a, o); return a && h.scrollboxSize() === o.position && (s -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - Ze(e, t, "border", !1, o) - .5)), s && (i = ie.exec(n)) && "px" !== (i[3] || "px") && (e.style[t] = n, n = w.css(e, t)), Ke(e, n, s) } } }), w.cssHooks.marginLeft = _e(h.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(Fe(e, "marginLeft")) || e.getBoundingClientRect().left - se(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left })) + "px" }), w.each({ margin: "", padding: "", border: "Width" }, function (e, t) { w.cssHooks[e + t] = { expand: function (n) { for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++)i[e + oe[r] + t] = o[r] || o[r - 2] || o[0]; return i } }, "margin" !== e && (w.cssHooks[e + t].set = Ke) }), w.fn.extend({ css: function (e, t) { return z(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = $e(e), i = t.length; a < i; a++)o[t[a]] = w.css(e, t[a], !1, r); return o } return void 0 !== n ? w.style(e, t, n) : w.css(e, t) }, e, t, arguments.length > 1) } }); function tt(e, t, n, r, i) { return new tt.prototype.init(e, t, n, r, i) } w.Tween = tt, tt.prototype = { constructor: tt, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || w.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (w.cssNumber[n] ? "" : "px") }, cur: function () { var e = tt.propHooks[this.prop]; return e && e.get ? e.get(this) : tt.propHooks._default.get(this) }, run: function (e) { var t, n = tt.propHooks[this.prop]; return this.options.duration ? this.pos = t = w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : tt.propHooks._default.set(this), this } }, tt.prototype.init.prototype = tt.prototype, tt.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = w.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { w.fx.step[e.prop] ? w.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[w.cssProps[e.prop]] && !w.cssHooks[e.prop] ? e.elem[e.prop] = e.now : w.style(e.elem, e.prop, e.now + e.unit) } } }, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, w.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, w.fx = tt.prototype.init, w.fx.step = {}; var nt, rt, it = /^(?:toggle|show|hide)$/, ot = /queueHooks$/; function at() { rt && (!1 === r.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(at) : e.setTimeout(at, w.fx.interval), w.fx.tick()) } function st() { return e.setTimeout(function () { nt = void 0 }), nt = Date.now() } function ut(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = oe[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i } function lt(e, t, n) { for (var r, i = (pt.tweeners[t] || []).concat(pt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r } function ct(e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), y = J.get(e, "fxshow"); n.queue || (null == (a = w._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s() }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, w.queue(e, "fx").length || a.empty.fire() }) })); for (r in t) if (i = t[r], it.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !y || void 0 === y[r]) continue; g = !0 } d[r] = y && y[r] || w.style(e, r) } if ((u = !w.isEmptyObject(t)) || !w.isEmptyObject(d)) { f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = y && y.display) && (l = J.get(e, "display")), "none" === (c = w.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = w.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === w.css(e, "float") && (u || (p.done(function () { h.display = l }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] })), u = !1; for (r in d) u || (y ? "hidden" in y && (g = y.hidden) : y = J.access(e, "fxshow", { display: l }), o && (y.hidden = !g), g && fe([e], !0), p.done(function () { g || fe([e]), J.remove(e, "fxshow"); for (r in d) w.style(e, r, d[r]) })), u = lt(g ? y[r] : 0, r, p), r in y || (y[r] = u.start, g && (u.end = u.start, u.start = 0)) } } function ft(e, t) { var n, r, i, o, a; for (n in e) if (r = G(n), i = t[r], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = w.cssHooks[r]) && "expand" in a) { o = a.expand(o), delete e[r]; for (n in o) n in e || (e[n] = o[n], t[n] = i) } else t[r] = i } function pt(e, t, n) { var r, i, o = 0, a = pt.prefilters.length, s = w.Deferred().always(function () { delete u.elem }), u = function () { if (i) return !1; for (var t = nt || st(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), o = 0, a = l.tweens.length; o < a; o++)l.tweens[o].run(r); return s.notifyWith(e, [l, r, n]), r < 1 && a ? n : (a || s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l]), !1) }, l = s.promise({ elem: e, props: w.extend({}, t), opts: w.extend(!0, { specialEasing: {}, easing: w.easing._default }, n), originalProperties: t, originalOptions: n, startTime: nt || st(), duration: n.duration, tweens: [], createTween: function (t, n) { var r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r }, stop: function (t) { var n = 0, r = t ? l.tweens.length : 0; if (i) return this; for (i = !0; n < r; n++)l.tweens[n].run(1); return t ? (s.notifyWith(e, [l, 1, 0]), s.resolveWith(e, [l, t])) : s.rejectWith(e, [l, t]), this } }), c = l.props; for (ft(c, l.opts.specialEasing); o < a; o++)if (r = pt.prefilters[o].call(l, e, c, l.opts)) return g(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r; return w.map(c, lt, l), g(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), w.fx.timer(w.extend(u, { elem: e, anim: l, queue: l.opts.queue })), l } w.Animation = w.extend(pt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return ue(n.elem, e, ie.exec(t), n), n }] }, tweener: function (e, t) { g(e) ? (t = e, e = ["*"]) : e = e.match(M); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], pt.tweeners[n] = pt.tweeners[n] || [], pt.tweeners[n].unshift(t) }, prefilters: [ct], prefilter: function (e, t) { t ? pt.prefilters.unshift(e) : pt.prefilters.push(e) } }), w.speed = function (e, t, n) { var r = e && "object" == typeof e ? w.extend({}, e) : { complete: n || !n && t || g(e) && e, duration: e, easing: n && t || t && !g(t) && t }; return w.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in w.fx.speeds ? r.duration = w.fx.speeds[r.duration] : r.duration = w.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { g(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue) }, r }, w.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (e, t, n, r) { var i = w.isEmptyObject(e), o = w.speed(t, n, r), a = function () { var t = pt(this, w.extend({}, e), o); (i || J.get(this, "finish")) && t.stop(!0) }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a) }, stop: function (e, t, n) { var r = function (e) { var t = e.stop; delete e.stop, t(n) }; return "string" != typeof e && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || "fx", []), this.each(function () { var t = !0, i = null != e && e + "queueHooks", o = w.timers, a = J.get(this); if (i) a[i] && a[i].stop && r(a[i]); else for (i in a) a[i] && a[i].stop && ot.test(i) && r(a[i]); for (i = o.length; i--;)o[i].elem !== this || null != e && o[i].queue !== e || (o[i].anim.stop(n), t = !1, o.splice(i, 1)); !t && n || w.dequeue(this, e) }) }, finish: function (e) { return !1 !== e && (e = e || "fx"), this.each(function () { var t, n = J.get(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = w.timers, a = r ? r.length : 0; for (n.finish = !0, w.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;)o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1)); for (t = 0; t < a; t++)r[t] && r[t].finish && r[t].finish.call(this); delete n.finish }) } }), w.each(["toggle", "show", "hide"], function (e, t) { var n = w.fn[t]; w.fn[t] = function (e, r, i) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ut(t, !0), e, r, i) } }), w.each({ slideDown: ut("show"), slideUp: ut("hide"), slideToggle: ut("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, t) { w.fn[e] = function (e, n, r) { return this.animate(t, e, n, r) } }), w.timers = [], w.fx.tick = function () { var e, t = 0, n = w.timers; for (nt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || w.fx.stop(), nt = void 0 }, w.fx.timer = function (e) { w.timers.push(e), w.fx.start() }, w.fx.interval = 13, w.fx.start = function () { rt || (rt = !0, at()) }, w.fx.stop = function () { rt = null }, w.fx.speeds = { slow: 600, fast: 200, _default: 400 }, w.fn.delay = function (t, n) { return t = w.fx ? w.fx.speeds[t] || t : t, n = n || "fx", this.queue(n, function (n, r) { var i = e.setTimeout(n, t); r.stop = function () { e.clearTimeout(i) } }) }, function () { var e = r.createElement("input"), t = r.createElement("select").appendChild(r.createElement("option")); e.type = "checkbox", h.checkOn = "" !== e.value, h.optSelected = t.selected, (e = r.createElement("input")).value = "t", e.type = "radio", h.radioValue = "t" === e.value }(); var dt, ht = w.expr.attrHandle; w.fn.extend({ attr: function (e, t) { return z(this, w.attr, e, t, arguments.length > 1) }, removeAttr: function (e) { return this.each(function () { w.removeAttr(this, e) }) } }), w.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? w.prop(e, t, n) : (1 === o && w.isXMLDoc(e) || (i = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? dt : void 0)), void 0 !== n ? null === n ? void w.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = w.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!h.radioValue && "radio" === t && N(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(M); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n) } }), dt = { set: function (e, t, n) { return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n } }, w.each(w.expr.match.bool.source.match(/\w+/g), function (e, t) { var n = ht[t] || w.find.attr; ht[t] = function (e, t, r) { var i, o, a = t.toLowerCase(); return r || (o = ht[a], ht[a] = i, i = null != n(e, t, r) ? a : null, ht[a] = o), i } }); var gt = /^(?:input|select|textarea|button)$/i, yt = /^(?:a|area)$/i; w.fn.extend({ prop: function (e, t) { return z(this, w.prop, e, t, arguments.length > 1) }, removeProp: function (e) { return this.each(function () { delete this[w.propFix[e] || e] }) } }), w.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && w.isXMLDoc(e) || (t = w.propFix[t] || t, i = w.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = w.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : gt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), h.optSelected || (w.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { w.propFix[this.toLowerCase()] = this }); function vt(e) { return (e.match(M) || []).join(" ") } function mt(e) { return e.getAttribute && e.getAttribute("class") || "" } function xt(e) { return Array.isArray(e) ? e : "string" == typeof e ? e.match(M) || [] : [] } w.fn.extend({ addClass: function (e) { var t, n, r, i, o, a, s, u = 0; if (g(e)) return this.each(function (t) { w(this).addClass(e.call(this, t, mt(this))) }); if ((t = xt(e)).length) while (n = this[u++]) if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = t[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = vt(r)) && n.setAttribute("class", s) } return this }, removeClass: function (e) { var t, n, r, i, o, a, s, u = 0; if (g(e)) return this.each(function (t) { w(this).removeClass(e.call(this, t, mt(this))) }); if (!arguments.length) return this.attr("class", ""); if ((t = xt(e)).length) while (n = this[u++]) if (i = mt(n), r = 1 === n.nodeType && " " + vt(i) + " ") { a = 0; while (o = t[a++]) while (r.indexOf(" " + o + " ") > -1) r = r.replace(" " + o + " ", " "); i !== (s = vt(r)) && n.setAttribute("class", s) } return this }, toggleClass: function (e, t) { var n = typeof e, r = "string" === n || Array.isArray(e); return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : g(e) ? this.each(function (n) { w(this).toggleClass(e.call(this, n, mt(this), t), t) }) : this.each(function () { var t, i, o, a; if (r) { i = 0, o = w(this), a = xt(e); while (t = a[i++]) o.hasClass(t) ? o.removeClass(t) : o.addClass(t) } else void 0 !== e && "boolean" !== n || ((t = mt(this)) && J.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : J.get(this, "__className__") || "")) }) }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && (" " + vt(mt(n)) + " ").indexOf(t) > -1) return !0; return !1 } }); var bt = /\r/g; w.fn.extend({ val: function (e) { var t, n, r, i = this[0]; { if (arguments.length) return r = g(e), this.each(function (n) { var i; 1 === this.nodeType && (null == (i = r ? e.call(this, n, w(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = w.map(i, function (e) { return null == e ? "" : e + "" })), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i)) }); if (i) return (t = w.valHooks[i.type] || w.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(bt, "") : null == n ? "" : n } } }), w.extend({ valHooks: { option: { get: function (e) { var t = w.find.attr(e, "value"); return null != t ? t : vt(w.text(e)) } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !N(n.parentNode, "optgroup"))) { if (t = w(n).val(), a) return t; s.push(t) } return s }, set: function (e, t) { var n, r, i = e.options, o = w.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = w.inArray(w.valHooks.option.get(r), o) > -1) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), w.each(["radio", "checkbox"], function () { w.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1 } }, h.checkOn || (w.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) }), h.focusin = "onfocusin" in e; var wt = /^(?:focusinfocus|focusoutblur)$/, Tt = function (e) { e.stopPropagation() }; w.extend(w.event, { trigger: function (t, n, i, o) { var a, s, u, l, c, p, d, h, v = [i || r], m = f.call(t, "type") ? t.type : t, x = f.call(t, "namespace") ? t.namespace.split(".") : []; if (s = h = u = i = i || r, 3 !== i.nodeType && 8 !== i.nodeType && !wt.test(m + w.event.triggered) && (m.indexOf(".") > -1 && (m = (x = m.split(".")).shift(), x.sort()), c = m.indexOf(":") < 0 && "on" + m, t = t[w.expando] ? t : new w.Event(m, "object" == typeof t && t), t.isTrigger = o ? 2 : 3, t.namespace = x.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), n = null == n ? [t] : w.makeArray(n, [t]), d = w.event.special[m] || {}, o || !d.trigger || !1 !== d.trigger.apply(i, n))) { if (!o && !d.noBubble && !y(i)) { for (l = d.delegateType || m, wt.test(l + m) || (s = s.parentNode); s; s = s.parentNode)v.push(s), u = s; u === (i.ownerDocument || r) && v.push(u.defaultView || u.parentWindow || e) } a = 0; while ((s = v[a++]) && !t.isPropagationStopped()) h = s, t.type = a > 1 ? l : d.bindType || m, (p = (J.get(s, "events") || {})[t.type] && J.get(s, "handle")) && p.apply(s, n), (p = c && s[c]) && p.apply && Y(s) && (t.result = p.apply(s, n), !1 === t.result && t.preventDefault()); return t.type = m, o || t.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !Y(i) || c && g(i[m]) && !y(i) && ((u = i[c]) && (i[c] = null), w.event.triggered = m, t.isPropagationStopped() && h.addEventListener(m, Tt), i[m](), t.isPropagationStopped() && h.removeEventListener(m, Tt), w.event.triggered = void 0, u && (i[c] = u)), t.result } }, simulate: function (e, t, n) { var r = w.extend(new w.Event, n, { type: e, isSimulated: !0 }); w.event.trigger(r, null, t) } }), w.fn.extend({ trigger: function (e, t) { return this.each(function () { w.event.trigger(e, t, this) }) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return w.event.trigger(e, t, n, !0) } }), h.focusin || w.each({ focus: "focusin", blur: "focusout" }, function (e, t) { var n = function (e) { w.event.simulate(t, e.target, w.event.fix(e)) }; w.event.special[t] = { setup: function () { var r = this.ownerDocument || this, i = J.access(r, t); i || r.addEventListener(e, n, !0), J.access(r, t, (i || 0) + 1) }, teardown: function () { var r = this.ownerDocument || this, i = J.access(r, t) - 1; i ? J.access(r, t, i) : (r.removeEventListener(e, n, !0), J.remove(r, t)) } } }); var Ct = e.location, Et = Date.now(), kt = /\?/; w.parseXML = function (t) { var n; if (!t || "string" != typeof t) return null; try { n = (new e.DOMParser).parseFromString(t, "text/xml") } catch (e) { n = void 0 } return n && !n.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), n }; var St = /\[\]$/, Dt = /\r?\n/g, Nt = /^(?:submit|button|image|reset|file)$/i, At = /^(?:input|select|textarea|keygen)/i; function jt(e, t, n, r) { var i; if (Array.isArray(t)) w.each(t, function (t, i) { n || St.test(e) ? r(e, i) : jt(e + "[" + ("object" == typeof i && null != i ? t : "") + "]", i, n, r) }); else if (n || "object" !== x(t)) r(e, t); else for (i in t) jt(e + "[" + i + "]", t[i], n, r) } w.param = function (e, t) { var n, r = [], i = function (e, t) { var n = g(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, function () { i(this.name, this.value) }); else for (n in e) jt(n, e[n], t, i); return r.join("&") }, w.fn.extend({ serialize: function () { return w.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var e = w.prop(this, "elements"); return e ? w.makeArray(e) : this }).filter(function () { var e = this.type; return this.name && !w(this).is(":disabled") && At.test(this.nodeName) && !Nt.test(e) && (this.checked || !pe.test(e)) }).map(function (e, t) { var n = w(this).val(); return null == n ? null : Array.isArray(n) ? w.map(n, function (e) { return { name: t.name, value: e.replace(Dt, "\r\n") } }) : { name: t.name, value: n.replace(Dt, "\r\n") } }).get() } }); var qt = /%20/g, Lt = /#.*$/, Ht = /([?&])_=[^&]*/, Ot = /^(.*?):[ \t]*([^\r\n]*)$/gm, Pt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Mt = /^(?:GET|HEAD)$/, Rt = /^\/\//, It = {}, Wt = {}, $t = "*/".concat("*"), Bt = r.createElement("a"); Bt.href = Ct.href; function Ft(e) { return function (t, n) { "string" != typeof t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase().match(M) || []; if (g(n)) while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n) } } function _t(e, t, n, r) { var i = {}, o = e === Wt; function a(s) { var u; return i[s] = !0, w.each(e[s] || [], function (e, s) { var l = s(t, n, r); return "string" != typeof l || o || i[l] ? o ? !(u = l) : void 0 : (t.dataTypes.unshift(l), a(l), !1) }), u } return a(t.dataTypes[0]) || !i["*"] && a("*") } function zt(e, t) { var n, r, i = w.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && w.extend(!0, e, r), e } function Xt(e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break } a || (a = i) } o = o || a } if (o) return o !== u[0] && u.unshift(o), n[o] } function Ut(e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t) } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o } } } return { state: "success", data: t } } w.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Ct.href, type: "GET", isLocal: Pt.test(Ct.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": $t, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": w.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? zt(zt(e, w.ajaxSettings), t) : zt(w.ajaxSettings, e) }, ajaxPrefilter: Ft(It), ajaxTransport: Ft(Wt), ajax: function (t, n) { "object" == typeof t && (n = t, t = void 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, h = w.ajaxSetup({}, n), g = h.context || h, y = h.context && (g.nodeType || g.jquery) ? w(g) : w.event, v = w.Deferred(), m = w.Callbacks("once memory"), x = h.statusCode || {}, b = {}, T = {}, C = "canceled", E = { readyState: 0, getResponseHeader: function (e) { var t; if (c) { if (!s) { s = {}; while (t = Ot.exec(a)) s[t[1].toLowerCase()] = t[2] } t = s[e.toLowerCase()] } return null == t ? null : t }, getAllResponseHeaders: function () { return c ? a : null }, setRequestHeader: function (e, t) { return null == c && (e = T[e.toLowerCase()] = T[e.toLowerCase()] || e, b[e] = t), this }, overrideMimeType: function (e) { return null == c && (h.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (c) E.always(e[E.status]); else for (t in e) x[t] = [x[t], e[t]]; return this }, abort: function (e) { var t = e || C; return i && i.abort(t), k(0, t), this } }; if (v.promise(E), h.url = ((t || h.url || Ct.href) + "").replace(Rt, Ct.protocol + "//"), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || "*").toLowerCase().match(M) || [""], null == h.crossDomain) { l = r.createElement("a"); try { l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host != l.protocol + "//" + l.host } catch (e) { h.crossDomain = !0 } } if (h.data && h.processData && "string" != typeof h.data && (h.data = w.param(h.data, h.traditional)), _t(It, h, n, E), c) return E; (f = w.event && h.global) && 0 == w.active++ && w.event.trigger("ajaxStart"), h.type = h.type.toUpperCase(), h.hasContent = !Mt.test(h.type), o = h.url.replace(Lt, ""), h.hasContent ? h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded") && (h.data = h.data.replace(qt, "+")) : (d = h.url.slice(o.length), h.data && (h.processData || "string" == typeof h.data) && (o += (kt.test(o) ? "&" : "?") + h.data, delete h.data), !1 === h.cache && (o = o.replace(Ht, "$1"), d = (kt.test(o) ? "&" : "?") + "_=" + Et++ + d), h.url = o + d), h.ifModified && (w.lastModified[o] && E.setRequestHeader("If-Modified-Since", w.lastModified[o]), w.etag[o] && E.setRequestHeader("If-None-Match", w.etag[o])), (h.data && h.hasContent && !1 !== h.contentType || n.contentType) && E.setRequestHeader("Content-Type", h.contentType), E.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : h.accepts["*"]); for (p in h.headers) E.setRequestHeader(p, h.headers[p]); if (h.beforeSend && (!1 === h.beforeSend.call(g, E, h) || c)) return E.abort(); if (C = "abort", m.add(h.complete), E.done(h.success), E.fail(h.error), i = _t(Wt, h, n, E)) { if (E.readyState = 1, f && y.trigger("ajaxSend", [E, h]), c) return E; h.async && h.timeout > 0 && (u = e.setTimeout(function () { E.abort("timeout") }, h.timeout)); try { c = !1, i.send(b, k) } catch (e) { if (c) throw e; k(-1, e) } } else k(-1, "No Transport"); function k(t, n, r, s) { var l, p, d, b, T, C = n; c || (c = !0, u && e.clearTimeout(u), i = void 0, a = s || "", E.readyState = t > 0 ? 4 : 0, l = t >= 200 && t < 300 || 304 === t, r && (b = Xt(h, E, r)), b = Ut(h, b, E, l), l ? (h.ifModified && ((T = E.getResponseHeader("Last-Modified")) && (w.lastModified[o] = T), (T = E.getResponseHeader("etag")) && (w.etag[o] = T)), 204 === t || "HEAD" === h.type ? C = "nocontent" : 304 === t ? C = "notmodified" : (C = b.state, p = b.data, l = !(d = b.error))) : (d = C, !t && C || (C = "error", t < 0 && (t = 0))), E.status = t, E.statusText = (n || C) + "", l ? v.resolveWith(g, [p, C, E]) : v.rejectWith(g, [E, C, d]), E.statusCode(x), x = void 0, f && y.trigger(l ? "ajaxSuccess" : "ajaxError", [E, h, l ? p : d]), m.fireWith(g, [E, C]), f && (y.trigger("ajaxComplete", [E, h]), --w.active || w.event.trigger("ajaxStop"))) } return E }, getJSON: function (e, t, n) { return w.get(e, t, n, "json") }, getScript: function (e, t) { return w.get(e, void 0, t, "script") } }), w.each(["get", "post"], function (e, t) { w[t] = function (e, n, r, i) { return g(n) && (i = i || r, r = n, n = void 0), w.ajax(w.extend({ url: e, type: t, dataType: i, data: n, success: r }, w.isPlainObject(e) && e)) } }), w._evalUrl = function (e) { return w.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, "throws": !0 }) }, w.fn.extend({ wrapAll: function (e) { var t; return this[0] && (g(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e }).append(this)), this }, wrapInner: function (e) { return g(e) ? this.each(function (t) { w(this).wrapInner(e.call(this, t)) }) : this.each(function () { var t = w(this), n = t.contents(); n.length ? n.wrapAll(e) : t.append(e) }) }, wrap: function (e) { var t = g(e); return this.each(function (n) { w(this).wrapAll(t ? e.call(this, n) : e) }) }, unwrap: function (e) { return this.parent(e).not("body").each(function () { w(this).replaceWith(this.childNodes) }), this } }), w.expr.pseudos.hidden = function (e) { return !w.expr.pseudos.visible(e) }, w.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, w.ajaxSettings.xhr = function () { try { return new e.XMLHttpRequest } catch (e) { } }; var Vt = { 0: 200, 1223: 204 }, Gt = w.ajaxSettings.xhr(); h.cors = !!Gt && "withCredentials" in Gt, h.ajax = Gt = !!Gt, w.ajaxTransport(function (t) { var n, r; if (h.cors || Gt && !t.crossDomain) return { send: function (i, o) { var a, s = t.xhr(); if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (a in t.xhrFields) s[a] = t.xhrFields[a]; t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"); for (a in i) s.setRequestHeader(a, i[a]); n = function (e) { return function () { n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Vt[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())) } }, s.onload = n(), r = s.onerror = s.ontimeout = n("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function () { 4 === s.readyState && e.setTimeout(function () { n && r() }) }, n = n("abort"); try { s.send(t.hasContent && t.data || null) } catch (e) { if (n) throw e } }, abort: function () { n && n() } } }), w.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1) }), w.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return w.globalEval(e), e } } }), w.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") }), w.ajaxTransport("script", function (e) { if (e.crossDomain) { var t, n; return { send: function (i, o) { t = w("<script>").prop({ charset: e.scriptCharset, src: e.url }).on("load error", n = function (e) { t.remove(), n = null, e && o("error" === e.type ? 404 : 200, e.type) }), r.head.appendChild(t[0]) }, abort: function () { n && n() } } } }); var Yt = [], Qt = /(=)\?(?=&|$)|\?\?/; w.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = Yt.pop() || w.expando + "_" + Et++; return this[e] = !0, e } }), w.ajaxPrefilter("json jsonp", function (t, n, r) { var i, o, a, s = !1 !== t.jsonp && (Qt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Qt.test(t.data) && "data"); if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = g(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Qt, "$1" + i) : !1 !== t.jsonp && (t.url += (kt.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function () { return a || w.error(i + " was not called"), a[0] }, t.dataTypes[0] = "json", o = e[i], e[i] = function () { a = arguments }, r.always(function () { void 0 === o ? w(e).removeProp(i) : e[i] = o, t[i] && (t.jsonpCallback = n.jsonpCallback, Yt.push(i)), a && g(o) && o(a[0]), a = o = void 0 }), "script" }), h.createHTMLDocument = function () { var e = r.implementation.createHTMLDocument("").body; return e.innerHTML = "<form></form><form></form>", 2 === e.childNodes.length }(), w.parseHTML = function (e, t, n) { if ("string" != typeof e) return []; "boolean" == typeof t && (n = t, t = !1); var i, o, a; return t || (h.createHTMLDocument ? ((i = (t = r.implementation.createHTMLDocument("")).createElement("base")).href = r.location.href, t.head.appendChild(i)) : t = r), o = A.exec(e), a = !n && [], o ? [t.createElement(o[1])] : (o = xe([e], t, a), a && a.length && w(a).remove(), w.merge([], o.childNodes)) }, w.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return s > -1 && (r = vt(e.slice(s)), e = e.slice(0, s)), g(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), a.length > 0 && w.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? w("<div>").append(w.parseHTML(e)).find(r) : e) }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]) }) }), this }, w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { w.fn[t] = function (e) { return this.on(t, e) } }), w.expr.pseudos.animated = function (e) { return w.grep(w.timers, function (t) { return e === t.elem }).length }, w.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l, c = w.css(e, "position"), f = w(e), p = {}; "static" === c && (e.style.position = "relative"), s = f.offset(), o = w.css(e, "top"), u = w.css(e, "left"), (l = ("absolute" === c || "fixed" === c) && (o + u).indexOf("auto") > -1) ? (a = (r = f.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), g(t) && (t = t.call(e, n, w.extend({}, s))), null != t.top && (p.top = t.top - s.top + a), null != t.left && (p.left = t.left - s.left + i), "using" in t ? t.using.call(e, p) : f.css(p) } }, w.fn.extend({ offset: function (e) { if (arguments.length) return void 0 === e ? this : this.each(function (t) { w.offset.setOffset(this, e, t) }); var t, n, r = this[0]; if (r) return r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 } }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = w(e).offset()).top += w.css(e, "borderTopWidth", !0), i.left += w.css(e, "borderLeftWidth", !0)) } return { top: t.top - i.top - w.css(r, "marginTop", !0), left: t.left - i.left - w.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === w.css(e, "position")) e = e.offsetParent; return e || be }) } }), w.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (e, t) { var n = "pageYOffset" === t; w.fn[e] = function (r) { return z(this, function (e, r, i) { var o; if (y(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o ? o[t] : e[r]; o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : e[r] = i }, e, r, arguments.length) } }), w.each(["top", "left"], function (e, t) { w.cssHooks[t] = _e(h.pixelPosition, function (e, n) { if (n) return n = Fe(e, t), We.test(n) ? w(e).position()[t] + "px" : n }) }), w.each({ Height: "height", Width: "width" }, function (e, t) { w.each({ padding: "inner" + e, content: t, "": "outer" + e }, function (n, r) { w.fn[r] = function (i, o) { var a = arguments.length && (n || "boolean" != typeof i), s = n || (!0 === i || !0 === o ? "margin" : "border"); return z(this, function (t, n, i) { var o; return y(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === i ? w.css(t, n, s) : w.style(t, n, i, s) }, t, a ? i : void 0, a) } }) }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, t) { w.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } }), w.fn.extend({ hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), w.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) } }), w.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), g(e)) return r = o.call(arguments, 2), i = function () { return e.apply(t || this, r.concat(o.call(arguments))) }, i.guid = e.guid = e.guid || w.guid++, i }, w.holdReady = function (e) { e ? w.readyWait++ : w.ready(!0) }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N, w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = function (e) { var t = w.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, "function" == typeof define && define.amd && define("jquery", [], function () { return w }); var Jt = e.jQuery, Kt = e.$; return w.noConflict = function (t) { return e.$ === w && (e.$ = Kt), t && e.jQuery === w && (e.jQuery = Jt), w }, t || (e.jQuery = e.$ = w), w });
;
/**
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT
 * @author Ariel Flesler
 * @version 2.1.2
 */
; (function (f) { "use strict"; "function" === typeof define && define.amd ? define(["jquery"], f) : "undefined" !== typeof module && module.exports ? module.exports = f(require("jquery")) : f(jQuery) })(function ($) { "use strict"; function n(a) { return !a.nodeName || -1 !== $.inArray(a.nodeName.toLowerCase(), ["iframe", "#document", "html", "body"]) } function h(a) { return $.isFunction(a) || $.isPlainObject(a) ? a : { top: a, left: a } } var p = $.scrollTo = function (a, d, b) { return $(window).scrollTo(a, d, b) }; p.defaults = { axis: "xy", duration: 0, limit: !0 }; $.fn.scrollTo = function (a, d, b) { "object" === typeof d && (b = d, d = 0); "function" === typeof b && (b = { onAfter: b }); "max" === a && (a = 9E9); b = $.extend({}, p.defaults, b); d = d || b.duration; var u = b.queue && 1 < b.axis.length; u && (d /= 2); b.offset = h(b.offset); b.over = h(b.over); return this.each(function () { function k(a) { var k = $.extend({}, b, { queue: !0, duration: d, complete: a && function () { a.call(q, e, b) } }); r.animate(f, k) } if (null !== a) { var l = n(this), q = l ? this.contentWindow || window : this, r = $(q), e = a, f = {}, t; switch (typeof e) { case "number": case "string": if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(e)) { e = h(e); break } e = l ? $(e) : $(e, q); case "object": if (e.length === 0) return; if (e.is || e.style) t = (e = $(e)).offset() }var v = $.isFunction(b.offset) && b.offset(q, e) || b.offset; $.each(b.axis.split(""), function (a, c) { var d = "x" === c ? "Left" : "Top", m = d.toLowerCase(), g = "scroll" + d, h = r[g](), n = p.max(q, c); t ? (f[g] = t[m] + (l ? 0 : h - r.offset()[m]), b.margin && (f[g] -= parseInt(e.css("margin" + d), 10) || 0, f[g] -= parseInt(e.css("border" + d + "Width"), 10) || 0), f[g] += v[m] || 0, b.over[m] && (f[g] += e["x" === c ? "width" : "height"]() * b.over[m])) : (d = e[m], f[g] = d.slice && "%" === d.slice(-1) ? parseFloat(d) / 100 * n : d); b.limit && /^\d+$/.test(f[g]) && (f[g] = 0 >= f[g] ? 0 : Math.min(f[g], n)); !a && 1 < b.axis.length && (h === f[g] ? f = {} : u && (k(b.onAfterFirst), f = {})) }); k(b.onAfter) } }) }; p.max = function (a, d) { var b = "x" === d ? "Width" : "Height", h = "scroll" + b; if (!n(a)) return a[h] - $(a)[b.toLowerCase()](); var b = "client" + b, k = a.ownerDocument || a.document, l = k.documentElement, k = k.body; return Math.max(l[h], k[h]) - Math.min(l[b], k[b]) }; $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = { get: function (a) { return $(a.elem)[a.prop]() }, set: function (a) { var d = this.get(a); if (a.options.interrupt && a._last && a._last !== d) return $(a.elem).stop(); var b = Math.round(a.now); d !== b && ($(a.elem)[a.prop](b), a._last = this.get(a)) } }; return p });
/*
 Sticky-kit v1.1.3 | MIT | Leaf Corcoran 2015 | http://leafo.net
*/
(function () {
  var c, f; c = window.jQuery; f = c(window); c.fn.stick_in_parent = function (b) {
    var A, w, J, n, B, K, p, q, L, k, E, t; null == b && (b = {}); t = b.sticky_class; B = b.inner_scrolling; E = b.recalc_every; k = b.parent; q = b.offset_top; p = b.spacer; w = b.bottoming; null == q && (q = 0); null == k && (k = void 0); null == B && (B = !0); null == t && (t = "is_stuck"); A = c(document); null == w && (w = !0); L = function (a) {
      var b; return window.getComputedStyle ? (a = window.getComputedStyle(a[0]), b = parseFloat(a.getPropertyValue("width")) + parseFloat(a.getPropertyValue("margin-left")) +
        parseFloat(a.getPropertyValue("margin-right")), "border-box" !== a.getPropertyValue("box-sizing") && (b += parseFloat(a.getPropertyValue("border-left-width")) + parseFloat(a.getPropertyValue("border-right-width")) + parseFloat(a.getPropertyValue("padding-left")) + parseFloat(a.getPropertyValue("padding-right"))), b) : a.outerWidth(!0)
    }; J = function (a, b, n, C, F, u, r, G) {
      var v, H, m, D, I, d, g, x, y, z, h, l; if (!a.data("sticky_kit")) {
        a.data("sticky_kit", !0); I = A.height(); g = a.parent(); null != k && (g = g.closest(k)); if (!g.length) throw "failed to find stick parent";
        v = m = !1; (h = null != p ? p && a.closest(p) : c("<div />")) && h.css("position", a.css("position")); x = function () {
          var d, f, e; if (!G && (I = A.height(), d = parseInt(g.css("border-top-width"), 10), f = parseInt(g.css("padding-top"), 10), b = parseInt(g.css("padding-bottom"), 10), n = g.offset().top + d + f, C = g.height(), m && (v = m = !1, null == p && (a.insertAfter(h), h.detach()), a.css({ position: "", top: "", width: "", bottom: "" }).removeClass(t), e = !0), F = a.offset().top - (parseInt(a.css("margin-top"), 10) || 0) - q, u = a.outerHeight(!0), r = a.css("float"), h && h.css({
            width: L(a),
            height: u, display: a.css("display"), "vertical-align": a.css("vertical-align"), "float": r
          }), e)) return l()
        }; x(); if (u !== C) return D = void 0, d = q, z = E, l = function () {
          var c, l, e, k; if (!G && (e = !1, null != z && (--z, 0 >= z && (z = E, x(), e = !0)), e || A.height() === I || x(), e = f.scrollTop(), null != D && (l = e - D), D = e, m ? (w && (k = e + u + d > C + n, v && !k && (v = !1, a.css({ position: "fixed", bottom: "", top: d }).trigger("sticky_kit:unbottom"))), e < F && (m = !1, d = q, null == p && ("left" !== r && "right" !== r || a.insertAfter(h), h.detach()), c = { position: "", width: "", top: "" }, a.css(c).removeClass(t).trigger("sticky_kit:unstick")),
            B && (c = f.height(), u + q > c && !v && (d -= l, d = Math.max(c - u, d), d = Math.min(q, d), m && a.css({ top: d + "px" })))) : e > F && (m = !0, c = { position: "fixed", top: d }, c.width = "border-box" === a.css("box-sizing") ? a.outerWidth() + "px" : a.width() + "px", a.css(c).addClass(t), null == p && (a.after(h), "left" !== r && "right" !== r || h.append(a)), a.trigger("sticky_kit:stick")), m && w && (null == k && (k = e + u + d > C + n), !v && k))) return v = !0, "static" === g.css("position") && g.css({ position: "relative" }), a.css({ position: "absolute", bottom: b, top: "auto" }).trigger("sticky_kit:bottom")
        },
          y = function () { x(); return l() }, H = function () { G = !0; f.off("touchmove", l); f.off("scroll", l); f.off("resize", y); c(document.body).off("sticky_kit:recalc", y); a.off("sticky_kit:detach", H); a.removeData("sticky_kit"); a.css({ position: "", bottom: "", top: "", width: "" }); g.position("position", ""); if (m) return null == p && ("left" !== r && "right" !== r || a.insertAfter(h), h.remove()), a.removeClass(t) }, f.on("touchmove", l), f.on("scroll", l), f.on("resize", y), c(document.body).on("sticky_kit:recalc", y), a.on("sticky_kit:detach", H), setTimeout(l,
            0)
      }
    }; n = 0; for (K = this.length; n < K; n++)b = this[n], J(c(b)); return this
  }
}).call(this);
;
/**
*  Ajax Autocomplete for jQuery, version 1.2.27
*  (c) 2014 Tomas Kirda
*
*  Ajax Autocomplete for jQuery is freely distributable under the terms of an MIT-style license.
*  For details, see the web site: https://github.com/devbridge/jQuery-Autocomplete
*/
!function (a) { "use strict"; "function" == typeof define && define.amd ? define(["jquery"], a) : a("object" == typeof exports && "function" == typeof require ? require("jquery") : jQuery) }(function (a) { "use strict"; function b(c, d) { var e = a.noop, f = this, g = { ajaxSettings: {}, autoSelectFirst: !1, appendTo: document.body, serviceUrl: null, lookup: null, onSelect: null, width: "auto", minChars: 1, maxHeight: 300, deferRequestBy: 0, params: {}, formatResult: b.formatResult, delimiter: null, zIndex: 9999, type: "GET", noCache: !1, onSearchStart: e, onSearchComplete: e, onSearchError: e, preserveInput: !1, containerClass: "autocomplete-suggestions", tabDisabled: !1, dataType: "text", currentRequest: null, triggerSelectOnValidInput: !0, preventBadQueries: !0, lookupFilter: function (a, b, c) { return -1 !== a.value.toLowerCase().indexOf(c) }, paramName: "query", transformResult: function (b) { return "string" == typeof b ? a.parseJSON(b) : b }, showNoSuggestionNotice: !1, noSuggestionNotice: "No results", orientation: "bottom", forceFixPosition: !1 }; f.element = c, f.el = a(c), f.suggestions = [], f.badQueries = [], f.selectedIndex = -1, f.currentValue = f.element.value, f.intervalId = 0, f.cachedResponse = {}, f.onChangeInterval = null, f.onChange = null, f.isLocal = !1, f.suggestionsContainer = null, f.noSuggestionsContainer = null, f.options = a.extend({}, g, d), f.classes = { selected: "autocomplete-selected", suggestion: "autocomplete-suggestion" }, f.hint = null, f.hintValue = "", f.selection = null, f.initialize(), f.setOptions(d) } var c = function () { return { escapeRegExChars: function (a) { return a.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&") }, createNode: function (a) { var b = document.createElement("div"); return b.className = a, b.style.position = "absolute", b.style.display = "none", b } } }(), d = { ESC: 27, TAB: 9, RETURN: 13, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 }; b.utils = c, a.Autocomplete = b, b.formatResult = function (a, b) { if (!b) return a.value; var d = "(" + c.escapeRegExChars(b) + ")"; return a.value.replace(new RegExp(d, "gi"), "<strong>$1</strong>").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/&lt;(\/?strong)&gt;/g, "<$1>") }, b.prototype = { killerFn: null, initialize: function () { var c, d = this, e = "." + d.classes.suggestion, f = d.classes.selected, g = d.options; d.element.setAttribute("autocomplete", "off"), d.killerFn = function (b) { a(b.target).closest("." + d.options.containerClass).length || (d.killSuggestions(), d.disableKillerFn()) }, d.noSuggestionsContainer = a('<div class="autocomplete-no-suggestion"></div>').html(this.options.noSuggestionNotice).get(0), d.suggestionsContainer = b.utils.createNode(g.containerClass), c = a(d.suggestionsContainer), c.appendTo(g.appendTo), "auto" !== g.width && c.css("width", g.width), c.on("mouseover.autocomplete", e, function () { d.activate(a(this).data("index")) }), c.on("mouseout.autocomplete", function () { d.selectedIndex = -1, c.children("." + f).removeClass(f) }), c.on("click.autocomplete", e, function () { return d.select(a(this).data("index")), !1 }), d.fixPositionCapture = function () { d.visible && d.fixPosition() }, a(window).on("resize.autocomplete", d.fixPositionCapture), d.el.on("keydown.autocomplete", function (a) { d.onKeyPress(a) }), d.el.on("keyup.autocomplete", function (a) { d.onKeyUp(a) }), d.el.on("blur.autocomplete", function () { d.onBlur() }), d.el.on("focus.autocomplete", function () { d.onFocus() }), d.el.on("change.autocomplete", function (a) { d.onKeyUp(a) }), d.el.on("input.autocomplete", function (a) { d.onKeyUp(a) }) }, onFocus: function () { var a = this; a.fixPosition(), a.el.val().length >= a.options.minChars && a.onValueChange() }, onBlur: function () { this.enableKillerFn() }, abortAjax: function () { var a = this; a.currentRequest && (a.currentRequest.abort(), a.currentRequest = null) }, setOptions: function (b) { var c = this, d = c.options; a.extend(d, b), c.isLocal = a.isArray(d.lookup), c.isLocal && (d.lookup = c.verifySuggestionsFormat(d.lookup)), d.orientation = c.validateOrientation(d.orientation, "bottom"), a(c.suggestionsContainer).css({ "max-height": d.maxHeight + "px", width: d.width + "px", "z-index": d.zIndex }) }, clearCache: function () { this.cachedResponse = {}, this.badQueries = [] }, clear: function () { this.clearCache(), this.currentValue = "", this.suggestions = [] }, disable: function () { var a = this; a.disabled = !0, clearInterval(a.onChangeInterval), a.abortAjax() }, enable: function () { this.disabled = !1 }, fixPosition: function () { var b = this, c = a(b.suggestionsContainer), d = c.parent().get(0); if (d === document.body || b.options.forceFixPosition) { var e = b.options.orientation, f = c.outerHeight(), g = b.el.outerHeight(), h = b.el.offset(), i = { top: h.top, left: h.left }; if ("auto" === e) { var j = a(window).height(), k = a(window).scrollTop(), l = -k + h.top - f, m = k + j - (h.top + g + f); e = Math.max(l, m) === l ? "top" : "bottom" } if ("top" === e ? i.top += -f : i.top += g, d !== document.body) { var n, o = c.css("opacity"); b.visible || c.css("opacity", 0).show(), n = c.offsetParent().offset(), i.top -= n.top, i.left -= n.left, b.visible || c.css("opacity", o).hide() } "auto" === b.options.width && (i.width = b.el.outerWidth() + "px"), c.css(i) } }, enableKillerFn: function () { var b = this; a(document).on("click.autocomplete", b.killerFn) }, disableKillerFn: function () { var b = this; a(document).off("click.autocomplete", b.killerFn) }, killSuggestions: function () { var a = this; a.stopKillSuggestions(), a.intervalId = window.setInterval(function () { a.visible && (a.options.preserveInput || a.el.val(a.currentValue), a.hide()), a.stopKillSuggestions() }, 50) }, stopKillSuggestions: function () { window.clearInterval(this.intervalId) }, isCursorAtEnd: function () { var a, b = this, c = b.el.val().length, d = b.element.selectionStart; return "number" == typeof d ? d === c : document.selection ? (a = document.selection.createRange(), a.moveStart("character", -c), c === a.text.length) : !0 }, onKeyPress: function (a) { var b = this; if (!b.disabled && !b.visible && a.which === d.DOWN && b.currentValue) return void b.suggest(); if (!b.disabled && b.visible) { switch (a.which) { case d.ESC: b.el.val(b.currentValue), b.hide(); break; case d.RIGHT: if (b.hint && b.options.onHint && b.isCursorAtEnd()) { b.selectHint(); break } return; case d.TAB: if (b.hint && b.options.onHint) return void b.selectHint(); if (-1 === b.selectedIndex) return void b.hide(); if (b.select(b.selectedIndex), b.options.tabDisabled === !1) return; break; case d.RETURN: if (-1 === b.selectedIndex) return void b.hide(); b.select(b.selectedIndex); break; case d.UP: b.moveUp(); break; case d.DOWN: b.moveDown(); break; default: return }a.stopImmediatePropagation(), a.preventDefault() } }, onKeyUp: function (a) { var b = this; if (!b.disabled) { switch (a.which) { case d.UP: case d.DOWN: return }clearInterval(b.onChangeInterval), b.currentValue !== b.el.val() && (b.findBestHint(), b.options.deferRequestBy > 0 ? b.onChangeInterval = setInterval(function () { b.onValueChange() }, b.options.deferRequestBy) : b.onValueChange()) } }, onValueChange: function () { var b = this, c = b.options, d = b.el.val(), e = b.getQuery(d); return b.selection && b.currentValue !== e && (b.selection = null, (c.onInvalidateSelection || a.noop).call(b.element)), clearInterval(b.onChangeInterval), b.currentValue = d, b.selectedIndex = -1, c.triggerSelectOnValidInput && b.isExactMatch(e) ? void b.select(0) : void (e.length < c.minChars ? b.hide() : b.getSuggestions(e)) }, isExactMatch: function (a) { var b = this.suggestions; return 1 === b.length && b[0].value.toLowerCase() === a.toLowerCase() }, getQuery: function (b) { var c, d = this.options.delimiter; return d ? (c = b.split(d), a.trim(c[c.length - 1])) : b }, getSuggestionsLocal: function (b) { var c, d = this, e = d.options, f = b.toLowerCase(), g = e.lookupFilter, h = parseInt(e.lookupLimit, 10); return c = { suggestions: a.grep(e.lookup, function (a) { return g(a, b, f) }) }, h && c.suggestions.length > h && (c.suggestions = c.suggestions.slice(0, h)), c }, getSuggestions: function (b) { var c, d, e, f, g = this, h = g.options, i = h.serviceUrl; if (h.params[h.paramName] = b, d = h.ignoreParams ? null : h.params, h.onSearchStart.call(g.element, h.params) !== !1) { if (a.isFunction(h.lookup)) return void h.lookup(b, function (a) { g.suggestions = a.suggestions, g.suggest(), h.onSearchComplete.call(g.element, b, a.suggestions) }); g.isLocal ? c = g.getSuggestionsLocal(b) : (a.isFunction(i) && (i = i.call(g.element, b)), e = i + "?" + a.param(d || {}), c = g.cachedResponse[e]), c && a.isArray(c.suggestions) ? (g.suggestions = c.suggestions, g.suggest(), h.onSearchComplete.call(g.element, b, c.suggestions)) : g.isBadQuery(b) ? h.onSearchComplete.call(g.element, b, []) : (g.abortAjax(), f = { url: i, data: d, type: h.type, dataType: h.dataType }, a.extend(f, h.ajaxSettings), g.currentRequest = a.ajax(f).done(function (a) { var c; g.currentRequest = null, c = h.transformResult(a, b), g.processResponse(c, b, e), h.onSearchComplete.call(g.element, b, c.suggestions) }).fail(function (a, c, d) { h.onSearchError.call(g.element, b, a, c, d) })) } }, isBadQuery: function (a) { if (!this.options.preventBadQueries) return !1; for (var b = this.badQueries, c = b.length; c--;)if (0 === a.indexOf(b[c])) return !0; return !1 }, hide: function () { var b = this, c = a(b.suggestionsContainer); a.isFunction(b.options.onHide) && b.visible && b.options.onHide.call(b.element, c), b.visible = !1, b.selectedIndex = -1, clearInterval(b.onChangeInterval), a(b.suggestionsContainer).hide(), b.signalHint(null) }, suggest: function () { if (!this.suggestions.length) return void (this.options.showNoSuggestionNotice ? this.noSuggestions() : this.hide()); var b, c = this, d = c.options, e = d.groupBy, f = d.formatResult, g = c.getQuery(c.currentValue), h = c.classes.suggestion, i = c.classes.selected, j = a(c.suggestionsContainer), k = a(c.noSuggestionsContainer), l = d.beforeRender, m = "", n = function (a, c) { var d = a.data[e]; return b === d ? "" : (b = d, '<div class="autocomplete-group"><strong>' + b + "</strong></div>") }; return d.triggerSelectOnValidInput && c.isExactMatch(g) ? void c.select(0) : (a.each(c.suggestions, function (a, b) { e && (m += n(b, g, a)), m += '<div class="' + h + '" data-index="' + a + '">' + f(b, g, a) + "</div>" }), this.adjustContainerWidth(), k.detach(), j.html(m), a.isFunction(l) && l.call(c.element, j, c.suggestions), c.fixPosition(), j.show(), d.autoSelectFirst && (c.selectedIndex = 0, j.scrollTop(0), j.children("." + h).first().addClass(i)), c.visible = !0, void c.findBestHint()) }, noSuggestions: function () { var b = this, c = a(b.suggestionsContainer), d = a(b.noSuggestionsContainer); this.adjustContainerWidth(), d.detach(), c.empty(), c.append(d), b.fixPosition(), c.show(), b.visible = !0 }, adjustContainerWidth: function () { var b, c = this, d = c.options, e = a(c.suggestionsContainer); "auto" === d.width && (b = c.el.outerWidth(), e.css("width", b > 0 ? b : 300)) }, findBestHint: function () { var b = this, c = b.el.val().toLowerCase(), d = null; c && (a.each(b.suggestions, function (a, b) { var e = 0 === b.value.toLowerCase().indexOf(c); return e && (d = b), !e }), b.signalHint(d)) }, signalHint: function (b) { var c = "", d = this; b && (c = d.currentValue + b.value.substr(d.currentValue.length)), d.hintValue !== c && (d.hintValue = c, d.hint = b, (this.options.onHint || a.noop)(c)) }, verifySuggestionsFormat: function (b) { return b.length && "string" == typeof b[0] ? a.map(b, function (a) { return { value: a, data: null } }) : b }, validateOrientation: function (b, c) { return b = a.trim(b || "").toLowerCase(), -1 === a.inArray(b, ["auto", "bottom", "top"]) && (b = c), b }, processResponse: function (a, b, c) { var d = this, e = d.options; a.suggestions = d.verifySuggestionsFormat(a.suggestions), e.noCache || (d.cachedResponse[c] = a, e.preventBadQueries && !a.suggestions.length && d.badQueries.push(b)), b === d.getQuery(d.currentValue) && (d.suggestions = a.suggestions, d.suggest()) }, activate: function (b) { var c, d = this, e = d.classes.selected, f = a(d.suggestionsContainer), g = f.find("." + d.classes.suggestion); return f.find("." + e).removeClass(e), d.selectedIndex = b, -1 !== d.selectedIndex && g.length > d.selectedIndex ? (c = g.get(d.selectedIndex), a(c).addClass(e), c) : null }, selectHint: function () { var b = this, c = a.inArray(b.hint, b.suggestions); b.select(c) }, select: function (a) { var b = this; b.hide(), b.onSelect(a), b.disableKillerFn() }, moveUp: function () { var b = this; if (-1 !== b.selectedIndex) return 0 === b.selectedIndex ? (a(b.suggestionsContainer).children().first().removeClass(b.classes.selected), b.selectedIndex = -1, b.el.val(b.currentValue), void b.findBestHint()) : void b.adjustScroll(b.selectedIndex - 1) }, moveDown: function () { var a = this; a.selectedIndex !== a.suggestions.length - 1 && a.adjustScroll(a.selectedIndex + 1) }, adjustScroll: function (b) { var c = this, d = c.activate(b); if (d) { var e, f, g, h = a(d).outerHeight(); e = d.offsetTop, f = a(c.suggestionsContainer).scrollTop(), g = f + c.options.maxHeight - h, f > e ? a(c.suggestionsContainer).scrollTop(e) : e > g && a(c.suggestionsContainer).scrollTop(e - c.options.maxHeight + h), c.options.preserveInput || c.el.val(c.getValue(c.suggestions[b].value)), c.signalHint(null) } }, onSelect: function (b) { var c = this, d = c.options.onSelect, e = c.suggestions[b]; c.currentValue = c.getValue(e.value), c.currentValue === c.el.val() || c.options.preserveInput || c.el.val(c.currentValue), c.signalHint(null), c.suggestions = [], c.selection = e, a.isFunction(d) && d.call(c.element, e) }, getValue: function (a) { var b, c, d = this, e = d.options.delimiter; return e ? (b = d.currentValue, c = b.split(e), 1 === c.length ? a : b.substr(0, b.length - c[c.length - 1].length) + a) : a }, dispose: function () { var b = this; b.el.off(".autocomplete").removeData("autocomplete"), b.disableKillerFn(), a(window).off("resize.autocomplete", b.fixPositionCapture), a(b.suggestionsContainer).remove() } }, a.fn.autocomplete = a.fn.devbridgeAutocomplete = function (c, d) { var e = "autocomplete"; return arguments.length ? this.each(function () { var f = a(this), g = f.data(e); "string" == typeof c ? g && "function" == typeof g[c] && g[c](d) : (g && g.dispose && g.dispose(), g = new b(this, c), f.data(e, g)) }) : this.first().data(e) } });
(function (j, f) {
  var c = j(window); function n() { return new Date(Date.UTC.apply(Date, arguments)); } function g() {
    var q = new Date(); return n(q.getFullYear(), q.getMonth(), q.getDate());
  } function l(q) { return function () { return this[q].apply(this, arguments); }; } var e = (function () {
    var q = {
      get: function (r) { return this.slice(r)[0]; }, contains: function (u) {
        var t = u && u.valueOf();
        for (var s = 0, r = this.length; s < r; s++) { if (this[s].valueOf() === t) { return s; } } return -1;
      }, remove: function (r) { this.splice(r, 1); }, replace: function (r) {
        if (!r) {
          return;
        } if (!j.isArray(r)) { r = [r]; } this.clear(); this.push.apply(this, r);
      }, clear: function () { this.splice(0); }, copy: function () {
        var r = new e(); r.replace(this); return r;
      }
    }; return function () { var r = []; r.push.apply(r, arguments); j.extend(r, q); return r; };
  })(); var k = function (r, q) {
    this.dates = new e(); this.viewDate = g(); this.focusDate = null;
    this._process_options(q); this.element = j(r); this.isInline = false; this.isInput = this.element.is("input"); this.component = this.element.is(".date") ? this.element.find(".add-on, .input-group-addon, .btn") : false;
    this.hasInput = this.component && this.element.find("input").length; if (this.component && this.component.length === 0) { this.component = false; } this.picker = j(m.template);
    this._buildEvents(); this._attachEvents(); if (this.isInline) { this.picker.addClass("datepicker-inline").appendTo(this.element); } else {
      this.picker.addClass("datepicker-dropdown dropdown-menu");
    } if (this.o.rtl) { this.picker.addClass("datepicker-rtl"); } this.viewMode = this.o.startView; if (this.o.calendarWeeks) {
      this.picker.find("tfoot th.today").attr("colspan", function (s, t) {
        return parseInt(t) + 1;
      });
    } this._allow_update = false; this.setStartDate(this._o.startDate); this.setEndDate(this._o.endDate); this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);
    this.fillDow(); this.fillMonths(); this._allow_update = true; this.update(); this.showMode(); if (this.isInline) { this.show(); }
  }; k.prototype = {
    constructor: k, _process_options: function (q) {
      this._o = j.extend({}, this._o, q);
      var u = this.o = j.extend({}, this._o); var t = u.language; if (!b[t]) { t = t.split("-")[0]; if (!b[t]) { t = h.language; } } u.language = t; switch (u.startView) {
        case 2: case "decade": u.startView = 2;
          break; case 1: case "year": u.startView = 1; break; default: u.startView = 0;
      }switch (u.minViewMode) {
        case 1: case "months": u.minViewMode = 1; break; case 2: case "years": u.minViewMode = 2;
          break; default: u.minViewMode = 0;
      }u.startView = Math.max(u.startView, u.minViewMode); if (u.multidate !== true) {
        u.multidate = Number(u.multidate) || false; if (u.multidate !== false) {
          u.multidate = Math.max(0, u.multidate);
        } else { u.multidate = 1; }
      } u.multidateSeparator = String(u.multidateSeparator); u.weekStart %= 7; u.weekEnd = ((u.weekStart + 6) % 7); var r = m.parseFormat(u.format); if (u.startDate !== -Infinity) {
        if (!!u.startDate) {
          if (u.startDate instanceof Date) {
            u.startDate = this._local_to_utc(this._zero_time(u.startDate));
          } else { u.startDate = m.parseDate(u.startDate, r, u.language); }
        } else { u.startDate = -Infinity; }
      } if (u.endDate !== Infinity) {
        if (!!u.endDate) {
          if (u.endDate instanceof Date) {
            u.endDate = this._local_to_utc(this._zero_time(u.endDate));
          } else { u.endDate = m.parseDate(u.endDate, r, u.language); }
        } else { u.endDate = Infinity; }
      } u.daysOfWeekDisabled = u.daysOfWeekDisabled || []; if (!j.isArray(u.daysOfWeekDisabled)) {
        u.daysOfWeekDisabled = u.daysOfWeekDisabled.split(/[,\s]*/);
      } u.daysOfWeekDisabled = j.map(u.daysOfWeekDisabled, function (w) { return parseInt(w, 10); }); var s = String(u.orientation).toLowerCase().split(/\s+/g), v = u.orientation.toLowerCase();
      s = j.grep(s, function (w) { return (/^auto|left|right|top|bottom$/).test(w); }); u.orientation = { x: "auto", y: "auto" }; if (!v || v === "auto") { } else {
        if (s.length === 1) {
          switch (s[0]) {
            case "top": case "bottom": u.orientation.y = s[0];
              break; case "left": case "right": u.orientation.x = s[0]; break;
          }
        } else {
          v = j.grep(s, function (w) { return (/^left|right$/).test(w); }); u.orientation.x = v[0] || "auto"; v = j.grep(s, function (w) {
            return (/^top|bottom$/).test(w);
          }); u.orientation.y = v[0] || "auto";
        }
      }
    }, _events: [], _secondaryEvents: [], _applyEvents: function (q) {
      for (var r = 0, t, s, u; r < q.length; r++) {
        t = q[r][0]; if (q[r].length === 2) {
          s = f;
          u = q[r][1];
        } else { if (q[r].length === 3) { s = q[r][1]; u = q[r][2]; } } t.on(u, s);
      }
    }, _unapplyEvents: function (q) {
      for (var r = 0, t, u, s; r < q.length; r++) {
        t = q[r][0]; if (q[r].length === 2) {
          s = f;
          u = q[r][1];
        } else { if (q[r].length === 3) { s = q[r][1]; u = q[r][2]; } } t.off(u, s);
      }
    }, _buildEvents: function () {
      if (this.isInput) {
        this._events = [[this.element, {
          focus: j.proxy(this.show, this), keyup: j.proxy(function (q) {
            if (j.inArray(q.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1) {
              this.update();
            }
          }, this), keydown: j.proxy(this.keydown, this)
        }]];
      } else {
        if (this.component && this.hasInput) {
          this._events = [[this.element.find("input"), {
            focus: j.proxy(this.show, this), keyup: j.proxy(function (q) {
              if (j.inArray(q.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1) {
                this.update();
              }
            }, this), keydown: j.proxy(this.keydown, this)
          }], [this.component, { click: j.proxy(this.show, this) }]];
        } else {
          if (this.element.is("div")) { this.isInline = true; } else {
            this._events = [[this.element, { click: j.proxy(this.show, this) }]];
          }
        }
      } this._events.push([this.element, "*", { blur: j.proxy(function (q) { this._focused_from = q.target; }, this) }], [this.element, {
        blur: j.proxy(function (q) {
          this._focused_from = q.target;
        }, this)
      }]); this._secondaryEvents = [[this.picker, { click: j.proxy(this.click, this) }], [j(window), { resize: j.proxy(this.place, this) }], [j(document), {
        "mousedown touchstart": j.proxy(function (q) {
          if (!(this.element.is(q.target) || this.element.find(q.target).length || this.picker.is(q.target) || this.picker.find(q.target).length)) {
            this.hide();
          }
        }, this)
      }]];
    }, _attachEvents: function () { this._detachEvents(); this._applyEvents(this._events); }, _detachEvents: function () {
      this._unapplyEvents(this._events);
    }, _attachSecondaryEvents: function () { this._detachSecondaryEvents(); this._applyEvents(this._secondaryEvents); }, _detachSecondaryEvents: function () {
      this._unapplyEvents(this._secondaryEvents);
    }, _trigger: function (s, t) {
      var r = t || this.dates.get(-1), q = this._utc_to_local(r); this.element.trigger({
        type: s, date: q, dates: j.map(this.dates, this._utc_to_local), format: j.proxy(function (u, w) {
          if (arguments.length === 0) {
            u = this.dates.length - 1;
            w = this.o.format;
          } else { if (typeof u === "string") { w = u; u = this.dates.length - 1; } } w = w || this.o.format; var v = this.dates.get(u); return m.formatDate(v, w, this.o.language);
        }, this)
      });
    }, show: function () {
      if (!this.isInline) { this.picker.appendTo("body"); } this.picker.show(); this.place(); this._attachSecondaryEvents(); this._trigger("show");
    }, hide: function () {
      if (this.isInline) { return; } if (!this.picker.is(":visible")) { return; } this.focusDate = null; this.picker.hide().detach(); this._detachSecondaryEvents();
      this.viewMode = this.o.startView; this.showMode(); if (this.o.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find("input").val())) {
        this.setValue();
      } this._trigger("hide");
    }, remove: function () {
      this.hide(); this._detachEvents(); this._detachSecondaryEvents(); this.picker.remove(); delete this.element.data().datepicker;
      if (!this.isInput) { delete this.element.data().date; }
    }, _utc_to_local: function (q) { return q && new Date(q.getTime() + (q.getTimezoneOffset() * 60000)); }, _local_to_utc: function (q) {
      return q && new Date(q.getTime() - (q.getTimezoneOffset() * 60000));
    }, _zero_time: function (q) { return q && new Date(q.getFullYear(), q.getMonth(), q.getDate()); }, _zero_utc_time: function (q) {
      return q && new Date(Date.UTC(q.getUTCFullYear(), q.getUTCMonth(), q.getUTCDate()));
    }, getDates: function () { return j.map(this.dates, this._utc_to_local); }, getUTCDates: function () { return j.map(this.dates, function (q) { return new Date(q); }); }, getDate: function () {
      return this._utc_to_local(this.getUTCDate());
    }, getUTCDate: function () { return new Date(this.dates.get(-1)); }, setDates: function () {
      var q = j.isArray(arguments[0]) ? arguments[0] : arguments; this.update.apply(this, q);
      this._trigger("changeDate"); this.setValue();
    }, setUTCDates: function () {
      var q = j.isArray(arguments[0]) ? arguments[0] : arguments; this.update.apply(this, j.map(q, this._utc_to_local));
      this._trigger("changeDate"); this.setValue();
    }, setDate: l("setDates"), setUTCDate: l("setUTCDates"), setValue: function () {
      var q = this.getFormattedDate(); if (!this.isInput) {
        if (this.component) {
          this.element.find("input").val(q).change();
        }
      } else { this.element.val(q).change(); }
    }, getFormattedDate: function (q) {
      if (q === f) { q = this.o.format; } var r = this.o.language; return j.map(this.dates, function (s) {
        return m.formatDate(s, q, r);
      }).join(this.o.multidateSeparator);
    }, setStartDate: function (q) { this._process_options({ startDate: q }); this.update(); this.updateNavArrows(); }, setEndDate: function (q) {
      this._process_options({ endDate: q });
      this.update(); this.updateNavArrows();
    }, setDaysOfWeekDisabled: function (q) {
      this._process_options({ daysOfWeekDisabled: q }); this.update(); this.updateNavArrows();
    }, place: function () {
      if (this.isInline) { return; } var E = this.picker.outerWidth(), A = this.picker.outerHeight(), u = 10, w = c.width(), r = c.height(), v = c.scrollTop(); var C = parseInt(this.element.parents().filter(function () {
        return j(this).css("z-index") !== "auto";
      }).first().css("z-index")) + 10; var z = this.component ? this.component.parent().offset() : this.element.offset(); var D = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
      var t = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false); var y = z.left, B = z.top; this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left");
      if (this.o.orientation.x !== "auto") { this.picker.addClass("datepicker-orient-" + this.o.orientation.x); if (this.o.orientation.x === "right") { y -= E - t; } } else {
        this.picker.addClass("datepicker-orient-left");
        if (z.left < 0) { y -= z.left - u; } else { if (z.left + E > w) { y = w - E - u; } }
      } var q = this.o.orientation.y, s, x; if (q === "auto") {
        s = -v + z.top - A; x = v + r - (z.top + D + A); if (Math.max(s, x) === x) {
          q = "top";
        } else { q = "bottom"; }
      } this.picker.addClass("datepicker-orient-" + q); if (q === "top") { B += D; } else { B -= A + parseInt(this.picker.css("padding-top")); } this.picker.css({ top: B, left: y, zIndex: C });
    }, _allow_update: true, update: function () {
      if (!this._allow_update) { return; } var r = this.dates.copy(), s = [], q = false; if (arguments.length) {
        j.each(arguments, j.proxy(function (u, t) {
          if (t instanceof Date) {
            t = this._local_to_utc(t);
          } s.push(t);
        }, this)); q = true;
      } else {
        s = this.isInput ? this.element.val() : this.element.data("date") || this.element.find("input").val(); if (s && this.o.multidate) {
          s = s.split(this.o.multidateSeparator);
        } else { s = [s]; } delete this.element.data().date;
      } s = j.map(s, j.proxy(function (t) { return m.parseDate(t, this.o.format, this.o.language); }, this)); s = j.grep(s, j.proxy(function (t) {
        return (t < this.o.startDate || t > this.o.endDate || !t);
      }, this), true); this.dates.replace(s); if (this.dates.length) { this.viewDate = new Date(this.dates.get(-1)); } else {
        if (this.viewDate < this.o.startDate) {
          this.viewDate = new Date(this.o.startDate);
        } else { if (this.viewDate > this.o.endDate) { this.viewDate = new Date(this.o.endDate); } }
      } if (q) { this.setValue(); } else {
        if (s.length) {
          if (String(r) !== String(this.dates)) {
            this._trigger("changeDate");
          }
        }
      } if (!this.dates.length && r.length) { this._trigger("clearDate"); } this.fill();
    }, fillDow: function () {
      var r = this.o.weekStart, s = "<tr>"; if (this.o.calendarWeeks) {
        var q = '<th class="cw">&nbsp;</th>';
        s += q; this.picker.find(".datepicker-days thead tr:first-child").prepend(q);
      } while (r < this.o.weekStart + 7) {
        s += '<th class="dow">' + b[this.o.language].daysMin[(r++) % 7] + "</th>";
      } s += "</tr>"; this.picker.find(".datepicker-days thead").append(s);
    }, fillMonths: function () {
      var r = "", q = 0; while (q < 12) {
        r += '<span class="month">' + b[this.o.language].monthsShort[q++] + "</span>";
      } this.picker.find(".datepicker-months td").html(r);
    }, setRange: function (q) {
      if (!q || !q.length) { delete this.range; } else {
        this.range = j.map(q, function (r) {
          return r.valueOf();
        });
      } this.fill();
    }, getClassNames: function (s) {
      var q = [], t = this.viewDate.getUTCFullYear(), u = this.viewDate.getUTCMonth(), r = new Date(); if (s.getUTCFullYear() < t || (s.getUTCFullYear() === t && s.getUTCMonth() < u)) {
        q.push("old");
      } else { if (s.getUTCFullYear() > t || (s.getUTCFullYear() === t && s.getUTCMonth() > u)) { q.push("new"); } } if (this.focusDate && s.valueOf() === this.focusDate.valueOf()) {
        q.push("focused");
      } if (this.o.todayHighlight && s.getUTCFullYear() === r.getFullYear() && s.getUTCMonth() === r.getMonth() && s.getUTCDate() === r.getDate()) { q.push("today"); } if (this.dates.contains(s) !== -1) {
        q.push("active");
      } if (s.valueOf() < this.o.startDate || s.valueOf() > this.o.endDate || j.inArray(s.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) { q.push("disabled"); } if (this.range) {
        if (s > this.range[0] && s < this.range[this.range.length - 1]) {
          q.push("range");
        } if (j.inArray(s.valueOf(), this.range) !== -1) { q.push("selected"); }
      } return q;
    }, fill: function () {
      var L = new Date(this.viewDate), A = L.getUTCFullYear(), M = L.getUTCMonth(), F = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity, J = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity, x = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity, G = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity, y = b[this.o.language].today || b.en.today || "", s = b[this.o.language].clear || b.en.clear || "", u;
      this.picker.find(".datepicker-days thead th.datepicker-switch").text(b[this.o.language].months[M] + " " + A); this.picker.find("tfoot th.today").text(y).toggle(this.o.todayBtn !== false);
      this.picker.find("tfoot th.clear").text(s).toggle(this.o.clearBtn !== false); this.updateNavArrows(); this.fillMonths(); var O = n(A, M - 1, 28), I = m.getDaysInMonth(O.getUTCFullYear(), O.getUTCMonth());
      O.setUTCDate(I); O.setUTCDate(I - (O.getUTCDay() - this.o.weekStart + 7) % 7); var q = new Date(O); q.setUTCDate(q.getUTCDate() + 42); q = q.valueOf(); var z = []; var D; while (O.valueOf() < q) {
        if (O.getUTCDay() === this.o.weekStart) {
          z.push("<tr>");
          if (this.o.calendarWeeks) {
            var r = new Date(+O + (this.o.weekStart - O.getUTCDay() - 7) % 7 * 86400000), v = new Date(Number(r) + (7 + 4 - r.getUTCDay()) % 7 * 86400000), t = new Date(Number(t = n(v.getUTCFullYear(), 0, 1)) + (7 + 4 - t.getUTCDay()) % 7 * 86400000), B = (v - t) / 86400000 / 7 + 1;
            z.push('<td class="cw">' + B + "</td>");
          }
        } D = this.getClassNames(O); D.push("day"); if (this.o.beforeShowDay !== j.noop) {
          var C = this.o.beforeShowDay(this._utc_to_local(O));
          if (C === f) { C = {}; } else { if (typeof (C) === "boolean") { C = { enabled: C }; } else { if (typeof (C) === "string") { C = { classes: C }; } } } if (C.enabled === false) { D.push("disabled"); } if (C.classes) {
            D = D.concat(C.classes.split(/\s+/));
          } if (C.tooltip) { u = C.tooltip; }
        } D = j.unique(D); z.push('<td class="' + D.join(" ") + '"' + (u ? ' title="' + u + '"' : "") + ">" + O.getUTCDate() + "</td>"); if (O.getUTCDay() === this.o.weekEnd) {
          z.push("</tr>");
        } O.setUTCDate(O.getUTCDate() + 1);
      } this.picker.find(".datepicker-days tbody").empty().append(z.join("")); var w = this.picker.find(".datepicker-months").find("th:eq(1)").text(A).end().find("span").removeClass("active");
      j.each(this.dates, function (P, Q) { if (Q.getUTCFullYear() === A) { w.eq(Q.getUTCMonth()).addClass("active"); } }); if (A < F || A > x) { w.addClass("disabled"); } if (A === F) {
        w.slice(0, J).addClass("disabled");
      } if (A === x) { w.slice(G + 1).addClass("disabled"); } z = ""; A = parseInt(A / 10, 10) * 10; var N = this.picker.find(".datepicker-years").find("th:eq(1)").text(A + "-" + (A + 9)).end().find("td");
      A -= 1; var E = j.map(this.dates, function (P) { return P.getUTCFullYear(); }), K; for (var H = -1; H < 11; H++) {
        K = ["year"]; if (H === -1) { K.push("old"); } else {
          if (H === 10) {
            K.push("new");
          }
        } if (j.inArray(A, E) !== -1) { K.push("active"); } if (A < F || A > x) { K.push("disabled"); } z += '<span class="' + K.join(" ") + '">' + A + "</span>"; A += 1;
      } N.html(z);
    }, updateNavArrows: function () {
      if (!this._allow_update) {
        return;
      } var s = new Date(this.viewDate), q = s.getUTCFullYear(), r = s.getUTCMonth(); switch (this.viewMode) {
        case 0: if (this.o.startDate !== -Infinity && q <= this.o.startDate.getUTCFullYear() && r <= this.o.startDate.getUTCMonth()) {
          this.picker.find(".prev").css({ visibility: "hidden" });
        } else { this.picker.find(".prev").css({ visibility: "visible" }); } if (this.o.endDate !== Infinity && q >= this.o.endDate.getUTCFullYear() && r >= this.o.endDate.getUTCMonth()) {
          this.picker.find(".next").css({ visibility: "hidden" });
        } else { this.picker.find(".next").css({ visibility: "visible" }); } break; case 1: case 2: if (this.o.startDate !== -Infinity && q <= this.o.startDate.getUTCFullYear()) {
          this.picker.find(".prev").css({ visibility: "hidden" });
        } else { this.picker.find(".prev").css({ visibility: "visible" }); } if (this.o.endDate !== Infinity && q >= this.o.endDate.getUTCFullYear()) {
          this.picker.find(".next").css({ visibility: "hidden" });
        } else { this.picker.find(".next").css({ visibility: "visible" }); } break;
      }
    }, click: function (u) {
      u.preventDefault(); var v = j(u.target).closest("span, td, th"), x, w, y;
      if (v.length === 1) {
        switch (v[0].nodeName.toLowerCase()) {
          case "th": switch (v[0].className) {
            case "datepicker-switch": this.showMode(1); break; case "prev": case "next": var q = m.modes[this.viewMode].navStep * (v[0].className === "prev" ? -1 : 1);
              switch (this.viewMode) {
                case 0: this.viewDate = this.moveMonth(this.viewDate, q); this._trigger("changeMonth", this.viewDate); break; case 1: case 2: this.viewDate = this.moveYear(this.viewDate, q);
                  if (this.viewMode === 1) { this._trigger("changeYear", this.viewDate); } break;
              }this.fill(); break; case "today": var r = new Date(); r = n(r.getFullYear(), r.getMonth(), r.getDate(), 0, 0, 0);
              this.showMode(-2); var s = this.o.todayBtn === "linked" ? null : "view"; this._setDate(r, s); break; case "clear": var t; if (this.isInput) { t = this.element; } else {
                if (this.component) {
                  t = this.element.find("input");
                }
              } if (t) { t.val("").change(); } this.update(); this._trigger("changeDate"); if (this.o.autoclose) { this.hide(); } break;
          }break; case "span": if (!v.is(".disabled")) {
            this.viewDate.setUTCDate(1);
            if (v.is(".month")) {
              y = 1; w = v.parent().find("span").index(v); x = this.viewDate.getUTCFullYear(); this.viewDate.setUTCMonth(w); this._trigger("changeMonth", this.viewDate);
              if (this.o.minViewMode === 1) { this._setDate(n(x, w, y)); }
            } else {
              y = 1; w = 0; x = parseInt(v.text(), 10) || 0; this.viewDate.setUTCFullYear(x); this._trigger("changeYear", this.viewDate);
              if (this.o.minViewMode === 2) { this._setDate(n(x, w, y)); }
            } this.showMode(-1); this.fill();
          } break; case "td": if (v.is(".day") && !v.is(".disabled")) {
            y = parseInt(v.text(), 10) || 1;
            x = this.viewDate.getUTCFullYear(); w = this.viewDate.getUTCMonth(); if (v.is(".old")) { if (w === 0) { w = 11; x -= 1; } else { w -= 1; } } else {
              if (v.is(".new")) {
                if (w === 11) {
                  w = 0; x += 1;
                } else { w += 1; }
              }
            } this._setDate(n(x, w, y));
          } break;
        }
      } if (this.picker.is(":visible") && this._focused_from) { j(this._focused_from).focus(); } delete this._focused_from;
    }, _toggle_multidate: function (r) {
      var q = this.dates.contains(r); if (!r) { this.dates.clear(); } else { if (q !== -1) { this.dates.remove(q); } else { this.dates.push(r); } } if (typeof this.o.multidate === "number") {
        while (this.dates.length > this.o.multidate) {
          this.dates.remove(0);
        }
      }
    }, _setDate: function (q, s) {
      if (!s || s === "date") { this._toggle_multidate(q && new Date(q)); } if (!s || s === "view") { this.viewDate = q && new Date(q); } this.fill(); this.setValue();
      this._trigger("changeDate"); var r; if (this.isInput) { r = this.element; } else { if (this.component) { r = this.element.find("input"); } } if (r) { r.change(); } if (this.o.autoclose && (!s || s === "date")) {
        this.hide();
      }
    }, moveMonth: function (q, r) {
      if (!q) { return f; } if (!r) { return q; } var u = new Date(q.valueOf()), y = u.getUTCDate(), v = u.getUTCMonth(), t = Math.abs(r), x, w; r = r > 0 ? 1 : -1;
      if (t === 1) { w = r === -1 ? function () { return u.getUTCMonth() === v; } : function () { return u.getUTCMonth() !== x; }; x = v + r; u.setUTCMonth(x); if (x < 0 || x > 11) { x = (x + 12) % 12; } } else {
        for (var s = 0;
          s < t; s++) { u = this.moveMonth(u, r); } x = u.getUTCMonth(); u.setUTCDate(y); w = function () { return x !== u.getUTCMonth(); };
      } while (w()) {
        u.setUTCDate(--y); u.setUTCMonth(x);
      } return u;
    }, moveYear: function (r, q) { return this.moveMonth(r, q * 12); }, dateWithinRange: function (q) { return q >= this.o.startDate && q <= this.o.endDate; }, keydown: function (w) {
      if (this.picker.is(":not(:visible)")) {
        if (w.keyCode === 27) {
          this.show();
        } return;
      } var s = false, r, q, u, v = this.focusDate || this.viewDate; switch (w.keyCode) {
        case 27: if (this.focusDate) {
          this.focusDate = null; this.viewDate = this.dates.get(-1) || this.viewDate;
          this.fill();
        } else { this.hide(); } w.preventDefault(); break; case 37: case 39: if (!this.o.keyboardNavigation) { break; } r = w.keyCode === 37 ? -1 : 1; if (w.ctrlKey) {
          q = this.moveYear(this.dates.get(-1) || g(), r);
          u = this.moveYear(v, r); this._trigger("changeYear", this.viewDate);
        } else {
          if (w.shiftKey) {
            q = this.moveMonth(this.dates.get(-1) || g(), r); u = this.moveMonth(v, r); this._trigger("changeMonth", this.viewDate);
          } else { q = new Date(this.dates.get(-1) || g()); q.setUTCDate(q.getUTCDate() + r); u = new Date(v); u.setUTCDate(v.getUTCDate() + r); }
        } if (this.dateWithinRange(q)) {
          this.focusDate = this.viewDate = u;
          this.setValue(); this.fill(); w.preventDefault();
        } break; case 38: case 40: if (!this.o.keyboardNavigation) { break; } r = w.keyCode === 38 ? -1 : 1; if (w.ctrlKey) {
          q = this.moveYear(this.dates.get(-1) || g(), r);
          u = this.moveYear(v, r); this._trigger("changeYear", this.viewDate);
        } else {
          if (w.shiftKey) {
            q = this.moveMonth(this.dates.get(-1) || g(), r); u = this.moveMonth(v, r); this._trigger("changeMonth", this.viewDate);
          } else { q = new Date(this.dates.get(-1) || g()); q.setUTCDate(q.getUTCDate() + r * 7); u = new Date(v); u.setUTCDate(v.getUTCDate() + r * 7); }
        } if (this.dateWithinRange(q)) {
          this.focusDate = this.viewDate = u;
          this.setValue(); this.fill(); w.preventDefault();
        } break; case 32: break; case 13: v = this.focusDate || this.dates.get(-1) || this.viewDate; this._toggle_multidate(v);
          s = true; this.focusDate = null; this.viewDate = this.dates.get(-1) || this.viewDate; this.setValue(); this.fill(); if (this.picker.is(":visible")) {
            w.preventDefault();
            if (this.o.autoclose) { this.hide(); }
          } break; case 9: this.focusDate = null; this.viewDate = this.dates.get(-1) || this.viewDate; this.fill(); this.hide(); break;
      }if (s) {
        if (this.dates.length) {
          this._trigger("changeDate");
        } else { this._trigger("clearDate"); } var t; if (this.isInput) { t = this.element; } else { if (this.component) { t = this.element.find("input"); } } if (t) { t.change(); }
      }
    }, showMode: function (q) {
      if (q) {
        this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + q));
      } this.picker.find(">div").hide().filter(".datepicker-" + m.modes[this.viewMode].clsName).css("display", "block"); this.updateNavArrows();
    }
  }; var p = function (r, q) {
    this.element = j(r);
    this.inputs = j.map(q.inputs, function (s) { return s.jquery ? s[0] : s; }); delete q.inputs; j(this.inputs).datepicker(q).bind("changeDate", j.proxy(this.dateUpdated, this));
    this.pickers = j.map(this.inputs, function (s) { return j(s).data("datepicker"); }); this.updateDates();
  }; p.prototype = {
    updateDates: function () {
      this.dates = j.map(this.pickers, function (q) {
        return q.getUTCDate();
      }); this.updateRanges();
    }, updateRanges: function () {
      var q = j.map(this.dates, function (r) { return r.valueOf(); }); j.each(this.pickers, function (r, s) {
        s.setRange(q);
      });
    }, dateUpdated: function (t) {
      if (this.updating) { return; } this.updating = true; var u = j(t.target).data("datepicker"), s = u.getUTCDate(), r = j.inArray(t.target, this.inputs), q = this.inputs.length;
      if (r === -1) { return; } j.each(this.pickers, function (v, w) { if (!w.getUTCDate()) { w.setUTCDate(s); } }); if (s < this.dates[r]) {
        while (r >= 0 && s < this.dates[r]) {
          this.pickers[r--].setUTCDate(s);
        }
      } else { if (s > this.dates[r]) { while (r < q && s > this.dates[r]) { this.pickers[r++].setUTCDate(s); } } } this.updateDates(); delete this.updating;
    }, remove: function () {
      j.map(this.pickers, function (q) {
        q.remove();
      }); delete this.element.data().datepicker;
    }
  }; function i(t, w) {
    var v = j(t).data(), q = {}, u, s = new RegExp("^" + w.toLowerCase() + "([A-Z])"); w = new RegExp("^" + w.toLowerCase());
    function x(z, y) { return y.toLowerCase(); } for (var r in v) { if (w.test(r)) { u = r.replace(s, x); q[u] = v[r]; } } return q;
  } function a(s) {
    var q = {}; if (!b[s]) {
      s = s.split("-")[0];
      if (!b[s]) { return; }
    } var r = b[s]; j.each(o, function (u, t) { if (t in r) { q[t] = r[t]; } }); return q;
  } var d = j.fn.datepicker; j.fn.datepicker = function (s) {
    var q = Array.apply(null, arguments);
    q.shift(); var r; this.each(function () {
      var A = j(this), y = A.data("datepicker"), u = typeof s === "object" && s; if (!y) {
        var w = i(this, "date"), t = j.extend({}, h, w, u), v = a(t.language), x = j.extend({}, h, v, w, u);
        if (A.is(".input-daterange") || x.inputs) { var z = { inputs: x.inputs || A.find("input").toArray() }; A.data("datepicker", (y = new p(this, j.extend(x, z)))); } else {
          A.data("datepicker", (y = new k(this, x)));
        }
      } if (typeof s === "string" && typeof y[s] === "function") { r = y[s].apply(y, q); if (r !== f) { return false; } }
    }); if (r !== f) { return r; } else { return this; }
  }; var h = j.fn.datepicker.defaults = { autoclose: false, beforeShowDay: j.noop, calendarWeeks: false, clearBtn: false, daysOfWeekDisabled: [], endDate: Infinity, forceParse: true, format: "mm/dd/yyyy", keyboardNavigation: true, language: "en", minViewMode: 0, multidate: false, multidateSeparator: ",", orientation: "auto", rtl: false, startDate: -Infinity, startView: 0, todayBtn: false, todayHighlight: false, weekStart: 0 };
  var o = j.fn.datepicker.locale_opts = ["format", "rtl", "weekStart"]; j.fn.datepicker.Constructor = k; var b = j.fn.datepicker.dates = { en: { days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], today: "Today", clear: "Clear" } };
  var m = {
    modes: [{ clsName: "days", navFnc: "Month", navStep: 1 }, { clsName: "months", navFnc: "FullYear", navStep: 1 }, { clsName: "years", navFnc: "FullYear", navStep: 10 }], isLeapYear: function (q) {
      return (((q % 4 === 0) && (q % 100 !== 0)) || (q % 400 === 0));
    }, getDaysInMonth: function (q, r) { return [31, (m.isLeapYear(q) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r]; }, validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g, nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g, parseFormat: function (s) {
      var q = s.replace(this.validParts, "\0").split("\0"), r = s.match(this.validParts);
      if (!q || !q.length || !r || r.length === 0) { throw new Error("Invalid date format."); } return { separators: q, parts: r };
    }, parseDate: function (H, E, B) {
      if (!H) { return f; } if (H instanceof Date) {
        return H;
      } if (typeof E === "string") { E = m.parseFormat(E); } var t = /([\-+]\d+)([dmwy])/, z = H.match(/([\-+]\d+)([dmwy])/g), A, y, D; if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(H)) {
        H = new Date();
        for (D = 0; D < z.length; D++) {
          A = t.exec(z[D]); y = parseInt(A[1]); switch (A[2]) {
            case "d": H.setUTCDate(H.getUTCDate() + y); break; case "m": H = k.prototype.moveMonth.call(k.prototype, H, y);
              break; case "w": H.setUTCDate(H.getUTCDate() + y * 7); break; case "y": H = k.prototype.moveYear.call(k.prototype, H, y); break;
          }
        } return n(H.getUTCFullYear(), H.getUTCMonth(), H.getUTCDate(), 0, 0, 0);
      } z = H && H.match(this.nonpunctuation) || []; H = new Date(); var u = {}, F = ["yyyy", "yy", "M", "MM", "m", "mm", "d", "dd"], x = {
        yyyy: function (J, s) {
          return J.setUTCFullYear(s);
        }, yy: function (J, s) { return J.setUTCFullYear(2000 + s); }, m: function (J, s) {
          if (isNaN(J)) { return J; } s -= 1; while (s < 0) { s += 12; } s %= 12; J.setUTCMonth(s); while (J.getUTCMonth() !== s) {
            J.setUTCDate(J.getUTCDate() - 1);
          } return J;
        }, d: function (J, s) { return J.setUTCDate(s); }
      }, I, r; x.M = x.MM = x.mm = x.m; x.dd = x.d; H = n(H.getFullYear(), H.getMonth(), H.getDate(), 0, 0, 0); var q = E.parts.slice();
      if (z.length !== q.length) { q = j(q).filter(function (s, J) { return j.inArray(J, F) !== -1; }).toArray(); } function G() {
        var s = this.slice(0, z[D].length), J = z[D].slice(0, s.length);
        return s === J;
      } if (z.length === q.length) {
        var C; for (D = 0, C = q.length; D < C; D++) {
          I = parseInt(z[D], 10); A = q[D]; if (isNaN(I)) {
            switch (A) {
              case "MM": r = j(b[B].months).filter(G);
                I = j.inArray(r[0], b[B].months) + 1; break; case "M": r = j(b[B].monthsShort).filter(G); I = j.inArray(r[0], b[B].monthsShort) + 1; break;
            }
          } u[A] = I;
        } var v, w; for (D = 0; D < F.length;
          D++) { w = F[D]; if (w in u && !isNaN(u[w])) { v = new Date(H); x[w](v, u[w]); if (!isNaN(v)) { H = v; } } }
      } return H;
    }, formatDate: function (q, u, w) {
      if (!q) { return ""; } if (typeof u === "string") {
        u = m.parseFormat(u);
      } var v = { d: q.getUTCDate(), D: b[w].daysShort[q.getUTCDay()], DD: b[w].days[q.getUTCDay()], m: q.getUTCMonth() + 1, M: b[w].monthsShort[q.getUTCMonth()], MM: b[w].months[q.getUTCMonth()], yy: q.getUTCFullYear().toString().substring(2), yyyy: q.getUTCFullYear() };
      v.dd = (v.d < 10 ? "0" : "") + v.d; v.mm = (v.m < 10 ? "0" : "") + v.m; q = []; var t = j.extend([], u.separators); for (var s = 0, r = u.parts.length; s <= r; s++) {
        if (t.length) {
          q.push(t.shift());
        } q.push(v[u.parts[s]]);
      } return q.join("");
    }, headTemplate: '<thead><tr><th class="prev">&laquo;</th><th colspan="5" class="datepicker-switch"></th><th class="next">&raquo;</th></tr></thead>', contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>', footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
  };
  m.template = '<div class="datepicker"><div class="datepicker-days"><table class=" table-condensed">' + m.headTemplate + "<tbody></tbody>" + m.footTemplate + '</table></div><div class="datepicker-months"><table class="table-condensed">' + m.headTemplate + m.contTemplate + m.footTemplate + '</table></div><div class="datepicker-years"><table class="table-condensed">' + m.headTemplate + m.contTemplate + m.footTemplate + "</table></div></div>";
  j.fn.datepicker.DPGlobal = m; j.fn.datepicker.noConflict = function () { j.fn.datepicker = d; return this; }; j(document).on("focus.datepicker.data-api click.datepicker.data-api", '[data-provide="datepicker"]', function (r) {
    var q = j(this);
    if (q.data("datepicker")) { return; } r.preventDefault(); q.datepicker("show");
  }); j(function () { j('[data-provide="datepicker-inline"]').datepicker(); });
}(window.jQuery));
;
(function (a) {
  a.fn.datepicker.dates.ru = { days: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"], daysShort: ["Вск", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Суб", "Вск"], daysMin: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"], months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"], monthsShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"], today: "Сегодня", clear: "Убрать дату", weekStart: 1 };
  a.fn.datepicker.defaults.format = "dd.mm.yyyy"; a.fn.datepicker.defaults.language = "ru"; a.fn.datepicker.defaults.autoclose = true;
}(jQuery));
/**
 * jBox is a jQuery plugin that makes it easy to create customizable tooltips, modal windows, image galleries and more.
 *
 * Author: Stephan Wagner (https://stephanwagner.me)
 *
 * License: MIT (https://opensource.org/licenses/MIT)
 *
 * Requires: jQuery 3.2.1 (https://code.jquery.com/jquery-3.2.1.min.js)
 *
 * Documentation: https://stephanwagner.me/jBox/documentation
 *
 * Demos: https://stephanwagner.me/jBox/demos
 */


// AMD and CommonJS support: http://ifandelse.com/its-not-hard-making-your-library-support-amd-and-commonjs

(function (root, factory) {

  // AMD support

  if (typeof define === 'function' && define.amd) {

    define(['jquery'], function (jQuery) {
      return (root.jBox = factory(jQuery));
    });

    // CommonJS support

  } else if (typeof module === 'object' && module.exports) {

    module.exports = (root.jBox = factory(require('jquery')));

    // Browser

  } else {

    root.jBox = factory(root.jQuery);

  }

}(this, function (jQuery) {


  // The actual jBox plugin starts here

  var jBox = function jBox(type, options) {


    // Options (https://stephanwagner.me/jBox/options)

    this.options = {

      // jBox ID
      id: null,                    // Choose a unique id, otherwise jBox will set one for you (jBox1, jBox2, ...)

      // Dimensions
      width: 'auto',               // The width of the content area, e.g. 'auto', 200, '80%'
      height: 'auto',              // The height of the content area
      minWidth: null,              // Minimal width
      minHeight: null,             // Minimal height
      maxWidth: null,              // Maximal width
      maxHeight: null,             // Maximal height

      // Responsive dimensions
      responsiveWidth: true,       // Adjusts the width to fit the viewport
      responsiveHeight: true,      // Adjusts the height to fit the viewport
      responsiveMinWidth: 100,     // Don't adjust width below this value (in pixel)
      responsiveMinHeight: 100,    // Don't adjust height below this value (in pixel)

      // Attach
      attach: null,                // A jQuery selector to elements that will open and close your jBox, e.g. '.tooltip'
      trigger: 'click',            // The event to open or close your jBox, use 'click', 'touchclick' or 'mouseenter'
      preventDefault: false,       // Prevent the default event when opening jBox, e.g. don't follow the href in a link

      // Content
      content: null,               // You can use HTML or a jQuery element, e.g. jQuery('#jBox-content'). The elements will be appended to the content element and then made visible, so hide them with style="display: none" beforehand
      getContent: null,            // Get the content from an attribute when jBox opens, e.g. getContent: 'data-content'. Use 'html' to get the attached elements HTML as content
      title: null,                 // Adds a title to your jBox
      getTitle: null,              // Get the title from an attribute when jBox opens, e.g. getTitle: 'data-title'
      footer: null,                // Adds a footer to your jBox
      isolateScroll: true,         // Isolates scrolling to the content container

      // AJAX
      ajax: {                      // Setting an URL will make an AJAX request when jBox opens. Optional you can add any jQuery AJAX option (http://api.jquery.com/jquery.ajax/)
        url: null,                 // The URL to send the AJAX request to
        data: '',                  // Data to send with your AJAX request, e.g. {id: 82, limit: 10}
        reload: false,             // Resend the AJAX request when jBox opens. Use true to send the AJAX request only once for every attached element or 'strict' to resend every time jBox opens
        getURL: 'data-url',        // The attribute in the source element where the AJAX request will look for the URL, e.g. data-url="https://ajaxresponse.com"
        getData: 'data-ajax',      // The attribute in the source element where the AJAX request will look for the data, e.g. data-ajax="id=82&limit=10"
        setContent: true,          // Automatically set the response as new content when the AJAX request is finished
        spinner: true,             // Hides the current content and adds a spinner while loading. You can pass HTML content to add your own spinner, e.g. spinner: '<div class="mySpinner"></div>'
        spinnerDelay: 300,         // Milliseconds to wait until spinner appears
        spinnerReposition: true    // Repositions jBox when the spinner is added or removed
      },

      // Position
      followMouse: false,          // open in mouse position

      target: null,                // The jQuery selector to the target element where jBox will be opened. If no element is found, jBox will use the attached element as target
      position: {
        x: 'center',               // Horizontal position, use a number, 'left', 'right' or 'center'
        y: 'center'                // Vertical position, use a number, 'top', 'bottom' or 'center'
      },
      outside: null,               // Use 'x', 'y', or 'xy' to move your jBox outside of the target element
      offset: 0,                   // Offset to final position, you can set different values for x and y with an object, e.g. {x: 20, y: 10}
      attributes: {                // Note that attributes can only be 'left' or 'right' when using numbers for position, e.g. {x: 300, y: 20}
        x: 'left',                 // Horizontal position, use 'left' or 'right'
        y: 'top'                   // Vertical position, use 'top' or 'bottom'
      },
      fixed: false,                // Your jBox will stay on position when scrolling
      adjustPosition: true,        // Adjusts your jBoxes position if there is not enough space, use 'flip', 'move' or true for both. This option overrides the reposition options
      adjustTracker: false,        // By default jBox adjusts its position when it opens or when the window size changes, set to true to also adjust when scrolling
      adjustDistance: 5,           // The minimal distance to the viewport edge while adjusting. Use an object to set different values, e.g. {top: 50, right: 5, bottom: 20, left: 5}
      reposition: true,            // Calculates new position when the window-size changes
      repositionOnOpen: true,      // Calculates new position each time jBox opens (rather than only when it opens the first time)
      repositionOnContent: true,   // Calculates new position when the content changes with .setContent() or .setTitle()

      // Pointer
      pointer: false,              // Your pointer will always point towards the target element, so the option outside needs to be 'x' or 'y'. By default the pointer is centered, set a position to move it to any side. You can also add an offset, e.g. 'left:30' or 'center:-20'
      pointTo: 'target',           // Setting something else than 'target' will add a pointer even if there is no target element set or found. Use 'top', 'right', 'bottom' or 'left'

      // Animations
      fade: 180,                   // Fade duration in ms, set to 0 or false to disable
      animation: null,             // Animation when opening or closing, use 'pulse', 'zoomIn', 'zoomOut', 'move', 'slide', 'flip', 'tada' (CSS inspired from Daniel Edens Animate.css: http://daneden.me/animate)

      // Appearance
      theme: 'Default',            // Set a jBox theme class
      addClass: null,              // Adds classes to the wrapper
      overlay: false,              // Adds an overlay to hide page content when jBox opens (adjust color and opacity with CSS)
      zIndex: 10000,               // Use a high z-index

      // Delays
      delayOpen: 0,                // Delay opening in ms. Note that the delay will be ignored if your jBox didn't finish closing
      delayClose: 0,               // Delay closing in ms. Nnote that there is always a closing delay of at least 10ms to ensure jBox won't be closed when opening right away

      // Closing
      closeOnEsc: false,           // Close jBox when pressing [esc] key
      closeOnClick: false,         // Close jBox with mouseclick. Use true (click anywhere), 'box' (click on jBox itself), 'overlay' (click on the overlay), 'body' (click anywhere but jBox)
      closeOnMouseleave: false,    // Close jBox when the mouse leaves the jBox area or the area of the attached element
      closeButton: false,          // Adds a close button to your jBox. Use 'title', 'box', 'overlay' or true (true will add the button to the overlay, title or the jBox itself, in that order if any of those elements can be found)

      // Other options
      appendTo: jQuery('body'),    // The element your jBox will be appended to. Any other element than jQuery('body') is only useful for fixed positions or when position values are numbers
      createOnInit: false,         // Creates jBox and makes it available in DOM when it's being initialized, otherwise it will be created when it opens for the first time
      blockScroll: false,          // Blocks scrolling when jBox is open
      draggable: false,            // Make your jBox draggable (use 'true', 'title' or provide an element as handle) (inspired from Chris Coyiers CSS-Tricks http://css-tricks.com/snippets/jquery/draggable-without-jquery-ui/)
      dragOver: true,              // When you have multiple draggable jBoxes, the one you select will always move over the other ones
      autoClose: false,            // Time in ms when jBox will close automatically after it was opened
      delayOnHover: false,         // Delay auto-closing while mouse is hovered
      showCountdown: false,        // Display a nice progress-indicator when autoClose is enabled

      // Audio                     // You can use the integrated audio function whenever you'd like to play an audio file, e.g. onInit: function () { this.audio('url_to_audio_file_without_file_extension', 75); }
      preloadAudio: true,          // Preloads the audio files set in option audio. You can also preload other audio files, e.g. ['src_to_file.mp3', 'src_to_file.ogg']
      audio: null,                 // The URL to an audio file to play when jBox opens. Set the URL without file extension, jBox will look for an .mp3 and .ogg file. To play audio when jBox closes, use an object, e.g. {open: 'src_to_audio1', close: 'src_to_audio2'}
      volume: 100,                 // The volume in percent. To have different volumes for opening and closeing, use an object, e.g. {open: 75, close: 100}

      // Events                    // Note that you can use 'this' in all event functions, it refers to your jBox object (e.g. onInit: function () { this.open(); })
      onInit: null,                // Fired when jBox is initialized
      onAttach: null,              // Fired when jBox attached itself to elements, the attached element will be passed as a parameter, e.g. onAttach: function (element) { element.css({color: 'red'}); }
      onPosition: null,            // Fired when jBox is positioned
      onCreated: null,             // Fired when jBox is created and availible in DOM
      onOpen: null,                // Fired when jBox opens
      onClose: null,               // Fired when jBox closes
      onCloseComplete: null        // Fired when jBox is completely closed (when fading is finished)
    };


    // Default plugin options

    this._pluginOptions = {

      // Default options for tooltips
      'Tooltip': {
        getContent: 'title',
        trigger: 'mouseenter',
        position: {
          x: 'center',
          y: 'top'
        },
        outside: 'y',
        pointer: true
      },

      // Default options for mouse tooltips
      'Mouse': {
        responsiveWidth: false,
        responsiveHeight: false,
        adjustPosition: 'flip',
        target: 'mouse',
        trigger: 'mouseenter',
        position: {
          x: 'right',
          y: 'bottom'
        },
        outside: 'xy',
        offset: 5
      },

      // Default options for modal windows
      'Modal': {
        target: jQuery(window),
        fixed: true,
        blockScroll: true,
        closeOnEsc: true,
        closeOnClick: 'overlay',
        closeButton: true,
        overlay: true,
        animation: 'zoomIn'
      },
    };


    // Merge options

    this.options = jQuery.extend(true, this.options, this._pluginOptions[type] ? this._pluginOptions[type] : jBox._pluginOptions[type], options);


    // Set the jBox type

    jQuery.type(type) == 'string' && (this.type = type);


    // Local function to fire events

    this._fireEvent = function (event, pass) {
      this.options['_' + event] && (this.options['_' + event].bind(this))(pass);
      this.options[event] && (this.options[event].bind(this))(pass);
    };


    // Get a unique jBox ID

    this.options.id === null && (this.options.id = 'jBox' + jBox._getUniqueID());
    this.id = this.options.id;


    // Correct impossible options

    ((this.options.position.x == 'center' && this.options.outside == 'x') || (this.options.position.y == 'center' && this.options.outside == 'y')) && (this.options.outside = null);
    this.options.pointTo == 'target' && (!this.options.outside || this.options.outside == 'xy') && (this.options.pointer = false);


    // Correct multiple choice options

    jQuery.type(this.options.offset) != 'object' ? (this.options.offset = { x: this.options.offset, y: this.options.offset }) : (this.options.offset = jQuery.extend({ x: 0, y: 0 }, this.options.offset));
    jQuery.type(this.options.adjustDistance) != 'object' ? (this.options.adjustDistance = { top: this.options.adjustDistance, right: this.options.adjustDistance, bottom: this.options.adjustDistance, left: this.options.adjustDistance }) : (this.options.adjustDistance = jQuery.extend({ top: 5, left: 5, right: 5, bottom: 5 }, this.options.adjustDistance));


    // Save default outside position

    this.outside = this.options.outside && this.options.outside != 'xy' ? this.options.position[this.options.outside] : false;


    // Save where the jBox is aligned to

    this.align = this.outside ? this.outside : (this.options.position.y != 'center' && jQuery.type(this.options.position.y) != 'number' ? this.options.position.x : (this.options.position.x != 'center' && jQuery.type(this.options.position.x) != 'number' ? this.options.position.y : this.options.attributes.x));


    // Internal positioning functions

    this._getOpp = function (opp) { return { left: 'right', right: 'left', top: 'bottom', bottom: 'top', x: 'y', y: 'x' }[opp]; };
    this._getXY = function (xy) { return { left: 'x', right: 'x', top: 'y', bottom: 'y', center: 'x' }[xy]; };
    this._getTL = function (tl) { return { left: 'left', right: 'left', top: 'top', bottom: 'top', center: 'left', x: 'left', y: 'top' }[tl]; };


    // Get a dimension value in integer pixel dependent on appended element

    this._getInt = function (value, dimension) {
      if (value == 'auto') return 'auto';
      if (value && jQuery.type(value) == 'string' && value.slice(-1) == '%') {
        return jQuery(window)[dimension == 'height' ? 'innerHeight' : 'innerWidth']() * parseInt(value.replace('%', '')) / 100;
      }
      return value;
    };


    // Create an svg element

    this._createSVG = function (type, options) {
      var svg = document.createElementNS('http://www.w3.org/2000/svg', type);
      jQuery.each(options, function (index, item) {
        svg.setAttribute(item[0], (item[1] || ''));
      });
      return svg;
    };


    // Isolate scrolling in a container

    this._isolateScroll = function (el) {
      // Abort if element not found
      if (!el || !el.length) return;

      el.on('DOMMouseScroll.jBoxIsolateScroll mousewheel.jBoxIsolateScroll', function (ev) {
        var delta = ev.wheelDelta || (ev.originalEvent && ev.originalEvent.wheelDelta) || -ev.detail;
        var overflowBottom = this.scrollTop + el.outerHeight() - this.scrollHeight >= 0;
        var overflowTop = this.scrollTop <= 0;
        ((delta < 0 && overflowBottom) || (delta > 0 && overflowTop)) && ev.preventDefault();
      });
    };


    // Set the title width to content width 

    this._setTitleWidth = function () {
      // Abort if there is no title or width of content is auto
      if (!this.titleContainer || (this.content[0].style.width == 'auto' && !this.content[0].style.maxWidth)) return null;

      // Expose wrapper to get actual width
      if (this.wrapper.css('display') == 'none') {
        this.wrapper.css('display', 'block');
        var contentWidth = this.content.outerWidth();
        this.wrapper.css('display', 'none');
      } else {
        var contentWidth = this.content.outerWidth();
      }

      // Set max-width only
      this.titleContainer.css({ maxWidth: (Math.max(contentWidth, parseInt(this.content[0].style.maxWidth)) || null) });
    }


    // Make jBox draggable

    this._draggable = function () {
      // Abort if jBox is not draggable
      if (!this.options.draggable) return false;

      // Get the handle where jBox will be dragged with
      var handle = this.options.draggable == 'title' ? this.titleContainer : (this.options.draggable instanceof jQuery ? this.options.draggable : (jQuery.type(this.options.draggable) == 'string' ? jQuery(this.options.draggable) : this.wrapper));

      // Abort if no handle or if draggable was set already
      if (!handle || !(handle instanceof jQuery) || !handle.length || handle.data('jBox-draggable')) return false;

      // Add mouse events
      handle.addClass('jBox-draggable').data('jBox-draggable', true).on('mousedown', function (ev) {
        if (ev.button == 2 || jQuery(ev.target).hasClass('jBox-noDrag') || jQuery(ev.target).parents('.jBox-noDrag').length) return;

        // Adjust z-index when dragging jBox over another draggable jBox
        if (this.options.dragOver && this.wrapper.css('zIndex') <= jBox.zIndexMax) {
          jBox.zIndexMax += 1;
          this.wrapper.css('zIndex', jBox.zIndexMax);
        }

        var drg_h = this.wrapper.outerHeight();
        var drg_w = this.wrapper.outerWidth();
        var pos_y = this.wrapper.offset().top + drg_h - ev.pageY;
        var pos_x = this.wrapper.offset().left + drg_w - ev.pageX;

        jQuery(document).on('mousemove.jBox-draggable-' + this.id, function (ev) {
          this.wrapper.offset({
            top: ev.pageY + pos_y - drg_h,
            left: ev.pageX + pos_x - drg_w
          });
        }.bind(this));
        ev.preventDefault();

      }.bind(this)).on('mouseup', function () { jQuery(document).off('mousemove.jBox-draggable-' + this.id); }.bind(this));

      // Get highest z-index
      jBox.zIndexMax = !jBox.zIndexMax ? this.options.zIndex : Math.max(jBox.zIndexMax, this.options.zIndex);



      return this;
    };

    // Create jBox

    this._create = function () {
      // Abort if jBox was created already
      if (this.wrapper) return;

      // Create wrapper
      this.wrapper = jQuery('<div/>', {
        id: this.id,
        'class': 'jBox-wrapper' + (this.type ? ' jBox-' + this.type : '') + (this.options.theme ? ' jBox-' + this.options.theme : '') + (this.options.addClass ? ' ' + this.options.addClass : '')
      }).css({
        position: (this.options.fixed ? 'fixed' : 'absolute'),
        display: 'none',
        opacity: 0,
        zIndex: this.options.zIndex

        // Save the jBox instance in the wrapper, so you can get access to your jBox when you only have the element
      }).data('jBox', this);

      // Add mouseleave event, only close jBox when the new target is not the source element
      this.options.closeOnMouseleave && this.wrapper.on('mouseleave', function (ev) {
        !this.source || !(ev.relatedTarget == this.source[0] || jQuery.inArray(this.source[0], jQuery(ev.relatedTarget).parents('*')) !== -1) && this.close();
      }.bind(this));

      // Add closeOnClick: 'box' events
      (this.options.closeOnClick == 'box') && this.wrapper.on('touchend click', function () { this.close({ ignoreDelay: true }); }.bind(this));

      // Create container
      this.container = jQuery('<div class="jBox-container"/>').appendTo(this.wrapper);

      // Create content
      this.content = jQuery('<div class="jBox-content"/>').appendTo(this.container);

      // Create footer
      this.options.footer && (this.footer = jQuery('<div class="jBox-footer"/>').append(this.options.footer).appendTo(this.container));

      // Isolate scrolling
      this.options.isolateScroll && this._isolateScroll(this.content);

      // Create close button
      if (this.options.closeButton) {
        var closeButtonSVG = this._createSVG('svg', [['viewBox', '0 0 24 24']]);
        closeButtonSVG.appendChild(this._createSVG('path', [['d', 'M22.2,4c0,0,0.5,0.6,0,1.1l-6.8,6.8l6.9,6.9c0.5,0.5,0,1.1,0,1.1L20,22.3c0,0-0.6,0.5-1.1,0L12,15.4l-6.9,6.9c-0.5,0.5-1.1,0-1.1,0L1.7,20c0,0-0.5-0.6,0-1.1L8.6,12L1.7,5.1C1.2,4.6,1.7,4,1.7,4L4,1.7c0,0,0.6-0.5,1.1,0L12,8.5l6.8-6.8c0.5-0.5,1.1,0,1.1,0L22.2,4z']]));
        this.closeButton = jQuery('<div class="jBox-closeButton jBox-noDrag"/>').on('touchend click', function (ev) { this.close({ ignoreDelay: true }); }.bind(this)).append(closeButtonSVG);

        // Add close button to jBox container
        if (this.options.closeButton == 'box' || (this.options.closeButton === true && !this.options.overlay && !this.options.title && !this.options.getTitle)) {
          this.wrapper.addClass('jBox-closeButton-box');
          this.closeButton.appendTo(this.container);
        }
      }

      // Append jBox to DOM
      this.wrapper.appendTo(this.options.appendTo);

      // Fix adjustDistance if there is a close button in the box
      this.wrapper.find('.jBox-closeButton').length && jQuery.each(['top', 'right', 'bottom', 'left'], function (index, pos) {
        this.wrapper.find('.jBox-closeButton').css(pos) && this.wrapper.find('.jBox-closeButton').css(pos) != 'auto' && (this.options.adjustDistance[pos] = Math.max(this.options.adjustDistance[pos], this.options.adjustDistance[pos] + (((parseInt(this.wrapper.find('.jBox-closeButton').css(pos)) || 0) + (parseInt(this.container.css('border-' + pos + '-width')) || 0)) * -1)));
      }.bind(this));

      // Create pointer
      if (this.options.pointer) {

        // Get pointer vars and save globally
        this.pointer = {
          position: (this.options.pointTo != 'target') ? this.options.pointTo : this._getOpp(this.outside),
          xy: (this.options.pointTo != 'target') ? this._getXY(this.options.pointTo) : this._getXY(this.outside),
          align: 'center',
          offset: 0
        };

        this.pointer.element = jQuery('<div class="jBox-pointer jBox-pointer-' + this.pointer.position + '"/>').appendTo(this.wrapper);
        this.pointer.dimensions = {
          x: this.pointer.element.outerWidth(),
          y: this.pointer.element.outerHeight()
        };

        if (jQuery.type(this.options.pointer) == 'string') {
          var split = this.options.pointer.split(':');
          split[0] && (this.pointer.align = split[0]);
          split[1] && (this.pointer.offset = parseInt(split[1]));
        }
        this.pointer.alignAttribute = (this.pointer.xy == 'x' ? (this.pointer.align == 'bottom' ? 'bottom' : 'top') : (this.pointer.align == 'right' ? 'right' : 'left'));

        // Set wrapper CSS
        this.wrapper.css('padding-' + this.pointer.position, this.pointer.dimensions[this.pointer.xy]);

        // Set pointer CSS
        this.pointer.element.css(this.pointer.alignAttribute, (this.pointer.align == 'center' ? '50%' : 0)).css('margin-' + this.pointer.alignAttribute, this.pointer.offset);
        this.pointer.margin = {};
        this.pointer.margin['margin-' + this.pointer.alignAttribute] = this.pointer.offset;

        // Add a transform to fix centered position
        (this.pointer.align == 'center') && this.pointer.element.css('transform', 'translate(' + (this.pointer.xy == 'y' ? (this.pointer.dimensions.x * -0.5 + 'px') : 0) + ', ' + (this.pointer.xy == 'x' ? (this.pointer.dimensions.y * -0.5 + 'px') : 0) + ')');

        this.pointer.element.css((this.pointer.xy == 'x' ? 'width' : 'height'), parseInt(this.pointer.dimensions[this.pointer.xy]) + parseInt(this.container.css('border-' + this.pointer.alignAttribute + '-width')));

        // Add class to wrapper for CSS access
        this.wrapper.addClass('jBox-pointerPosition-' + this.pointer.position);
      }

      // Set title and content
      this.setContent(this.options.content, true);
      this.setTitle(this.options.title, true);

      this.options.draggable && this._draggable();

      // Fire onCreated event
      this._fireEvent('onCreated');
    };


    // Create jBox onInit

    this.options.createOnInit && this._create();


    // Attach jBox

    this.options.attach && this.attach();


    // Attach document and window events

    this._attachEvents = function () {
      // Closing event: closeOnEsc
      this.options.closeOnEsc && jQuery(document).on('keyup.jBox-' + this.id, function (ev) { if (ev.keyCode == 27) { this.close({ ignoreDelay: true }); } }.bind(this));

      // Closing event: closeOnClick
      if (this.options.closeOnClick === true || this.options.closeOnClick == 'body') {
        jQuery(document).on('touchend.jBox-' + this.id + ' click.jBox-' + this.id, function (ev) {
          if (this.blockBodyClick || (this.options.closeOnClick == 'body' && (ev.target == this.wrapper[0] || this.wrapper.has(ev.target).length))) return;
          this.close({ ignoreDelay: true });
        }.bind(this));
      }

      // Cancel countdown on mouseenter if delayOnHover
      this.options.delayOnHover && jQuery('#' + this.id).on('mouseenter', function (ev) { this.isHovered = true; }.bind(this));
      // Resume countdown on mouseleave if delayOnHover
      this.options.delayOnHover && jQuery('#' + this.id).on('mouseleave', function (ev) { this.isHovered = false; }.bind(this));

      // Positioning events
      if ((this.options.adjustPosition || this.options.reposition) && !this.fixed && this.outside) {

        // Trigger position events when scrolling
        this.options.adjustTracker && jQuery(window).on('scroll.jBox-' + this.id, function (ev) { this.position(); }.bind(this));

        // Trigger position events when resizing
        (this.options.adjustPosition || this.options.reposition) && jQuery(window).on('resize.jBox-' + this.id, function (ev) { this.position(); }.bind(this));
      }

      // Mousemove events
      this.options.target == 'mouse' && jQuery('body').on('mousemove.jBox-' + this.id, function (ev) { this.position({ mouseTarget: { top: ev.pageY, left: ev.pageX } }); }.bind(this));
    };


    // Detach document and window events

    this._detachEvents = function () {
      // Closing event: closeOnEsc
      this.options.closeOnEsc && jQuery(document).off('keyup.jBox-' + this.id);

      // Closing event: closeOnClick
      (this.options.closeOnClick === true || this.options.closeOnClick == 'body') && jQuery(document).off('touchend.jBox-' + this.id + ' click.jBox-' + this.id);

      // Positioning events
      this.options.adjustTracker && jQuery(window).off('scroll.jBox-' + this.id);
      (this.options.adjustPosition || this.options.reposition) && jQuery(window).off('resize.jBox-' + this.id);

      // Mousemove events
      this.options.target == 'mouse' && jQuery('body').off('mousemove.jBox-' + this.id);
    };


    // Show overlay

    this._showOverlay = function () {
      // Create the overlay if wasn't created already
      if (!this.overlay) {

        // Create element and append to the element where jBox is appended to
        this.overlay = jQuery('<div id="' + this.id + '-overlay"/>').addClass('jBox-overlay' + (this.type ? ' jBox-overlay-' + this.type : '')).css({
          display: 'none',
          opacity: 0,
          zIndex: this.options.zIndex - 1
        }).appendTo(this.options.appendTo);

        // Add close button to overlay
        (this.options.closeButton == 'overlay' || this.options.closeButton === true) && this.overlay.append(this.closeButton);

        // Add closeOnClick: 'overlay' events
        this.options.closeOnClick == 'overlay' && this.overlay.on('touchend click', function () { this.close({ ignoreDelay: true }); }.bind(this));

        // Adjust option adjustDistance if there is a close button in the overlay
        jQuery('#' + this.id + '-overlay .jBox-closeButton').length && (this.options.adjustDistance.top = Math.max(jQuery('#' + this.id + '-overlay .jBox-closeButton').outerHeight(), this.options.adjustDistance.top));
      }

      // Abort if overlay is already visible
      if (this.overlay.css('display') == 'block') return;

      // Show overlay
      this.options.fade ? (this.overlay.stop() && this.overlay.animate({ opacity: 1 }, {
        queue: false,
        duration: this.options.fade,
        start: function () { this.overlay.css({ display: 'block' }); }.bind(this)
      })) : this.overlay.css({ display: 'block', opacity: 1 });
    };


    // Hide overlay

    this._hideOverlay = function () {
      // Abort if the overlay wasn't created yet
      if (!this.overlay) return;

      // Hide overlay if no other jBox needs it
      this.options.fade ? (this.overlay.stop() && this.overlay.animate({ opacity: 0 }, {
        queue: false,
        duration: this.options.fade,
        complete: function () { this.overlay.css({ display: 'none' }); }.bind(this)
      })) : this.overlay.css({ display: 'none', opacity: 0 });
    };


    // Get the correct jBox dimensions by moving jBox out of viewport

    this._exposeDimensions = function () {
      // Move wrapper out of viewport
      this.wrapper.css({
        top: -10000,
        left: -10000,
        right: 'auto',
        bottom: 'auto'
      });

      // Get jBox dimensions
      var jBoxDimensions = {
        x: this.wrapper.outerWidth(),
        y: this.wrapper.outerHeight()
      };

      // Reset position to viewport
      this.wrapper.css({
        top: 'auto',
        left: 'auto'
      });

      return jBoxDimensions;
    };


    // Generate CSS for animations and append to header

    this._generateAnimationCSS = function () {
      // Get open and close animations if none provided
      (jQuery.type(this.options.animation) != 'object') && (this.options.animation = {
        pulse: { open: 'pulse', close: 'zoomOut' },
        zoomIn: { open: 'zoomIn', close: 'zoomIn' },
        zoomOut: { open: 'zoomOut', close: 'zoomOut' },
        move: { open: 'move', close: 'move' },
        slide: { open: 'slide', close: 'slide' },
        flip: { open: 'flip', close: 'flip' },
        tada: { open: 'tada', close: 'zoomOut' }
      }[this.options.animation]);

      // Abort if animation not found
      if (!this.options.animation) return null;

      // Get direction var
      this.options.animation.open && (this.options.animation.open = this.options.animation.open.split(':'));
      this.options.animation.close && (this.options.animation.close = this.options.animation.close.split(':'));
      this.options.animation.openDirection = this.options.animation.open[1] ? this.options.animation.open[1] : null;
      this.options.animation.closeDirection = this.options.animation.close[1] ? this.options.animation.close[1] : null;
      this.options.animation.open && (this.options.animation.open = this.options.animation.open[0]);
      this.options.animation.close && (this.options.animation.close = this.options.animation.close[0]);

      // Add 'Open' and 'Close' to animation names
      this.options.animation.open && (this.options.animation.open += 'Open');
      this.options.animation.close && (this.options.animation.close += 'Close');

      // All animations
      var animations = {
        pulse: {
          duration: 350,
          css: [['0%', 'scale(1)'], ['50%', 'scale(1.1)'], ['100%', 'scale(1)']]
        },
        zoomInOpen: {
          duration: (this.options.fade || 180),
          css: [['0%', 'scale(0.9)'], ['100%', 'scale(1)']]
        },
        zoomInClose: {
          duration: (this.options.fade || 180),
          css: [['0%', 'scale(1)'], ['100%', 'scale(0.9)']]
        },
        zoomOutOpen: {
          duration: (this.options.fade || 180),
          css: [['0%', 'scale(1.1)'], ['100%', 'scale(1)']]
        },
        zoomOutClose: {
          duration: (this.options.fade || 180),
          css: [['0%', 'scale(1)'], ['100%', 'scale(1.1)']]
        },
        moveOpen: {
          duration: (this.options.fade || 180),
          positions: { top: { '0%': -12 }, right: { '0%': 12 }, bottom: { '0%': 12 }, left: { '0%': -12 } },
          css: [['0%', 'translate%XY(%Vpx)'], ['100%', 'translate%XY(0px)']]
        },
        moveClose: {
          duration: (this.options.fade || 180),
          timing: 'ease-in',
          positions: { top: { '100%': -12 }, right: { '100%': 12 }, bottom: { '100%': 12 }, left: { '100%': -12 } },
          css: [['0%', 'translate%XY(0px)'], ['100%', 'translate%XY(%Vpx)']]
        },
        slideOpen: {
          duration: 400,
          positions: { top: { '0%': -400 }, right: { '0%': 400 }, bottom: { '0%': 400 }, left: { '0%': -400 } },
          css: [['0%', 'translate%XY(%Vpx)'], ['100%', 'translate%XY(0px)']]
        },
        slideClose: {
          duration: 400,
          timing: 'ease-in',
          positions: { top: { '100%': -400 }, right: { '100%': 400 }, bottom: { '100%': 400 }, left: { '100%': -400 } },
          css: [['0%', 'translate%XY(0px)'], ['100%', 'translate%XY(%Vpx)']]
        },
        flipOpen: {
          duration: 600,
          css: [['0%', 'perspective(400px) rotateX(90deg)'], ['40%', 'perspective(400px) rotateX(-15deg)'], ['70%', 'perspective(400px) rotateX(15deg)'], ['100%', 'perspective(400px) rotateX(0deg)']]
        },
        flipClose: {
          duration: (this.options.fade || 300),
          css: [['0%', 'perspective(400px) rotateX(0deg)'], ['100%', 'perspective(400px) rotateX(90deg)']]
        },
        tada: {
          duration: 800,
          css: [['0%', 'scale(1)'], ['10%, 20%', 'scale(0.9) rotate(-3deg)'], ['30%, 50%, 70%, 90%', 'scale(1.1) rotate(3deg)'], ['40%, 60%, 80%', 'scale(1.1) rotate(-3deg)'], ['100%', 'scale(1) rotate(0)']]
        }
      };

      // Set Open and Close names for standalone animations
      jQuery.each(['pulse', 'tada'], function (index, item) { animations[item + 'Open'] = animations[item + 'Close'] = animations[item]; });

      // Function to generate the CSS for the keyframes
      var generateKeyframeCSS = function (ev, position) {
        // Generate keyframes CSS
        keyframe_css = '@keyframes jBox-' + this.id + '-animation-' + this.options.animation[ev] + '-' + ev + (position ? '-' + position : '') + ' {';
        jQuery.each(animations[this.options.animation[ev]].css, function (index, item) {
          var translate = position ? item[1].replace('%XY', this._getXY(position).toUpperCase()) : item[1];
          animations[this.options.animation[ev]].positions && (translate = translate.replace('%V', animations[this.options.animation[ev]].positions[position][item[0]]));
          keyframe_css += item[0] + ' {transform:' + translate + ';}';
        }.bind(this));
        keyframe_css += '}';

        // Generate class CSS
        keyframe_css += '.jBox-' + this.id + '-animation-' + this.options.animation[ev] + '-' + ev + (position ? '-' + position : '') + ' {';
        keyframe_css += 'animation-duration: ' + animations[this.options.animation[ev]].duration + 'ms;';
        keyframe_css += 'animation-name: jBox-' + this.id + '-animation-' + this.options.animation[ev] + '-' + ev + (position ? '-' + position : '') + ';';
        keyframe_css += animations[this.options.animation[ev]].timing ? ('animation-timing-function: ' + animations[this.options.animation[ev]].timing + ';') : '';
        keyframe_css += '}';

        return keyframe_css;
      }.bind(this);

      // Generate css for each event and positions
      this._animationCSS = '';
      jQuery.each(['open', 'close'], function (index, ev) {
        // No CSS needed for closing with no fade
        if (!this.options.animation[ev] || !animations[this.options.animation[ev]] || (ev == 'close' && !this.options.fade)) return '';

        // Generate CSS
        animations[this.options.animation[ev]].positions ?
          jQuery.each(['top', 'right', 'bottom', 'left'], function (index2, position) { this._animationCSS += generateKeyframeCSS(ev, position); }.bind(this)) :
          this._animationCSS += generateKeyframeCSS(ev);
      }.bind(this));

    };


    // Add css for animations

    this.options.animation && this._generateAnimationCSS();


    // Block body clicks for 10ms to prevent extra event triggering

    this._blockBodyClick = function () {
      this.blockBodyClick = true;
      setTimeout(function () { this.blockBodyClick = false; }.bind(this), 10);
    };


    // Animations

    this._animate = function (ev) {
      // The event which triggers the animation
      !ev && (ev = this.isOpen ? 'open' : 'close');

      // Don't animate when closing with no fade duration
      if (!this.options.fade && ev == 'close') return null;

      // Get the current position, use opposite if jBox is flipped
      var animationDirection = (this.options.animation[ev + 'Direction'] || ((this.align != 'center') ? this.align : this.options.attributes.x));
      this.flipped && this._getXY(animationDirection) == (this._getXY(this.align)) && (animationDirection = this._getOpp(animationDirection));

      // Add event and position classes
      var classnames = 'jBox-' + this.id + '-animation-' + this.options.animation[ev] + '-' + ev + ' jBox-' + this.id + '-animation-' + this.options.animation[ev] + '-' + ev + '-' + animationDirection;
      this.wrapper.addClass(classnames);

      // Get duration of animation
      var animationDuration = parseFloat(this.wrapper.css('animation-duration')) * 1000;
      ev == 'close' && (animationDuration = Math.min(animationDuration, this.options.fade));

      // Remove animation classes when animation is finished
      setTimeout(function () { this.wrapper.removeClass(classnames); }.bind(this), animationDuration);
    };


    // Abort an animation

    this._abortAnimation = function () {
      // Remove all animation classes
      var classes = this.wrapper.attr('class').split(' ').filter(function (c) {
        return c.lastIndexOf('jBox-' + this.id + '-animation', 0) !== 0;
      }.bind(this));
      this.wrapper.attr('class', classes.join(' '));
    };


    // Adjust dimensions when browser is resized

    if (this.options.responsiveWidth || this.options.responsiveHeight) {
      // Responsive positioning overrides options adjustPosition and reposition
      // TODO: Only add this resize event when the other one from adjustPosition and reposition was not set
      jQuery(window).on('resize.responsivejBox-' + this.id, function (ev) { if (this.isOpen) { this.position(); } }.bind(this));
    }


    // Fix audio options

    jQuery.type(this.options.preloadAudio) === 'string' && (this.options.preloadAudio = [this.options.preloadAudio]);
    jQuery.type(this.options.audio) === 'string' && (this.options.audio = { open: this.options.audio });
    jQuery.type(this.options.volume) === 'number' && (this.options.volume = { open: this.options.volume, close: this.options.volume });

    if (this.options.preloadAudio === true && this.options.audio) {
      this.options.preloadAudio = [];
      jQuery.each(this.options.audio, function (index, url) {
        this.options.preloadAudio.push(url + '.mp3');
        this.options.preloadAudio.push(url + '.ogg');
      }.bind(this));
    }


    // Preload audio files

    this.options.preloadAudio.length && jQuery.each(this.options.preloadAudio, function (index, url) {
      var audio = new Audio();
      audio.src = url;
      audio.preload = 'auto';
    });


    // Fire onInit event
    if (this.options.followMouse) {
      jQuery(document).on('mousemove', function (ev) {
        this.mouse = { x: ev.pageX, y: ev.pageY };
      }.bind(this));
    }


    this._fireEvent('onInit');


    return this;
  };


  // Attach jBox to elements

  jBox.prototype.attach = function (elements, trigger) {
    // Get elements from options if none passed
    !elements && (elements = this.options.attach);

    // Convert selectors to jQuery objects
    jQuery.type(elements) == 'string' && (elements = jQuery(elements));

    // Get trigger event from options if not passed
    !trigger && (trigger = this.options.trigger);

    // Loop through elements and attach jBox
    elements && elements.length && jQuery.each(elements, function (index, el) {
      el = jQuery(el);

      // Only attach if the element wasn't attached to this jBox already
      if (!el.data('jBox-attached-' + this.id)) {

        // Remove title attribute and store content on element
        (this.options.getContent == 'title' && el.attr('title') != undefined) && el.data('jBox-getContent', el.attr('title')).removeAttr('title');

        // Add Element to collection
        this.attachedElements || (this.attachedElements = []);
        this.attachedElements.push(el[0]);

        // Add click or mouseenter event, click events can prevent default as well
        el.on(trigger + '.jBox-attach-' + this.id, function (ev) {
          // Clear timer
          this.timer && clearTimeout(this.timer);

          // Block opening when jbox is open and the source element is triggering
          if (trigger == 'mouseenter' && this.isOpen && this.source[0] == el[0]) return;

          // Only close jBox if you click the current target element, otherwise open at new target
          if (this.isOpen && this.source && this.source[0] != el[0]) var forceOpen = true;

          // Set new source element
          this.source = el;

          // Set new target
          !this.options.target && (this.target = el);

          // Prevent default action on click
          trigger == 'click' && this.options.preventDefault && ev.preventDefault();

          // Toggle or open jBox
          this[trigger == 'click' && !forceOpen ? 'toggle' : 'open']();

        }.bind(this));

        // Add close event for trigger event mouseenter
        (this.options.trigger == 'mouseenter') && el.on('mouseleave', function (ev) {
          // Abort if jBox wasn't created yet
          if (!this.wrapper) return null;

          // If we have set closeOnMouseleave, do not close jBox when leaving attached element and mouse is over jBox
          if (!this.options.closeOnMouseleave || !(ev.relatedTarget == this.wrapper[0] || jQuery(ev.relatedTarget).parents('#' + this.id).length)) this.close();
        }.bind(this));

        // Store 
        el.data('jBox-attached-' + this.id, trigger);

        // Fire onAttach event
        this._fireEvent('onAttach', el);
      }

    }.bind(this));

    return this;
  };


  // Detach jBox from elements

  jBox.prototype.detach = function (elements) {
    // Get elements from stores elements if none passed
    !elements && (elements = this.attachedElements || []);

    elements && elements.length && jQuery.each(elements, function (index, el) {
      el = jQuery(el);

      // Remove events
      if (el.data('jBox-attached-' + this.id)) {
        el.off(el.data('jBox-attached-' + this.id) + '.jBox-attach-' + this.id);
        el.data('jBox-attached-' + this.id, null);
      }
      // Remove element from collection
      this.attachedElements = jQuery.grep(this.attachedElements, function (value) {
        return value != el[0];
      });
    }.bind(this));

    return this;
  };


  // Set title

  jBox.prototype.setTitle = function (title, ignore_positioning) {
    // Abort if title to set
    if (title == null || title == undefined) return this;

    // Create jBox if it wasn't created already
    !this.wrapper && this._create();

    // Get the width and height of wrapper, only if they change we need to reposition
    var wrapperHeight = this.wrapper.outerHeight();
    var wrapperWidth = this.wrapper.outerWidth();

    // Create title elements if they weren't created already
    if (!this.title) {
      this.titleContainer = jQuery('<div class="jBox-title"/>');
      this.title = jQuery('<div/>').appendTo(this.titleContainer);
      this.wrapper.addClass('jBox-hasTitle');
      if (this.options.closeButton == 'title' || (this.options.closeButton === true && !this.options.overlay)) {
        this.wrapper.addClass('jBox-closeButton-title');
        this.closeButton.appendTo(this.titleContainer);
      }
      this.titleContainer.insertBefore(this.content);
      this._setTitleWidth();
    }
    this.title.html(title);

    // Adjust width of title
    wrapperWidth != this.wrapper.outerWidth() && this._setTitleWidth();

    // Make jBox draggable
    this.options.draggable && this._draggable();

    // Reposition if dimensions changed
    !ignore_positioning && this.options.repositionOnContent && (wrapperHeight != this.wrapper.outerHeight() || wrapperWidth != this.wrapper.outerWidth()) && this.position();

    return this;
  };


  // Set content

  jBox.prototype.setContent = function (content, ignore_positioning) {
    // Abort if no content to set
    if (content == null || content == undefined) return this;

    // Create jBox if it wasn't created already
    !this.wrapper && this._create();

    // Get the width and height of wrapper, only if they change we need to reposition
    var wrapperHeight = this.wrapper.outerHeight();
    var wrapperWidth = this.wrapper.outerWidth();

    // Move all appended containers to body
    this.content.children('[data-jbox-content-appended]').appendTo('body').css({ display: 'none' });

    // Set the new content
    switch (jQuery.type(content)) {
      case 'string': this.content.html(content); break;
      case 'object': this.content.html(''); content.attr('data-jbox-content-appended', 1).appendTo(this.content).css({ display: 'block' }); break;
    }

    // Adjust title width
    wrapperWidth != this.wrapper.outerWidth() && this._setTitleWidth();

    // Make jBox draggable
    this.options.draggable && this._draggable();

    // Reposition if dimensions changed
    !ignore_positioning && this.options.repositionOnContent && (wrapperHeight != this.wrapper.outerHeight() || wrapperWidth != this.wrapper.outerWidth()) && this.position();

    return this;
  };


  // Set jBox dimensions

  jBox.prototype.setDimensions = function (type, value, pos) {
    // Create jBox if it wasn't created already
    !this.wrapper && this._create();

    // Default value is 'auto'
    value == undefined && (value = 'auto');

    // Set CSS of content and title
    this.content.css(type, this._getInt(value));

    // Adjust title width
    type == 'width' && this._setTitleWidth();

    // Reposition by default
    (pos == undefined || pos) && this.position();
  };


  // Set jBox width or height

  jBox.prototype.setWidth = function (value, pos) { this.setDimensions('width', value, pos); };
  jBox.prototype.setHeight = function (value, pos) { this.setDimensions('height', value, pos); };


  // Position jBox

  jBox.prototype.position = function (options) {
    // Options are required
    !options && (options = {});

    // Combine passed options with jBox options
    options = jQuery.extend(true, this.options, options);

    // Get the target
    this.target = options.target || this.target || jQuery(window);

    // Make sure target is a jQuery element
    !(this.target instanceof jQuery || this.target == 'mouse') && (this.target = jQuery(this.target));

    // Abort if target is missing
    if (!this.target.length) return this;

    // Reset content css to get original dimensions
    this.content.css({
      width: this._getInt(options.width, 'width'),
      height: this._getInt(options.height, 'height'),
      minWidth: this._getInt(options.minWidth, 'width'),
      minHeight: this._getInt(options.minHeight, 'height'),
      maxWidth: this._getInt(options.maxWidth, 'width'),
      maxHeight: this._getInt(options.maxHeight, 'height'),
    });

    // Reset width of title
    this._setTitleWidth();

    // Get jBox dimensions
    var jBoxDimensions = this._exposeDimensions();

    // Check if target has fixed position, store in elements data
    this.target != 'mouse' && !this.target.data('jBox-' + this.id + '-fixed') && this.target.data('jBox-' + this.id + '-fixed', (this.target[0] != jQuery(window)[0] && (this.target.css('position') == 'fixed' || this.target.parents().filter(function () { return jQuery(this).css('position') == 'fixed'; }).length > 0)) ? 'fixed' : 'static');

    // Get the window dimensions
    var windowDimensions = {
      x: jQuery(window).outerWidth(),
      y: jQuery(window).outerHeight(),
      top: (options.fixed && this.target.data('jBox-' + this.id + '-fixed') ? 0 : jQuery(window).scrollTop()),
      left: (options.fixed && this.target.data('jBox-' + this.id + '-fixed') ? 0 : jQuery(window).scrollLeft())
    };
    windowDimensions.bottom = windowDimensions.top + windowDimensions.y;
    windowDimensions.right = windowDimensions.left + windowDimensions.x;

    // Get target offset
    try { var targetOffset = this.target.offset(); } catch (e) { var targetOffset = { top: 0, left: 0 }; };

    // When the target is fixed and jBox is fixed, remove scroll offset
    if (this.target != 'mouse' && this.target.data('jBox-' + this.id + '-fixed') == 'fixed' && options.fixed) {
      targetOffset.top = targetOffset.top - jQuery(window).scrollTop();
      targetOffset.left = targetOffset.left - jQuery(window).scrollLeft();
    }

    // Get target dimensions
    var targetDimensions = {
      x: this.target == 'mouse' ? 12 : this.target.outerWidth(),
      y: this.target == 'mouse' ? 20 : this.target.outerHeight(),
      top: this.target == 'mouse' && options.mouseTarget ? options.mouseTarget.top : (targetOffset ? targetOffset.top : 0),
      left: this.target == 'mouse' && options.mouseTarget ? options.mouseTarget.left : (targetOffset ? targetOffset.left : 0)
    };

    // Check if jBox is outside
    var outside = options.outside && !(options.position.x == 'center' && options.position.y == 'center');

    // Get the available space on all sides
    var availableSpace = {
      x: windowDimensions.x - options.adjustDistance.left - options.adjustDistance.right, // TODO: substract position.x when they are numbers
      y: windowDimensions.y - options.adjustDistance.top - options.adjustDistance.bottom, // TODO: substract position.x when they are numbers
      left: !outside ? 0 : (targetDimensions.left - jQuery(window).scrollLeft() - options.adjustDistance.left),
      right: !outside ? 0 : (windowDimensions.x - targetDimensions.left + jQuery(window).scrollLeft() - targetDimensions.x - options.adjustDistance.right),
      top: !outside ? 0 : (targetDimensions.top - jQuery(window).scrollTop() - this.options.adjustDistance.top),
      bottom: !outside ? 0 : (windowDimensions.y - targetDimensions.top + jQuery(window).scrollTop() - targetDimensions.y - options.adjustDistance.bottom),
    };

    // Get the default outside position, check if box will be flipped
    var jBoxOutsidePosition = {
      x: (options.outside == 'x' || options.outside == 'xy') && jQuery.type(options.position.x) != 'number' ? options.position.x : null,
      y: (options.outside == 'y' || options.outside == 'xy') && jQuery.type(options.position.y) != 'number' ? options.position.y : null
    };
    var flip = { x: false, y: false };
    (jBoxOutsidePosition.x && jBoxDimensions.x > availableSpace[jBoxOutsidePosition.x] && availableSpace[this._getOpp(jBoxOutsidePosition.x)] > availableSpace[jBoxOutsidePosition.x]) && (jBoxOutsidePosition.x = this._getOpp(jBoxOutsidePosition.x)) && (flip.x = true);
    (jBoxOutsidePosition.y && jBoxDimensions.y > availableSpace[jBoxOutsidePosition.y] && availableSpace[this._getOpp(jBoxOutsidePosition.y)] > availableSpace[jBoxOutsidePosition.y]) && (jBoxOutsidePosition.y = this._getOpp(jBoxOutsidePosition.y)) && (flip.y = true);

    // Adjust responsive dimensions
    if (options.responsiveWidth || options.responsiveHeight) {

      // Adjust width and height according to default outside position
      var adjustResponsiveWidth = function () {
        if (options.responsiveWidth && jBoxDimensions.x > availableSpace[jBoxOutsidePosition.x || 'x']) {
          var contentWidth = availableSpace[jBoxOutsidePosition.x || 'x'] - (this.pointer && outside && options.outside == 'x' ? this.pointer.dimensions.x : 0) - parseInt(this.container.css('border-left-width')) - parseInt(this.container.css('border-right-width'));
          this.content.css({
            width: contentWidth > this.options.responsiveMinWidth ? contentWidth : null,
            minWidth: contentWidth < parseInt(this.content.css('minWidth')) ? 0 : null
          });
          this._setTitleWidth();
        }
        jBoxDimensions = this._exposeDimensions();

      }.bind(this);
      options.responsiveWidth && adjustResponsiveWidth();

      // After adjusting width, check if jBox will be flipped for y
      options.responsiveWidth && !flip.y && (jBoxOutsidePosition.y && jBoxDimensions.y > availableSpace[jBoxOutsidePosition.y] && availableSpace[this._getOpp(jBoxOutsidePosition.y)] > availableSpace[jBoxOutsidePosition.y]) && (jBoxOutsidePosition.y = this._getOpp(jBoxOutsidePosition.y)) && (flip.y = true);

      // Adjust width and height according to default outside position
      var adjustResponsiveHeight = function () {
        if (options.responsiveHeight && jBoxDimensions.y > availableSpace[jBoxOutsidePosition.y || 'y']) {

          // Expose wrapper to get correct title height
          var exposeTitleFooterHeight = function () {
            if (!this.titleContainer && !this.footer) return 0;
            if (this.wrapper.css('display') == 'none') {
              this.wrapper.css('display', 'block');
              var height = (this.titleContainer ? this.titleContainer.outerHeight() : 0) + (this.footer ? this.footer.outerHeight() : 0);
              this.wrapper.css('display', 'none');
            } else {
              var height = (this.titleContainer ? this.titleContainer.outerHeight() : 0) + (this.footer ? this.footer.outerHeight() : 0);
            }
            return height || 0;
          }.bind(this);

          var contentHeight = availableSpace[jBoxOutsidePosition.y || 'y'] - (this.pointer && outside && options.outside == 'y' ? this.pointer.dimensions.y : 0) - exposeTitleFooterHeight() - parseInt(this.container.css('border-top-width')) - parseInt(this.container.css('border-bottom-width'));
          this.content.css({ height: contentHeight > this.options.responsiveMinHeight ? contentHeight : null });
          this._setTitleWidth();
        }
        jBoxDimensions = this._exposeDimensions();

      }.bind(this);
      options.responsiveHeight && adjustResponsiveHeight();

      // After adjusting height, check if jBox will be flipped for x
      options.responsiveHeight && !flip.x && (jBoxOutsidePosition.x && jBoxDimensions.x > availableSpace[jBoxOutsidePosition.x] && availableSpace[this._getOpp(jBoxOutsidePosition.x)] > availableSpace[jBoxOutsidePosition.x]) && (jBoxOutsidePosition.x = this._getOpp(jBoxOutsidePosition.x)) && (flip.x = true);

      // Adjust width and height if jBox will be flipped
      if (options.adjustPosition && options.adjustPosition != 'move') {
        flip.x && adjustResponsiveWidth();
        flip.y && adjustResponsiveHeight();
      }
    }

    // Store new positioning vars in local var
    var pos = {};

    // Calculate positions
    var setPosition = function (p) {
      // Set number positions
      if (jQuery.type(options.position[p]) == 'number') {
        pos[options.attributes[p]] = options.position[p];
        return;
      }

      // We have a target, so use 'left' or 'top' as attributes
      var a = options.attributes[p] = (p == 'x' ? 'left' : 'top');

      // Start at target position
      pos[a] = targetDimensions[a];

      // Set centered position
      if (options.position[p] == 'center') {

        if (options.followMouse) {
          pos[a] = Math.ceil(this.mouse[p] - jBoxDimensions[p] / 2);
        } else {
          pos[a] += Math.ceil((targetDimensions[p] - jBoxDimensions[p]) / 2);
        }

        // If the target is the window, adjust centered position depending on adjustDistance
        (this.target != 'mouse' && this.target[0] && this.target[0] == jQuery(window)[0]) && (pos[a] += (options.adjustDistance[a] - options.adjustDistance[this._getOpp(a)]) * 0.5);
        return;
      }

      if (options.followMouse) {
        pos[a] = this.mouse[p];

      } else {
        // Move inside
        (a != options.position[p]) && (pos[a] += targetDimensions[p] - jBoxDimensions[p]);

        // Move outside
        (options.outside == p || options.outside == 'xy') && (pos[a] += jBoxDimensions[p] * (a != options.position[p] ? 1 : -1));
      }

    }.bind(this);

    // Set position including offset
    setPosition('x');
    setPosition('y');

    // Adjust position depending on pointer align
    if (this.pointer && options.pointTo == 'target' && jQuery.type(options.position.x) != 'number' && jQuery.type(options.position.y) != 'number') {

      var adjustWrapper = 0;

      // Where is the pointer aligned? Add or substract accordingly
      switch (this.pointer.align) {
        case 'center':
          if (options.position[this._getOpp(options.outside)] != 'center') {
            adjustWrapper += (jBoxDimensions[this._getOpp(options.outside)] / 2);
          }
          break;
        default:
          switch (options.position[this._getOpp(options.outside)]) {
            case 'center':
              adjustWrapper += ((jBoxDimensions[this._getOpp(options.outside)] / 2) - (this.pointer.dimensions[this._getOpp(options.outside)] / 2)) * (this.pointer.align == this._getTL(this.pointer.align) ? 1 : -1);
              break;
            default:
              adjustWrapper += (this.pointer.align != options.position[this._getOpp(options.outside)]) ?

                // If pointer align is different to position align
                (this.dimensions[this._getOpp(options.outside)] * (jQuery.inArray(this.pointer.align, ['top', 'left']) !== -1 ? 1 : -1)) + ((this.pointer.dimensions[this._getOpp(options.outside)] / 2) * (jQuery.inArray(this.pointer.align, ['top', 'left']) !== -1 ? -1 : 1)) :

                // If pointer align is same as position align
                (this.pointer.dimensions[this._getOpp(options.outside)] / 2) * (jQuery.inArray(this.pointer.align, ['top', 'left']) !== -1 ? 1 : -1);
              break;
          }
          break;
      }

      adjustWrapper *= (options.position[this._getOpp(options.outside)] == this.pointer.alignAttribute ? -1 : 1);
      adjustWrapper += this.pointer.offset * (this.pointer.align == this._getOpp(this._getTL(this.pointer.align)) ? 1 : -1);

      pos[this._getTL(this._getOpp(this.pointer.xy))] += adjustWrapper;
    }

    // Add final offset
    pos[options.attributes.x] += options.offset.x;
    pos[options.attributes.y] += options.offset.y;

    // Set CSS
    this.wrapper.css(pos);

    // Adjust position
    if (options.adjustPosition) {

      // Reset cached pointer position
      if (this.positionAdjusted) {
        this.pointer && this.wrapper.css('padding', 0).css('padding-' + this._getOpp(this.outside), this.pointer.dimensions[this._getXY(this.outside)]).removeClass('jBox-pointerPosition-' + this._getOpp(this.pointer.position)).addClass('jBox-pointerPosition-' + this.pointer.position);
        this.pointer && this.pointer.element.attr('class', 'jBox-pointer jBox-pointer-' + this._getOpp(this.outside)).css(this.pointer.margin);
        this.positionAdjusted = false;
        this.flipped = false;
      }

      // Find out where the jBox is out of view area
      var outYT = (windowDimensions.top > pos.top - (options.adjustDistance.top || 0)),
        outXR = (windowDimensions.right < pos.left + jBoxDimensions.x + (options.adjustDistance.right || 0)),
        outYB = (windowDimensions.bottom < pos.top + jBoxDimensions.y + (options.adjustDistance.bottom || 0)),
        outXL = (windowDimensions.left > pos.left - (options.adjustDistance.left || 0)),
        outX = outXL ? 'left' : (outXR ? 'right' : null),
        outY = outYT ? 'top' : (outYB ? 'bottom' : null),
        out = outX || outY;

      // Only continue if jBox is out of view area
      if (out) {

        // Function to flip position
        var flipJBox = function (xy) {
          if (options.followMouse) {
            this.wrapper.css(this._getTL(xy), pos[this._getTL(xy)] + ((jBoxDimensions[this._getXY(xy)] + (options.offset[this._getXY(xy)] * (xy == 'top' || xy == 'left' ? -2 : 2))) * (xy == 'top' || xy == 'left' ? 1 : -1)));
          } else {
            this.wrapper.css(this._getTL(xy), pos[this._getTL(xy)] + ((jBoxDimensions[this._getXY(xy)] + (options.offset[this._getXY(xy)] * (xy == 'top' || xy == 'left' ? -2 : 2)) + targetDimensions[this._getXY(xy)]) * (xy == 'top' || xy == 'left' ? 1 : -1)));
          }

          this.pointer && this.wrapper.removeClass('jBox-pointerPosition-' + this.pointer.position).addClass('jBox-pointerPosition-' + this._getOpp(this.pointer.position)).css('padding', 0).css('padding-' + xy, this.pointer.dimensions[this._getXY(xy)]);
          this.pointer && this.pointer.element.attr('class', 'jBox-pointer jBox-pointer-' + xy);
          this.positionAdjusted = true;
          this.flipped = true;
        }.bind(this);

        // Flip jBox
        flip.x && flipJBox(this.options.position.x);
        flip.y && flipJBox(this.options.position.y);

        // Move jBox (only possible with pointer)
        var outMove = (this._getXY(this.outside) == 'x') ? outY : outX;

        if (this.pointer && options.pointTo == 'target' && options.adjustPosition != 'flip' && this._getXY(outMove) == this._getOpp(this._getXY(this.outside))) {

          // Get the maximum space we have availible to adjust
          if (this.pointer.align == 'center') {
            var spaceAvail = (jBoxDimensions[this._getXY(outMove)] / 2) - (this.pointer.dimensions[this._getOpp(this.pointer.xy)] / 2) - (parseInt(this.pointer.element.css('margin-' + this.pointer.alignAttribute)) * (outMove != this._getTL(outMove) ? -1 : 1));
          } else {
            var spaceAvail = (outMove == this.pointer.alignAttribute) ?
              parseInt(this.pointer.element.css('margin-' + this.pointer.alignAttribute)) :
              jBoxDimensions[this._getXY(outMove)] - parseInt(this.pointer.element.css('margin-' + this.pointer.alignAttribute)) - this.pointer.dimensions[this._getXY(outMove)];
          }

          // Get the overlapping space
          spaceDiff = (outMove == this._getTL(outMove)) ?
            windowDimensions[this._getTL(outMove)] - pos[this._getTL(outMove)] + options.adjustDistance[outMove] :
            (windowDimensions[this._getOpp(this._getTL(outMove))] - pos[this._getTL(outMove)] - options.adjustDistance[outMove] - jBoxDimensions[this._getXY(outMove)]) * -1;

          // Add overlapping space on left or top window edge
          if (outMove == this._getOpp(this._getTL(outMove)) && pos[this._getTL(outMove)] - spaceDiff < windowDimensions[this._getTL(outMove)] + options.adjustDistance[this._getTL(outMove)]) {
            spaceDiff -= windowDimensions[this._getTL(outMove)] + options.adjustDistance[this._getTL(outMove)] - (this.pos[this._getTL(outMove)] - spaceDiff);
          }

          // Only adjust the maximum availible
          spaceDiff = Math.min(spaceDiff, spaceAvail);

          // Move jBox
          if (spaceDiff <= spaceAvail && spaceDiff > 0) {
            this.pointer.element.css('margin-' + this.pointer.alignAttribute, parseInt(this.pointer.element.css('margin-' + this.pointer.alignAttribute)) - (spaceDiff * (outMove != this.pointer.alignAttribute ? -1 : 1)));
            this.wrapper.css(this._getTL(outMove), pos[this._getTL(outMove)] + (spaceDiff * (outMove != this._getTL(outMove) ? -1 : 1)));
            this.positionAdjusted = true;
          }
        }
      }
    }

    // Fire onPosition event
    this._fireEvent('onPosition');

    return this;
  };


  // Open jBox

  jBox.prototype.open = function (options) {
    // Create blank options if none passed
    !options && (options = {});

    // Abort if jBox was destroyed
    if (this.isDestroyed) return false;

    // Construct jBox if not already constructed
    !this.wrapper && this._create();

    // Add css to header if not added already
    !this._styles && (this._styles = jQuery('<style/>').append(this._animationCSS).appendTo(jQuery('head')));

    // Abort any opening or closing timer
    this.timer && clearTimeout(this.timer);

    // Block body click for 10ms, so jBox can open on attached elements while closeOnClick = 'body'
    this._blockBodyClick();

    // Block opening
    if (this.isDisabled) return this;

    // Opening function
    var open = function () {

      // Set title from source element
      this.source && this.options.getTitle && (this.source.attr(this.options.getTitle) && this.setTitle(this.source.attr(this.options.getTitle)), true);

      // Set content from source element
      this.source && this.options.getContent && (this.source.data('jBox-getContent') ? this.setContent(this.source.data('jBox-getContent'), true) : (this.source.attr(this.options.getContent) ? this.setContent(this.source.attr(this.options.getContent), true) : (this.options.getContent == 'html' ? this.setContent(this.source.html(), true) : null)));

      // Fire onOpen event
      this._fireEvent('onOpen');

      // Get content from ajax
      if ((this.options.ajax && (this.options.ajax.url || (this.source && this.source.attr(this.options.ajax.getURL))) && (!this.ajaxLoaded || this.options.ajax.reload)) || (options.ajax && (options.ajax.url || options.ajax.data))) {
        // Send the content from stored data if there is any, otherwise load new data
        (this.options.ajax.reload != 'strict' && this.source && this.source.data('jBox-ajax-data') && !(options.ajax && (options.ajax.url || options.ajax.data))) ? this.setContent(this.source.data('jBox-ajax-data')) : this.ajax((options.ajax || null), true);
      }

      // Set position
      (!this.positionedOnOpen || this.options.repositionOnOpen) && this.position(options) && (this.positionedOnOpen = true);

      // Abort closing
      this.isClosing && this._abortAnimation();

      // Open functions to call when jBox is closed
      if (!this.isOpen) {

        // jBox is open now
        this.isOpen = true;

        // Automatically close jBox after some time
        this.options.autoClose && (this.options.delayClose = this.options.autoClose) && this.close();

        // Attach events
        this._attachEvents();

        // Block scrolling
        this.options.blockScroll && jQuery('body').addClass('jBox-blockScroll-' + this.id);

        // Show overlay
        this.options.overlay && this._showOverlay();

        // Only animate if jBox is completely closed
        this.options.animation && !this.isClosing && this._animate('open');

        // Play audio file
        this.options.audio && this.options.audio.open && this.audio(this.options.audio.open, this.options.volume.open);

        // Fading animation or show immediately
        if (this.options.fade) {
          this.wrapper.stop().animate({ opacity: 1 }, {
            queue: false,
            duration: this.options.fade,
            start: function () {
              this.isOpening = true;
              this.wrapper.css({ display: 'block' });
            }.bind(this),
            always: function () {
              this.isOpening = false;

              // Delay positioning for ajax to prevent positioning during animation
              setTimeout(function () { this.positionOnFadeComplete && this.position() && (this.positionOnFadeComplete = false); }.bind(this), 10);
            }.bind(this)
          });
        } else {
          this.wrapper.css({ display: 'block', opacity: 1 });
          this.positionOnFadeComplete && this.position() && (this.positionOnFadeComplete = false);
        }
      }
    }.bind(this);

    // Open jBox
    this.options.delayOpen && !this.isOpen && !this.isClosing && !options.ignoreDelay ? (this.timer = setTimeout(open, this.options.delayOpen)) : open();

    return this;
  };


  // Close jBox

  jBox.prototype.close = function (options) {
    // Create blank options if none passed
    options || (options = {});

    // Abort if jBox was destroyed or is currently closing
    if (this.isDestroyed || this.isClosing) return false;

    // Abort opening
    this.timer && clearTimeout(this.timer);

    // Block body click for 10ms, so jBox can open on attached elements while closeOnClock = 'body' is true
    this._blockBodyClick();

    // Block closing
    if (this.isDisabled) return this;

    // Close function
    var close = function () {

      // Fire onClose event
      this._fireEvent('onClose');

      // Only close if jBox is open
      if (this.isOpen) {

        // jBox is not open anymore
        this.isOpen = false;

        // Detach events
        this._detachEvents();

        // Unblock scrolling
        this.options.blockScroll && jQuery('body').removeClass('jBox-blockScroll-' + this.id);

        // Hide overlay
        this.options.overlay && this._hideOverlay();

        // Only animate if jBox is compleately closed
        this.options.animation && !this.isOpening && this._animate('close');

        // Play audio file
        this.options.audio && this.options.audio.close && this.audio(this.options.audio.close, this.options.volume.close);

        // Fading animation or show immediately
        if (this.options.fade) {
          this.wrapper.stop().animate({ opacity: 0 }, {
            queue: false,
            duration: this.options.fade,
            start: function () {
              this.isClosing = true;
            }.bind(this),
            complete: function () {
              this.wrapper.css({ display: 'none' });
              this._fireEvent('onCloseComplete');
            }.bind(this),
            always: function () {
              this.isClosing = false;
            }.bind(this)
          });
        } else {
          this.wrapper.css({ display: 'none', opacity: 0 });
          this._fireEvent('onCloseComplete');
        }
      }
    }.bind(this);

    // Close jBox
    if (options.ignoreDelay) {
      close();
    } else if ((this.options.delayOnHover || this.options.showCountdown) && this.options.delayClose > 10) {
      var self = this;
      var remaining = this.options.delayClose;
      var prevFrame = Date.now();
      if (this.options.showCountdown && !this.inner) {
        var outer = jQuery('<div class="jBox-countdown"></div>');
        this.inner = jQuery('<div class="jBox-countdown_inner"></div>');
        outer.prepend(this.inner);
        jQuery('#' + this.id).append(outer);
      }
      this.countdown = function () {
        var dateNow = Date.now();
        if (!self.isHovered) {
          remaining -= dateNow - prevFrame;
        }
        prevFrame = dateNow;
        if (remaining > 0) {
          if (self.options.showCountdown) {
            self.inner.css('width', (remaining * 100 / self.options.delayClose) + '%');
          }
          window.requestAnimationFrame(self.countdown);
        } else {
          close();
        }
      };
      window.requestAnimationFrame(this.countdown);
    } else {
      this.timer = setTimeout(close, Math.max(this.options.delayClose, 10));
    }

    return this;
  };


  // Open or close jBox

  jBox.prototype.toggle = function (options) {
    this[this.isOpen ? 'close' : 'open'](options);
    return this;
  };


  // Block opening and closing

  jBox.prototype.disable = function () {
    this.isDisabled = true;
    return this;
  };


  // Unblock opening and closing

  jBox.prototype.enable = function () {
    this.isDisabled = false;
    return this;
  };


  // Hide jBox

  jBox.prototype.hide = function () {
    this.disable();
    this.wrapper && this.wrapper.css({ display: 'none' });
    return this;
  };


  // Show jBox

  jBox.prototype.show = function () {
    this.enable();
    this.wrapper && this.wrapper.css({ display: 'block' });
    return this;
  };


  // Get content from ajax

  jBox.prototype.ajax = function (options, opening) {
    options || (options = {});

    // Add data or url from source element if none set in options
    jQuery.each([['getData', 'data'], ['getURL', 'url']], function (index, item) {
      (this.options.ajax[item[0]] && !options[item[1]] && this.source && this.source.attr(this.options.ajax[item[0]]) != undefined) && (options[item[1]] = this.source.attr(this.options.ajax[item[0]]) || '');
    }.bind(this));

    // Clone the system options
    var sysOptions = jQuery.extend(true, {}, this.options.ajax);

    // Abort running ajax call
    this.ajaxRequest && this.ajaxRequest.abort();

    // Extract events
    var beforeSend = options.beforeSend || sysOptions.beforeSend || function () { };
    var complete = options.complete || sysOptions.complete || function () { };
    var success = options.success || sysOptions.success || function () { };
    var error = options.error || sysOptions.error || function () { };

    // Merge options
    var userOptions = jQuery.extend(true, sysOptions, options);

    // Set new beforeSend event
    userOptions.beforeSend = function () {
      // jBox is loading
      this.wrapper.addClass('jBox-loading');

      // Add loading spinner
      userOptions.spinner && (this.spinnerDelay = setTimeout(function () {
        // If there is a dela
        this.wrapper.addClass('jBox-loading-spinner');

        // Reposition jBox
        // TODO: Only reposition if dimensions change
        userOptions.spinnerReposition && (opening ? (this.positionOnFadeComplete = true) : this.position());

        // Add spinner to container
        this.spinner = jQuery(userOptions.spinner !== true ? userOptions.spinner : '<div class="jBox-spinner"></div>').appendTo(this.container);

        // Fix spinners position if there is a title
        this.titleContainer && this.spinner.css('position') == 'absolute' && this.spinner.css({ transform: 'translateY(' + (this.titleContainer.outerHeight() * 0.5) + 'px)' });

      }.bind(this), (this.content.html() == '' ? 0 : (userOptions.spinnerDelay || 0))));

      // Fire users beforeSend event
      (beforeSend.bind(this))();

    }.bind(this);

    // Set up new complete event
    userOptions.complete = function (response) {
      // Abort spinner timeout
      this.spinnerDelay && clearTimeout(this.spinnerDelay);

      // jBox finished loading
      this.wrapper.removeClass('jBox-loading jBox-loading-spinner jBox-loading-spinner-delay');

      // Remove spinner
      this.spinner && this.spinner.length && this.spinner.remove() && userOptions.spinnerReposition && (opening ? (this.positionOnFadeComplete = true) : this.position());

      // Store that ajax loading finished
      this.ajaxLoaded = true;

      // Fire users complete event
      (complete.bind(this))(response);

    }.bind(this);

    // Set up new success event
    userOptions.success = function (response) {
      // Set content
      userOptions.setContent && this.setContent(response, true) && (opening ? (this.positionOnFadeComplete = true) : this.position());

      // Store content in source element
      userOptions.setContent && this.source && this.source.data('jBox-ajax-data', response);

      // Fire users success event
      (success.bind(this))(response);

    }.bind(this);

    // Add error event
    userOptions.error = function (response) { (error.bind(this))(response); }.bind(this);

    // Send new ajax request
    this.ajaxRequest = jQuery.ajax(userOptions);

    return this;
  };


  // Play an audio file

  jBox.prototype.audio = function (url, volume) {
    // URL is required
    if (!url) return this;

    // Create intern audio object if it wasn't created already
    !jBox._audio && (jBox._audio = {});

    // Create an audio element specific to this audio file if it doesn't exist already
    if (!jBox._audio[url]) {
      var audio = jQuery('<audio/>');
      jQuery('<source/>', { src: url + '.mp3' }).appendTo(audio);
      jQuery('<source/>', { src: url + '.ogg' }).appendTo(audio);
      jBox._audio[url] = audio[0];
    }

    // Set volume
    jBox._audio[url].volume = Math.min(((volume != undefined ? volume : 100) / 100), 1);

    // Try to pause current audio
    try {
      jBox._audio[url].pause();
      jBox._audio[url].currentTime = 0;
    } catch (e) { }

    // Play audio
    jBox._audio[url].play();

    return this;
  };


  // Apply custom animations to jBox

  jBox._animationSpeeds = {
    'tada': 1000,
    'tadaSmall': 1000,
    'flash': 500,
    'shake': 400,
    'pulseUp': 250,
    'pulseDown': 250,
    'popIn': 250,
    'popOut': 250,
    'fadeIn': 200,
    'fadeOut': 200,
    'slideUp': 400,
    'slideRight': 400,
    'slideLeft': 400,
    'slideDown': 400
  };

  jBox.prototype.animate = function (animation, options) {
    // Options are required
    !options && (options = {});

    // Timout needs to be an object
    !this.animationTimeout && (this.animationTimeout = {});

    // Use jBox wrapper by default
    !options.element && (options.element = this.wrapper);

    // Give the element an unique id
    !options.element.data('jBox-animating-id') && options.element.data('jBox-animating-id', jBox._getUniqueElementID());

    // Abort if element is animating
    if (options.element.data('jBox-animating')) {
      options.element.removeClass(options.element.data('jBox-animating')).data('jBox-animating', null);
      this.animationTimeout[options.element.data('jBox-animating-id')] && clearTimeout(this.animationTimeout[options.element.data('jBox-animating-id')]);
    }

    // Animate the element
    options.element.addClass('jBox-animated-' + animation).data('jBox-animating', 'jBox-animated-' + animation);
    this.animationTimeout[options.element.data('jBox-animating-id')] = setTimeout((function () { options.element.removeClass(options.element.data('jBox-animating')).data('jBox-animating', null); options.complete && options.complete(); }), jBox._animationSpeeds[animation]);
  };


  // Destroy jBox and remove it from DOM

  jBox.prototype.destroy = function () {
    // Detach from attached elements
    this.detach();

    // If jBox is open, close without delay
    this.isOpen && this.close({ ignoreDelay: true });

    // Remove wrapper
    this.wrapper && this.wrapper.remove();

    // Remove overlay
    this.overlay && this.overlay.remove();

    // Remove styles
    this._styles && this._styles.remove();

    // Tell the jBox instance it is destroyed
    this.isDestroyed = true;

    return this;
  };


  // Get a unique ID for jBoxes

  jBox._getUniqueID = (function () {
    var i = 1;
    return function () { return i++; };
  }());


  // Get a unique ID for animating elements

  jBox._getUniqueElementID = (function () {
    var i = 1;
    return function () { return i++; };
  }());


  // Function to create jBox plugins

  jBox._pluginOptions = {};
  jBox.plugin = function (type, options) {
    jBox._pluginOptions[type] = options;
  };


  // Make jBox usable with jQuery selectors

  jQuery.fn.jBox = function (type, options) {
    // Variables type and object are required
    !type && (type = {});
    !options && (options = {});

    // Return a new instance of jBox with the selector as attached element
    return new jBox(type, jQuery.extend(options, {
      attach: this
    }));
  };

  return jBox;
}));
jQuery(document).ready(function () { new jBox.plugin("Confirm", { confirmButton: "Submit", cancelButton: "Cancel", confirm: null, cancel: null, closeOnConfirm: !0, target: window, addClass: "jBox-Modal", fixed: !0, attach: "[data-confirm]", getContent: "data-confirm", content: "Do you really want to do this?", minWidth: 360, maxWidth: 500, blockScroll: !0, closeOnEsc: !0, closeOnClick: !1, closeButton: !1, overlay: !0, animation: "zoomIn", preventDefault: !0, _onAttach: function (t) { if (!this.options.confirm) { var o = t.attr("onclick") ? t.attr("onclick") : t.attr("href") ? t.attr("target") ? 'window.open("' + t.attr("href") + '", "' + t.attr("target") + '");' : 'window.location.href = "' + t.attr("href") + '";' : ""; t.prop("onclick", null).data("jBox-Confirm-submit", o) } }, _onCreated: function () { this.footer = jQuery('<div class="jBox-Confirm-footer"/>'), jQuery('<div class="jBox-Confirm-button jBox-Confirm-button-cancel"/>').html(this.options.cancelButton).click(function () { this.options.cancel && this.options.cancel(), this.close() }.bind(this)).appendTo(this.footer), this.submitButton = jQuery('<div class="jBox-Confirm-button jBox-Confirm-button-submit"/>').html(this.options.confirmButton).appendTo(this.footer), this.footer.appendTo(this.container) }, _onOpen: function () { this.submitButton.off("click.jBox-Confirm" + this.id).on("click.jBox-Confirm" + this.id, function () { this.options.confirm ? this.options.confirm() : eval(this.source.data("jBox-Confirm-submit")), this.options.closeOnConfirm && this.close() }.bind(this)) } }) });
jQuery(document).ready(function () {
  new jBox.plugin("Image", {
    src: "href", gallery: "data-jbox-image", imageLabel: "title", imageFade: 360, imageSize: "contain", imageCounter: false, imageCounterSeparator: "/", target: window, attach: "[data-jbox-image]", fixed: true, blockScroll: true, closeOnEsc: true, closeOnClick: "button", closeButton: true, overlay: true, animation: "zoomIn", preventDefault: true, width: "100%", height: "100%", adjustDistance: { top: 40, right: 5, bottom: 40, left: 5 }, _onAttach: function (b) {
      this.images = this.images || {};
      if (b.data("jBox-image-gallery")) { return; } var a = b.attr(this.options.gallery) || "default"; !this.images[a] && (this.images[a] = []); this.images[a].push({ src: b.attr(this.options.src), label: (b.attr(this.options.imageLabel) || "") });
      this.options.imageLabel == "title" && b.removeAttr("title"); b.data("jBox-image-gallery", a); b.data("jBox-image-id", (this.images[a].length - 1));
    }, _onInit: function () {
      this.currentImage = {};
      this.imageZIndex = 1; var b = function (d, j, g, f, e, h, c) {
        if (jQuery("#jBox-image-" + d + "-" + j).length) { return; } var i = jQuery("<div/>", { id: "jBox-image-" + d + "-" + j, "class": "jBox-image-container" + (e ? " jBox-image-not-found" : "") + (!f && !g ? " jBox-image-" + d + "-current" : ""), "data-width": h, "data-height": c }).css({ backgroundImage: e ? "" : 'url("' + this.images[d][j].src + '")', backgroundSize: this.options.imageSize, opacity: (f ? 1 : 0), zIndex: (g ? 0 : this.imageZIndex++) }).appendTo(this.content);
        jQuery("<div/>", { id: "jBox-image-label-" + d + "-" + j, "class": "jBox-image-label" + (f ? " active" : "") }).html(this.images[d][j].label).click(function () {
          $(this).toggleClass("expanded");
        }).appendTo(this.imageLabel); !f && !g && i.animate({ opacity: 1 }, this.options.imageFade);
      }.bind(this); var a = function (c, d) {
        jQuery(".jBox-image-label.active").removeClass("active expanded");
        jQuery("#jBox-image-label-" + c + "-" + d).addClass("active");
      }; this.checkSize = function (c) {
        if ((this.content.width() <= c.data("width")) || (this.content.height() <= c.data("height"))) {
          c.css("backgroundSize", "contain");
        } else { c.css("backgroundSize", "auto"); }
      }; this.showImage = function (d) {
        if (d != "open") {
          var c = this.currentImage.gallery; var f = this.currentImage.id + (1 * (d == "prev") ? -1 : 1);
          f = f > (this.images[c].length - 1) ? 0 : (f < 0 ? (this.images[c].length - 1) : f);
        } else {
          var c = this.source.data("jBox-image-gallery"); var f = this.source.data("jBox-image-id");
          jQuery(".jBox-image-pointer-prev, .jBox-image-pointer-next").css({ display: (this.images[c].length > 1 ? "block" : "none") });
        } if (jQuery(".jBox-image-" + c + "-current").length) {
          jQuery(".jBox-image-" + c + "-current").removeClass("jBox-image-" + c + "-current").animate({ opacity: 0 }, (d == "open") ? 0 : this.options.imageFade);
        } this.currentImage = { gallery: c, id: f }; if (jQuery("#jBox-image-" + c + "-" + f).length) {
          jQuery("#jBox-image-" + c + "-" + f).addClass("jBox-image-" + c + "-current").css({ zIndex: this.imageZIndex++, opacity: 0 }).animate({ opacity: 1 }, (d == "open") ? 0 : this.options.imageFade);
          this.checkSize(jQuery("#jBox-image-" + c + "-" + f)); a(c, f);
        } else {
          this.wrapper.addClass("jBox-image-loading"); jQuery('<img src="' + this.images[c][f].src + '"/>').each(function () {
            var g = new Image();
            g.onload = function () {
              b(c, f, false, null, false, g.width, g.height); this.checkSize(jQuery("#jBox-image-" + c + "-" + f)); a(c, f); this.wrapper.removeClass("jBox-image-loading");
            }.bind(this); g.onerror = function () { b(c, f, false, null, true, g.width, g.height); a(c, f); this.wrapper.removeClass("jBox-image-loading"); }.bind(this); g.src = this.images[c][f].src;
          }.bind(this));
        } if (this.imageCounter) {
          if (this.images[c].length > 1) {
            this.wrapper.addClass("jBox-image-has-counter"); this.imageCounter.find(".jBox-image-counter-all").html(this.images[c].length);
            this.imageCounter.find(".jBox-image-counter-current").html(f + 1);
          } else { this.wrapper.removeClass("jBox-image-has-counter"); }
        } if (this.images[c].length > 1) {
          var e = f + 1;
          e = e > (this.images[c].length - 1) ? 0 : (e < 0 ? (this.images[c].length - 1) : e); (!jQuery("#jBox-image-" + c + "-" + e).length) && jQuery('<img src="' + this.images[c][e].src + '"/>').each(function () {
            var g = new Image();
            g.onload = function () { b(c, e, true, null, false, g.width, g.height); }.bind(this); g.onerror = function () { b(c, e, true, null, true, g.width, g.height); }.bind(this); g.src = this.images[c][e].src;
          }.bind(this));
        }
      };
    }, _onCreated: function () {
      this.imageLabel = jQuery("<div/>", { "class": "jBox-image-label-container" }).appendTo(this.wrapper); this.imageLabel.append(jQuery("<div/>", {
        "class": "jBox-image-pointer-prev", click: function () {
          this.showImage("prev");
        }.bind(this)
      })).append(jQuery("<div/>", { "class": "jBox-image-pointer-next", click: function () { this.showImage("next"); }.bind(this) })); if (this.options.imageCounter) {
        this.imageCounter = jQuery("<div/>", { "class": "jBox-image-counter-container" }).appendTo(this.wrapper);
        this.imageCounter.append(jQuery("<span/>", { "class": "jBox-image-counter-current" })).append(jQuery("<span/>").html(this.options.imageCounterSeparator)).append(jQuery("<span/>", { "class": "jBox-image-counter-all" }));
      }
    }, _onOpen: function () {
      jQuery(document).on("keyup.jBox-Image-" + this.id, function (a) {
        (a.keyCode == 37) && this.showImage("prev"); (a.keyCode == 39) && this.showImage("next");
      }.bind(this)); this.showImage("open");
    }, _onClose: function () { jQuery(document).off("keyup.jBox-Image-" + this.id); }, _onCloseComplete: function () {
      this.wrapper.find(".jBox-image-container").css("opacity", 0);
    }
  });
});
jQuery(document).ready(function () { new jBox.plugin("Notice", { color: null, stack: !0, stackSpacing: 10, autoClose: 6e3, attributes: { x: "right", y: "top" }, position: { x: 15, y: 15 }, responsivePositions: { 500: { x: 5, y: 5 }, 768: { x: 10, y: 10 } }, target: window, fixed: !0, animation: "zoomIn", closeOnClick: "box", zIndex: 12e3, _onInit: function () { this.defaultNoticePosition = jQuery.extend({}, this.options.position), this._adjustNoticePositon = function () { var t = jQuery(window), i = { x: t.width(), y: t.height() }; this.options.position = jQuery.extend({}, this.defaultNoticePosition), jQuery.each(this.options.responsivePositions, function (t, o) { if (i.x <= t) return this.options.position = o, !1 }.bind(this)), this.options.adjustDistance = { top: this.options.position.y, right: this.options.position.x, bottom: this.options.position.y, left: this.options.position.x } }, this.options.content instanceof jQuery && (this.options.content = this.options.content.clone().attr("id", "")), jQuery(window).on("resize.responsivejBoxNotice-" + this.id, function (t) { this.isOpen && this._adjustNoticePositon() }.bind(this)), this.open() }, _onCreated: function () { this.wrapper.addClass("jBox-Notice-color jBox-Notice-" + (this.options.color || "gray")), this.wrapper.data("jBox-Notice-position", this.options.attributes.x + "-" + this.options.attributes.y) }, _onOpen: function () { this._adjustNoticePositon(), jQuery.each(jQuery(".jBox-Notice"), function (t, i) { if (i = jQuery(i), i.attr("id") != this.id && i.data("jBox-Notice-position") == this.options.attributes.x + "-" + this.options.attributes.y) { if (!this.options.stack) return void i.data("jBox").close({ ignoreDelay: !0 }); var o = (i.data("jBoxNoticeMargin") ? parseInt(i.data("jBoxNoticeMargin")) : parseInt(i.css("margin-" + this.options.attributes.y))) + this.wrapper.outerHeight() + this.options.stackSpacing; i.data("jBoxNoticeMargin", o), i.css("margin-" + this.options.attributes.y, o) } }.bind(this)) }, _onCloseComplete: function () { this.destroy() } }) });
// основано на jBox
window.msgErrorBox = {

  alert: function (title, message) {
    var options = {
      animation: { open: 'flip', close: 'zoomIn' },
      position: {
        x: 16,
        y: 16
      },
      color: 'red',
      zIndex: 12000,
      width: 250
    };

    if (title) {
      options['title'] = title;
    } else {
      options['title'] = 'Ошибка!';
    }
    if (message) options['content'] = message;
    new jBox('Notice', options);
  }
};

window.msgNoticeBox = {
  alert: function (title, message) {
    var options = {
      animation: { open: 'flip', close: 'zoomIn' },
      position: {
        x: 16,
        y: 16
      },
      color: 'green',
      zIndex: 12000,
      width: 250
    };

    if (title) {
      options['title'] = title;
    } else {
      options['title'] = 'Внимание!';
    }
    if (message) options['content'] = message;
    new jBox('Notice', options);
  }
};
(function (a) {
  (jQuery.browser = jQuery.browser || {}).mobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
  jQuery.browser.mobile = jQuery.browser.mobile || a.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i);

})(navigator.userAgent || navigator.vendor || window.opera);


jQuery.cachedScript = function (url, options) {
  // Allow user to set any option except for dataType, cache, and url
  options = $.extend(options || {},
    {
      dataType: "script",
      cache: true,
      url: url
    });
  // Use $.ajax() since it is more flexible than $.getScript
  // Return the jqXHR object so we can chain callbacks
  return jQuery.ajax(options);
};



$(document).ready(function () {
  // Баннеры
  if (typeof (MutationObserver) != 'undefined') {
    var sContainer = '.content_plus_ad';
    var aLoadContainers = ['IFRAME', 'IMG'];
    var aResizeContainers = ['DIV'];

    var recalcBanners = function () {
      var nConiatnerHeight = $(sContainer).height();
      $('.sticky_block > div').each(function (i, e) {
        if ($(this).height() > 0) // sized
        {
          $(this).hide();
          if ($(sContainer).height() == nConiatnerHeight) {
            $(this).show();
            $(this).stick_in_parent({ parent: sContainer, spacer: '.sticky_block' });
          } else {
            $(this).show();
            $(this).trigger('sticky_kit:detach');
          }
        }
      });
      $(document.body).trigger('sticky_kit:recalc');

      // кастылечек для странных баннеров
      setTimeout(function () {
        $(document.body).trigger('sticky_kit:recalc');

      }, 500);
    };

    var bannerObserver = new MutationObserver(function (mutations) {
      var bRecalcBanners = false;
      for (var i = 0, j = mutations.length; i < j; i++) {
        if (mutations[i].type == 'childList') {
          if (mutations[i].addedNodes.length) {
            for (var k = 0, l = mutations[i].addedNodes.length; k < l; k++) {
              if (aLoadContainers.indexOf(mutations[i].addedNodes[k].nodeName) != -1) {
                mutations[i].addedNodes[k].addEventListener('load', recalcBanners, false);
              }

              if (aResizeContainers.indexOf(mutations[i].addedNodes[k].nodeName) != -1) {
                if (mutations[i].addedNodes[k].style.height && (mutations[i].addedNodes[k].style.height != 'auto')) bRecalcBanners = true;
                if (mutations[i].addedNodes[k].style.width && (mutations[i].addedNodes[k].style.width != 'auto')) bRecalcBanners = true;
              }
            }
          }

          if (mutations[i].removedNodes.length) {
            for (var k = 0, l = mutations[i].addedNodes.length; k < l; k++) {
              if (aLoadContainers.indexOf(mutations[i].addedNodes[k].nodeName) != -1) {
                mutations[i].addedNodes[k].removeEventListener('load', recalcBanners, false);
              }

              if (aResizeContainers.indexOf(mutations[i].addedNodes[k].nodeName) != -1) {
                bRecalcBanners = true;
              }
            }
          }
        }
      }

      if (bRecalcBanners) recalcBanners();
    });

    $('.sticky_block').wrapInner('<div/>');
    $('.sticky_block > div').each(function (i, e) {
      bannerObserver.observe(this, { childList: true, subtree: true });

    });

    $(window).on('resize', recalcBanners);

  } else {
    $('.sticky_block').wrapInner('<div/>');
    $('.sticky_block > div').stick_in_parent({ parent: '.content_plus_ad', spacer: '.sticky_block', recalc_every: 1 });
  }

  // кнопки "вверх\вниз
  $('#top, #bottom').css('position', 'fixed');

  $('a[href^="#top"]').on('click', function (e) {
    e.stopPropagation();
    $('body, html').animate({ scrollTop: 0 }, 1000);
    return false;
  });

  $('a[href^="#bottom"]').on('click', function (e) {
    e.stopPropagation();
    var offset = $('#bottom').offset().top - $('html').get(0).clientHeight - $('#bottom').height();
    $('body, html').animate({ scrollTop: offset }, 1000);
    return false;
  });



  // менюшки всякие
  var _window = $(window);
  $('.hidden_menu').on('click', function () {
    $(this).toggleClass('active');
    $('.company_bar').toggleClass('active');
  });

  $(window).on('scroll,resize', function () {
    var scrollTop = _window.scrollTop();

    if (scrollTop > 40 && _window.width() < 1025) {
      $('.hidden_menu').addClass('scrolled');
      $('.company_bar').addClass('scrolled');
    } else {
      $('.hidden_menu').removeClass('scrolled');
      $('.company_bar').removeClass('scrolled');
    }
  }).trigger('resize');

  $(document).on('mouseup', function (e) {
    var value = $('.company_bar, .hidden_menu');
    if (!$(value).is(e.target) && $(value).has(e.target).length === 0) {
      $('.hidden_menu').removeClass('active');
      $('.company_bar').removeClass('active');
    }

  }).on('click', '.mobile_search__toggle', function (e) {
    e.preventDefault();
    $(this).addClass('active');
    $(this).parent().addClass('active');
    $('.mobile_search__overlay').addClass('active');
    return false;
  }).on('click', '.mobile_search__toggle.active, .mobile_search__overlay', function (e) {
    e.preventDefault();
    $('.mobile_search').removeClass('active');
    $('.mobile_search__toggle').removeClass('active');
    $('.mobile_search__input').removeClass('active');
    $('.mobile_search__overlay').removeClass('active');
    return false;
  });

  $('.image_true').jBox('Tooltip', {
    maxWidth: '300px',
    position: {
      x: 'right',
      y: 'center'
    },
    outside: 'x'
  });

  function hideallDropdowns() {
    var aDropped = $('.drop-menu-main.dropped');
    if (aDropped.length) {
      aDropped.removeClass('dropped');
      aDropped.find('.drop-menu-main-sub').removeClass('showing');

      $('body').off('click', hideallDropdowns);
      return true;
    }
    return false;
  }

  $('body').on('click', '.drop-menu-main', function (e) {
    var t = $(this);
    if (!t.hasClass('dropped')) {
      e.preventDefault();
      hideallDropdowns();

      t.toggleClass('dropped');
      t.find('.drop-menu-main-sub').toggleClass('showing');

      e.stopPropagation();
      $('body').on('click', hideallDropdowns);
    }
  });

  function hideClickMenu(e) {
    $('.hamburger').removeClass('is-active');
    if (e.target.nodeName == 'A') {
      $('body').off('click', hideClickMenu);
      $('.clickmenu').hide();
      return;
    }

    var cm = $(e.target);
    if (!cm.hasClass('clickmenu') && !cm.hasClass('popupmenu')) cm = cm.parents('.clickmenu, .popupmenu');
    if (!cm.length) {
      $('body').off('click', hideClickMenu);
      $('.clickmenu').hide();
    }
  }

  $('.hamburger').on('click', function (e) {
    $(this).addClass('is-active');

    e.preventDefault();
    var menu = 'undermenu_more_main';
    var bOpened = ($('#' + menu).css('display') == 'block');

    $('.clickmenu').hide();
    if (!bOpened) {
      var menuitem = $('.hamburger');
      var offset = menuitem.offset();

      $('#' + menu).css({ 'left': offset.left + 'px', 'top': offset.top + menuitem.outerHeight() + 'px' });
      $('#' + menu).show();

      e.stopPropagation();
      $('body').on('click', hideClickMenu);
    }
  });

  if ($(window).width() < 700) {
    $('.flinks > div > span').on('click', function () {
      $('.flinks > div > a').hide();
      $(this).nextAll().slideToggle();
    });
  }

  $('.undermenu_more_main').on('mouseover', '.popupmenu', function (e) {
    var menuItem = $(e.target).parents('.submenu');
    if (!menuItem.hasClass('selected')) {
      menuItem.addClass('selected');
      var subMenu = $(e.target);
      if (!subMenu.hasClass('.popupmenu')) subMenu = subMenu.parents('.popupmenu');

      subMenu.on('mouseleave', function (e) {
        subMenu.off('mouseleave');
        menuItem.removeClass('selected');
      });
    }
  });



  // уменьшение картинок в пределы окна
  $('[data-type="article"]').each(function (i, el) {
    var aId = $(el).data('id');
    $(el).find('a.imgpreview').attr('data-jbox-image', 'gallery_article_' + aId);
  });

  $('[data-type="comment"]').each(function (i, el) {
    var cId = $(el).data('id');
    $(el).find('a.imgpreview').attr('data-jbox-image', 'gallery_comment_' + cId);
  });


  var widthOffset = 18 + 40;
  var heightOffset = 55 + 40;

  window.jbi = new jBox('Image');
  $(window).on('resize', function (e) {
    var jbiWidth = window.innerWidth - widthOffset;
    var jbiHeight = (window.innerWidth - widthOffset) / 1.5;
    if (jbiHeight > window.innerHeight) {
      jbiHeight = window.innerHeight - heightOffset;
      jbiWidth = jbiHeight * 1.5;
    }
    window.jbi.setWidth(jbiWidth);
    window.jbi.setHeight(jbiHeight);
  });
  $(window).trigger('resize');



  // сортируемые таблицы
  $('.sort-table').on('click', 'th', function () {
    var table = $(this).parents('table');
    var sortMode = !$(this).hasClass('asc');
    table.find('th').removeClass('active asc desc');
    $(this).addClass('active ' + (sortMode ? 'asc' : 'desc'));

    var col = table.find('th').index($(this));
    var trs = table.find('tr').get();
    var firstRow = trs.shift();
    var fCompareFunction = function (a, b) { };

    $.each(trs, function (i, row) {
      var value = $($(row).find('td').get(col)).text();
      if ($.trim(value)) {
        if (value.indexOf('%') !== -1) {
          fCompareFunction = function (a, b) {
            var a = parseFloat(a.replace('%', ''));
            var b = parseFloat(b.replace('%', ''));

            if (isNaN(a) || isNaN(b)) {
              if (isNaN(a) && !isNaN(b)) return sortMode ? -1 : 1;
              if (!isNaN(a) && isNaN(b)) return sortMode ? 1 : -1;
              return 0;

            } else {
              return sortMode ? a - b : b - a;
            }
          };
          return false;

        } else if (value.match(/^[-+]?\b[0-9]*\.?[0-9]+\b$/)) {
          fCompareFunction = function (a, b) {
            var a = parseFloat(a);
            var b = parseFloat(b);

            if (isNaN(a) || isNaN(b)) {
              if (isNaN(a) && !isNaN(b)) return sortMode ? -1 : 1;
              if (!isNaN(a) && isNaN(b)) return sortMode ? 1 : -1;
              return 0;

            } else {
              return sortMode ? a - b : b - a;
            }
          };
          return false;
        } else {
          fCompareFunction = function (a, b) {
            return sortMode ? a.localeCompare(b) : b.localeCompare(a);
          };
          return false;
        }
      }
    });

    trs.sort(function (a, b) {
      var at = $($(a).find('td').get(col)).text();
      var bt = $($(b).find('td').get(col)).text();
      return fCompareFunction(at, bt);
    });

    table.empty();
    table.append($(firstRow));

    $.each(trs, function (i, v) {
      $(v).appendTo(table);
    });
  });

  $('.sort-table.collapsed + #collapse_wrapper').find('#collapse').on('click', function () {
    var table = $(this).parents('#collapse_wrapper').prev('.sort-table');
    if (table.length) {
      table.toggleClass('collapsed');
      if (table.hasClass('collapsed')) {
        $(this).text('показать все ↓');
      } else {
        $(this).text('скрыть ↑');
      }
    }
  });


  // панель поиска
  if ($('.upbar_search').length) {
    var sServiceUrl = $('.upbar_search input[name="q"]').attr('autocompleter');
    $('.upbar_search input[name="q"]').autocomplete({
      containerClass: 'autocomplete-suggestions more_companies',
      serviceUrl: sServiceUrl,
      type: 'POST',
      dataType: 'json',
      paramName: 'value',
      params: { 'json': 1, 'forums': 1 },
      preventBadQueries: false,
      zIndex: 99999,
      transformResult: function (response) {
        return { suggestions: response['results'] };
      },

      beforeRender: function (container, suggestions) {
        $.each(suggestions, function (i, v) {
          if (('hilite' in v) && (v['hilite'])) {
            container.find('.autocomplete-suggestion[data-index="' + i + '"]').addClass('hilite');
          }
        });
      },
      onSelect: function (suggestion) {
        document.location = suggestion.data;
      }
    });
  }



  // блок последних сообщений
  var lastMessagesBlock = $('#forum_last_posts').first();
  if (lastMessagesBlock.length) {
    function lastMessagesBlockReloader() {
      window.setTimeout(function () {
        $.ajax({

          url: '/forum/ajax_forum_last_messages' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
          type: 'GET',
          data: { security_ls_key: LIVESTREET_SECURITY_KEY }

        }).then(function (result) {
          try {
            result = JSON.parse(result);
            if (result.js.bStateError) {
              msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
              return;
            }

          } catch (e) { }

          var block = $(result.js.sLastMessages);
          lastMessagesBlock.html(block.find('#forum_last_posts').html());
          lastMessagesBlockReloader();
        });

      }, 60000);
    }
    lastMessagesBlockReloader();
  }

  // ошибка исправлена
  (function ($) {
    if ($('#admin_new_bug').length) {
      $('#admin_new_bug').on('click', function () {
        JsHttpRequest.query('POST ' + aRouter.abuse + 'bug_clean_ajax/', { iBugId: $(this).attr('bug-id'), security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) {
          if (!result) {
            msgErrorBox.alert('Error', 'Please try again later');
          }

          if (result.bStateError) {
            msgErrorBox.alert(result.sMsgTitle, result.sMsg);
            if ('iNewBug' in result) {
              $('#admin_new_bug').attr('bug-id', result.iNewBug);
              $('.user_warned a').first().attr('href', aRouter['trading'] + 'smartlab-bugs/goto_comment_' + result.iNewComment + '/#comment' + result.iNewComment);
            }

          } else {
            document.location.reload();
          }
        }, true);

      });
    }

    if ($('#admin_new_spam').length) {
      $('#admin_new_spam').on('click', function () {
        JsHttpRequest.query('POST ' + aRouter.abuse + 'spam_clean_ajax/', { iAbuseId: $(this).attr('abuse-id'), security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) {
          if (!result) {
            msgErrorBox.alert('Error', 'Please try again later');
          }

          if (result.bStateError) {
            msgErrorBox.alert(result.sMsgTitle, result.sMsg);
            if ('iNewAbuse' in result) {
              $('#admin_new_spam').attr('abuse-id', result.iNewAbuse);

              setTimeout(function () {
                document.location.reload();

              }, 1000);
            }

          } else {
            document.location.reload();
          }
        }, true);

      });
    }

  })(jQuery);

});
;
(function ($) {
  $(document).ready(function ($) {
    $('body').on('click', '.blog_calendar', function () {
      if ($('.blog_dates').length) {
        $('.blog_dates').toggleClass('show');
      }
    });

    $('.input-daterange').datepicker({

      'toDisplay': 'dd.mm.yy',
      'toValue': 'yyyy-mm-dd'

    }).on('hide', function (e) { e.preventDefault(); });

    $('#my_blog_interval_form').on('submit', function (e) {
      e.preventDefault();

      var path = $('#my_blog_interval_form').attr('action');
      path += ($('#date_from').val()) ? $('#date_from').datepicker('getFormattedDate', 'yyyy-mm-dd') : '-';
      path += '/';

      if ($('#date_to').val()) {
        path += $('#date_to').datepicker('getFormattedDate', 'yyyy-mm-dd');
        path += '/';
      }

      location.replace(path);
      return false;
    });


    $('.place-btn').jBox('Tooltip', {
      maxWidth: '300px'
    });

  });

})(jQuery);
jQuery(document).ready(function ($) {

  // уменьшение картинок в пределы окна
  $('[data-type="article"]').each(function (i, el) {
    var aId = $(el).data('id');
    $(el).find('a.imgpreview').attr('data-jbox-image', 'gallery_article_' + aId);
  });

  $('[data-type="comment"]').each(function (i, el) {
    var cId = $(el).data('id');
    $(el).find('a.imgpreview').attr('data-jbox-image', 'gallery_comment_' + cId);
  });


  $('.topic').each(function (i, el) {
    var tId = $(el).attr('tid');
    $(el).find('a.imgpreview').attr('data-jbox-image', 'gallery_topic_' + tId);
  });

  $('.comment').each(function (i, el) {
    var cId = $(el).attr('id');
    if (typeof (cId) !== 'undefined') {
      var m = cId.match(/^comment_id_(\d+)$/);
      if (m !== null) {
        cId = m[1];
        $(el).find('a.imgpreview').attr('data-jbox-image', 'gallery_comment_' + cId);
      }
    }
  });


  if (!('jbi' in window)) {
    var widthOffset = 18 + 40;
    var heightOffset = 55 + 40;

    window.jbi = new jBox('Image');
    $(window).on('resize', function (e) {
      var jbiWidth = window.innerWidth - widthOffset;
      var jbiHeight = (window.innerWidth - widthOffset) / 1.5;
      if (jbiHeight > window.innerHeight) {
        jbiHeight = window.innerHeight - heightOffset;
        jbiWidth = jbiHeight * 1.5;
      }
      window.jbi.setWidth(jbiWidth);
      window.jbi.setHeight(jbiHeight);
    });
    $(window).trigger('resize');
  }

});
(function ($) {
  $(document).ready(function ($) {
    $('body').on('click', '.chat_more__btn', function (e) {
      e.preventDefault();

      var nBtn = $(this);
      if (nBtn.next('.chat_more__overlay').length) {
        nBtn.find('~ .chat_more__overlay').show();
        nBtn.find('~ .chat_more__list').fadeIn('fast');
        nBtn.addClass('menu_active');

        return;
      }

      var sTargetType = null;
      var iTargetId = null;

      if (nBtn.parents('.topic[tid]').length) {
        sTargetType = 'topic';
        iTargetId = nBtn.parents('.topic[tid]').attr('tid');

      } else if (nBtn.parents('.comment[cid]').length) {
        sTargetType = 'comment';
        iTargetId = nBtn.parents('.comment[cid]').attr('cid');
      }

      if (iTargetId !== null) {
        var data = { target_id: iTargetId, security_ls_key: LIVESTREET_SECURITY_KEY };
        if ((sTargetType == 'comment') && ((typeof (lsCmtTree) !== 'undefined') && ('IsChat' in lsCmtTree))) data['chat'] = 1;

        $.ajax({

          url: aRouter['topic'] + 'ajax_' + sTargetType + '_menu/',
          type: 'POST',
          data: data
        }).then(function (result) {
          if (!result.bStateError) {
            nBtn.data('loaded', true);
            nBtn.after($(result.sHtml));
            nBtn.find('~ .chat_more__overlay').show();
            nBtn.find('~ .chat_more__list').fadeIn('fast');
            nBtn.addClass('menu_active');
          } else {
            msgErrorBox.alert(result.sMsgTitle, result.sMsg);
          }
        });
      }
    }).on('click', '.chat_more__item a.blacklist', function (e) {
      var data = { idUser: $(this).attr('user'), action: 'ban', security_ls_key: LIVESTREET_SECURITY_KEY };
      var url = '/blacklist/ajax/';

      $.ajax({

        url: url + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
        type: 'POST',
        data: data
      }).then(function (result) {
        try {
          result = JSON.parse(result);
        } catch (e) {
          msgErrorBox.alert('Внимание!', 'Неизвестная ошибка');
          return;
        }

        if (result.js.bStateError) {
          return msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
        } else {
          if (result.js.sMsg) msgNoticeBox.alert(result.js.sMsgTitle, result.js.sMsg);
        }
      });

    }).on('click', '.chat_more__item a, .chat_more__overlay', function (e) {
      var nBtn = $(this).parents('.chat_more__wrapper').find('.chat_more__btn');
      nBtn.find('~ .chat_more__list').fadeOut('fast', function () {
        if (nBtn.data('loaded')) {
          $(this).remove();
          nBtn.find('~ .chat_more__overlay').remove();
          nBtn.removeClass('menu_active');
          nBtn.removeData('loaded');
        } else {
          nBtn.removeClass('menu_active');
          nBtn.find('~ .chat_more__list').fadeOut('fast');
          nBtn.find('~ .chat_more__overlay').hide();
        }
      });
    });
  });

})(jQuery);;
(function (a) {
  a(document).ready(function (e) {
    var b = {}; var g = 0; var d = null; var c = e('<div class="Whodidit"></div>'); e("body").append(c); function f(h, i) {
      c.empty();
      if (!i.data.length) { c.append("Нет данных"); } else {
        if (i.vote) {
          c.append("<div>Лайкнули: " + i.vote.count + " чел.</div>"); c.append("<div>Рейтинг: +" + i.vote.rating + "</div>");
          c.append('<hr style="margin: 4px 0 2px 0" />');
        } e.each(i.data, function (l, k) {
          c.append('<div class="' + ((k.direction > 0) ? "plus" : "minus") + '">' + k.name + "</div>");
        });
      } var j = e(h).offset(); c.css("left", j.left + e(h).outerWidth()); c.css("top", j.top + e(h).outerHeight()); c.show();
    } e("div.comments, div.topic, div.forum-top-buttons, .forum_cmts").on("mouseover", ".total a, #vote_article_counter, a.cm_mrk", function (h) {
      d = h.target;
      if (d.parentNode.getAttribute("title")) { d.parentNode.removeAttribute("title"); } g = setTimeout(function () {
        g = 0; var j = d.href.split("/"); var k = j[j.length - 2]; if (k in b) {
          f(d, b[k]);
        } else {
          var l = e(d).offset(); c.empty(); c.append("<div>Загрузка...</div>"); c.css("left", l.left + e(d).outerWidth()); c.css("top", l.top + e(d).outerHeight()); c.show();
          var i = d; JsHttpRequest.query("POST " + i.href.replace("comment", "comment_ajax").replace("topic", "topic_ajax").replace("article", "article_ajax") + "/?security_ls_key=" + LIVESTREET_SECURITY_KEY, {}, function (m, n) {
            if (i !== d) {
              return;
            } if (m && !m.bStateError) { b[k] = { data: m.data, vote: ("vote" in m) ? m.vote : null }; f(d, b[k]); } else { c.find("div").text("Ошибка!"); }
          });
        }
      }, 500);
    }).on("mouseout", ".total a, #vote_article_counter, a.cm_mrk", function (h) {
      d = null;
      if (g) { clearTimeout(g); g = 0; } c.hide();
    });
  });
})(jQuery);
jQuery(document).ready(function ($) {
  var vapidPublicKey = 'BNIp6VPnSvoSm96bH-tlXdCObG8EVcUzJV3yigtQ8FGb5OPX3LK6lg6S67JGugfNRxX77_qMLGiWNQYGEVCqdHk';
  var aErrors = {

    'error': 'Ошибка',
    'notify_denied': 'Уведомления запрещены в настройках браузера. Разрешите уведомления для сайта, чтобы получить возможность получать push-уведомления.',
    'notify_not_supported': 'Ваш браузер не поддерживает Push-уведомления. Попробуйте установить Google Chrome.',
    'notify_subscribe_problems': 'Не удалось подписаться на push-уведомления.',
    'notify_unsubscribe_problems': 'Возникла ошибка в процессе отписки от push-уведомлений.',
    'token_update_error': 'Не удалось обновить токен подписки.',
    'subscribe_status_error': 'Не удалось обновить статус подписки.'
  };

  var aSussess = {

    'success': 'Внимание!',
    'notify_subscribe_recovered': 'Подписки успешно восстановлены'
  };

  function updateSubscriptionInfo(subscription, bSubscribe, bMute) {
    bSubscribe = (bSubscribe == undefined) ? true : bSubscribe;
    bMute = (bMute == undefined) ? false : bMute;

    return new Promise(function (resolve, reject) {
      var sOldEndpoint = localStorage.getItem('sEndpoint');

      var sKey = subscription.getKey ? subscription.getKey('p256dh') : '';
      sKey = sKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(sKey))) : '';

      var sAuth = subscription.getKey ? subscription.getKey('auth') : '';
      sAuth = sAuth ? btoa(String.fromCharCode.apply(null, new Uint8Array(sAuth))) : '';

      var sEndpoint = subscription.endpoint;


      if ((sEndpoint !== sOldEndpoint) || !bSubscribe || !bMute) {
        $.ajax({
          url: '/pushes/ajax_webpush_subscribe/?JsHttpRequest=' + (new Date()).getTime() + '-xml', // ебаное гавно с JsHttpRequest
          type: 'POST',
          data: { sEndpoint: sEndpoint, sOldEndpoint: sOldEndpoint, sKey: sKey, sAuth: sAuth, bSubscribe: bSubscribe ? 1 : 0, security_ls_key: LIVESTREET_SECURITY_KEY }
        }).then(function (result) {
          try {
            result = JSON.parse(result);

          } catch (e) { result = null; }

          if (result == null) {
            if (!bMute) msgErrorBox.alert(aErrors['error'], aErrors['token_update_error']);
            return reject({ bError: true });
          }

          if (result.js.bStateError) {
            msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
            return reject({ bError: result.js.bStateError });
          } else {
            if (bSubscribe) {
              localStorage.setItem('sEndpoint', sEndpoint);
            } else {
              localStorage.removeItem('sEndpoint');
            }
            return resolve({ bError: result.js.bStateError });
          }
        }).catch(function (err) {
          return reject({ bError: true });
        });
      } else {
        resolve({ bError: false });
      }
    });
  };

  function updateSubscriptionToTarget(targetId, targetType, targetHow, bSubscribe) {
    return new Promise(function (resolve, reject) {
      $.ajax({
        url: '/pushes/ajax_update_subscribe2target/?JsHttpRequest=' + (new Date()).getTime() + '-xml', // ебаное гавно с JsHttpRequest
        type: 'POST',
        data: { targetId: targetId, targetType: targetType, targetHow: targetHow, bSubscribe: bSubscribe ? 1 : 0, security_ls_key: LIVESTREET_SECURITY_KEY }
      }).then(function (result) {
        try {
          result = JSON.parse(result);

        } catch (e) { result = null; }

        if (result == null) {
          msgErrorBox.alert(aErrors['error'], aErrors['subscribe_status_error']);
          return reject({ bError: true, targetId: targetId, targetType: targetType });
        }

        if (result.js.bStateError) {
          msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
          return reject({ bError: result.js.bStateError, targetId: targetId, targetType: targetType });
        } else {
          msgNoticeBox.alert(result.js.sMsgTitle, result.js.sMsg);
          return resolve({ bError: result.js.bStateError, targetId: targetId, targetType: targetType, bSubscribed: result.js.bSubscribed, bLastSubscription: result.js.bLastSubscription });
        }

      }).catch(function (err) {
        return reject({ bError: true, targetId: targetId, targetType: targetType });
      });
    });
  };

  function urlBase64ToUint8Array(base64String) {
    var padding = '='.repeat((4 - base64String.length % 4) % 4);
    var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
    var rawData = window.atob(base64);
    var outputArray = new Uint8Array(rawData.length);

    for (var i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  var btn = $('.push-notifies-subscribe');
  if ('serviceWorker' in navigator) navigator.serviceWorker.register('/sw.js?v1').then(function () {
    if (!('showNotification' in ServiceWorkerRegistration.prototype)) return;
    if (Notification.permission === 'denied') return;
    if (!('PushManager' in window)) return;

    navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
      serviceWorkerRegistration.pushManager.getSubscription().then(function (subscription) {
        $('.push-notifies-repair').removeClass('unsupported');
        if (btn.hasClass('unsupported')) btn.removeClass('unsupported');
        if (subscription) return updateSubscriptionInfo(subscription, true, true);

        var pt = $('head').find('meta[name="push-subscribes"]');
        if (pt.length && (pt.attr('content') == 'yes')) {
          serviceWorkerRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) }).then(function (subscription) {
            updateSubscriptionInfo(subscription, true, true);
          });
        }

      }).catch(function (err) { }); // subscribtion catch
    });
  }).catch(function (err) { }); // registration catch

  $('body').on('click', '.push-notifies-subscribe', function (e) {
    var btn = $(e.target);

    var targetId = btn.data('target-id');
    var targetType = btn.data('target-type');
    var targetHow = btn.data('target-how');

    if (btn.hasClass('unsupported')) {
      e.stopPropagation();
      msgErrorBox.alert(aErrors['error'], (Notification.permission === 'denied') ? aErrors['notify_denied'] : aErrors['notify_not_supported']);
      return false;
    }

    var bCheckbox = ((btn.get(0).nodeName == 'INPUT') && (btn.attr('type') == 'checkbox'));
    if (bCheckbox) e.preventDefault();

    var bSubscribed = (btn.hasClass('subscribed') || (bCheckbox && !btn.get(0).checked));
    if (bSubscribed) {
      updateSubscriptionToTarget(targetId, targetType, targetHow, false).then(function (params) {
        if (bCheckbox) btn.get(0).checked = false;
        btn.removeClass('subscribed');
        btn.trigger('subscribe', [params['bSubscribed']]);
      });

    } else {
      navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
        serviceWorkerRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) }).then(function (subscription) {
          updateSubscriptionInfo(subscription).then(function (params) {
            updateSubscriptionToTarget(targetId, targetType, targetHow, true).then(function (params) {
              if (bCheckbox) btn.get(0).checked = true;
              btn.addClass('subscribed');
              btn.trigger('subscribe', [params['bSubscribed']]);
            });
          });

        }).catch(function (e) {
          msgErrorBox.alert(aErrors['error'], (Notification.permission === 'denied') ? aErrors['notify_denied'] : aErrors['notify_subscribe_problems']);
        });
      });
    }
  }).on('click', '.push-notifies-repair', function (e) {
    if (btn.hasClass('unsupported')) {
      e.stopPropagation();
      msgErrorBox.alert(aErrors['error'], (Notification.permission === 'denied') ? aErrors['notify_denied'] : aErrors['notify_not_supported']);
      return false;
    }

    navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
      serviceWorkerRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) }).then(function (subscription) {
        updateSubscriptionInfo(subscription, true, false).then(function (params) {
          msgNoticeBox.alert(aSussess['success'], aSussess['notify_subscribe_recovered']);
        });
      });
    });

  });


});
(function ($) {
  $(document).ready(function ($) {
    if (typeof (CURRENT_USER_ID) === 'undefined') return;
    function userNetlenkaDialog(topicId, sDestination, title) {
      var untDialog = new jBox('Confirm',
        {
          id: 'user_netlenka_dialog',
          title: (sDestination == 'netlenka') ? 'Добавить в дерево блога пост:' : 'Добавить в Дерево Избранное пост',
          confirmButton: 'ОК',
          closeOnConfirm: false,
          cancelButton: 'Отмена',
          ajax:
          {
            url: '/my/' + CURRENT_USER_LOGIN + ((sDestination == 'netlenka') ? '/tree/ajax/' : '/tree/fav/ajax/'),
            data:
            {
              JsHttpRequest: (new Date()).getTime() + '-xml',
              action: 'dialog',
              topic: topicId,
              security_ls_key: LIVESTREET_SECURITY_KEY
            },
            reload: 'strict',
            setContent: false,
            success: function (response) {
              try {
                response = JSON.parse(response);
                if (response.js.bStateError) throw 'Error loading content';
                if (!('sDialogHtml' in response.js)) throw 'Error content';
                var nContent = $(response.js.sDialogHtml);
                nContent.find('#netlenka_dialog_tpl').removeAttr('id').show();
                nContent.find('#topic_title').text('"' + title + '"');
                nContent.find('#netlenka_categoryId').val(0);

                this.setContent(nContent);

              } catch (e) {
                this.setContent('<b style="color: #d33">' + e + '</b>');
              }
            },
            error: function () {
              this.setContent('<b style="color: #d33">Error loading content.</b>');
            }
          },

          confirm: function () {
            var dialog = $('#user_netlenka_dialog');
            var data = {
              action: 'new',
              type: 'record',
              source: topicId,
              destination: dialog.find('#netlenka_categoryId').val(),
              text: '',
              security_ls_key: LIVESTREET_SECURITY_KEY
            };

            JsHttpRequest.query('POST /my/' + CURRENT_USER_LOGIN + ((sDestination == 'netlenka') ? '/tree/ajax/' : '/tree/fav/ajax/') + '?security_ls_key=' + LIVESTREET_SECURITY_KEY, data, function (result, errors) {
              if (!result) {
                msgErrorBox.alert('Error', 'Please try again later');
              }

              if (result.bStateError) {
                msgErrorBox.alert(result.sMsgTitle, result.sMsg);
              } else {
                msgNoticeBox.alert(result.sMsgTitle, result.sMsg);
                untDialog.close();
              }
            }, true);
          },

          onCloseComplete: function () {
            this.destroy();
          },

        });
      untDialog.open();
    }

    window['user_netlenka'] = userNetlenkaDialog;

    var sFriendsTooltipHtml = '';
    new jBox('Tooltip', {

      attach: '#subscribe-sidebar-links',
      target: '#friends_menu_link',
      trigger: 'subscribed',
      maxWidth: '300px',
      closeButton: 'box',
      closeOnClick: 'overlay',
      position: {
        x: 'center',
        y: 'bottom'
      },
      outside: 'y',
      onOpen: function () {
        this.setContent(sFriendsTooltipHtml);
      }
    });


    $('body').on('click', '#subscribe-sidebar-links', function (e) {
      var nBtn = $(this);
      var sLogin = $(this).attr('login');
      var bSubscribed = parseInt($(this).attr('subscribed')) ? true : false;

      if (!bSubscribed) window.fz('track', 'subscribe blog-sidebar-button');

      JsHttpRequest.query('POST /friends/ajax_user_subscribe/', { login: sLogin, subscribe: !bSubscribed, security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) {
        if (!result) return;
        if (!result.bStateError) {
          // обновим кеш
          nBtn.attr('subscribed', result.bSubscribeState ? 1 : 0);
          if (result.bSubscribeState) {
            nBtn.text('Вы подписаны');

            sFriendsTooltipHtml = result.sMsg + '<br />Посмотреть список вашей подписки вы можете в <a href="/profile/' + CURRENT_USER_LOGIN + '/">своем профиле</a>';
            nBtn.trigger('subscribed');

          } else {
            nBtn.text('Подписаться на блог');
          }

          msgNoticeBox.alert(result.sMsgTitle, result.sMsg);
        } else {
          msgErrorBox.alert(result.sMsgTitle, result.sMsg);
        }
      }, true);
    });

  });

})(jQuery);
(function ($) {
  $(document).ready(function ($) {
    $('body').on('click', '.thisdayHide', function () {
      var block = $(this).parents('.topic.thisday');
      JsHttpRequest.query('POST /thisday/ajax/', { action: 'hide', security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) {
        if (!result) return;
        if (!result.bStateError) {
          msgNoticeBox.alert(result.sMsgTitle, result.sMsg);
          block.remove();
        } else {
          msgErrorBox.alert(result.sMsgTitle, result.sMsg);
        }
      }, true);
    });
  });

})(jQuery);

;
(function (a) {
  a(document).ready(function (c) {
    var b = c("#topic_ban_dialog"); function e(g, h) {
      var i = { "delete": "Удалить топик", offtopic: "Принять меры" }; i = (h in i) ? i[h] : "Что-то творим с топиком";
      var f = new jBox("Confirm", {
        id: "topicBanDialog", title: i, confirmButton: "ОК", cancelButton: "Отмена", content: b, confirm: function () {
          var j = this; var q = { topic_id: g, security_ls_key: LIVESTREET_SECURITY_KEY };
          var r = b.find('select[name="topic_action"]'); q.action = r.val(); var k = "nothing"; var p = b.find('input[name="additional_action"]'); p.each(function (t, s) {
            if (s.checked) {
              k = c(s).val();
            }
          }); if (k != "nothing") {
            var o = b.find('input[name="reason"]'); o.each(function (t, s) { if (s.checked) { q.reason = s.value; } }); var l = b.find('input[name="reason_value"]');
            if (l.length) { q.reason_value = l.val(); } if (k == "ban") {
              var n = b.find('input[name="time"]'); n.each(function (t, s) {
                if (n.length > 1) { if (s.checked) { q.time = s.value; } } else {
                  q.time = s.value;
                }
              }); var l = b.find('input[name="time_value"]'); l.each(function (t, s) { if (l.length > 1) { if (s.checked) { q.time_value = s.value; } } else { q.time_value = s.value; } });
            }
          } q.additional_action = k;
          JsHttpRequest.query("POST /topic/admin/" + q.topic_id + "/?security_ls_key=" + LIVESTREET_SECURITY_KEY, q, function (s, u) {
            if (!s) {
              msgErrorBox.alert("Error", "Please try again later");
            } if (s.bStateError) { msgErrorBox.alert(s.sMsgTitle, s.sMsg); } else {
              var t = c("#content").find(".topic"); if (q.action == "delete") {
                if (t.length > 1) {
                  t.each(function (v, w) {
                    if (c(w).attr("tid") == q.topic_id) {
                      w.parentNode.removeChild(w);
                    }
                  }); msgNoticeBox.alert(s.sMsgTitle, s.sMsg);
                } else {
                  if (document.location.href.toString() != s.sURL) { document.location.replace(s.sURL); } else {
                    document.location.reload();
                  }
                }
              } else {
                if (["offtopic", "signals", "copypaste", "news"].indexOf(q.action) !== -1) {
                  if (t.length > 1) { msgNoticeBox.alert(s.sMsgTitle, s.sMsg); } else {
                    if (document.location.href.toString() != s.sURL) {
                      document.location.replace(s.sURL);
                    } else { document.location.reload(); }
                  }
                } else { if (s.sMsg) { msgNoticeBox.alert(s.sMsgTitle, s.sMsg); } }
              }
            }
          }, true);
        }, onOpen: function () {
          var n = b.find('select[name="topic_action"]');
          if (n.find('option[value="' + h + '"]').length) { n.val(h); } var l = b.find('input[name="additional_action"]'); l.each(function (p, o) { o.checked = false; }); l[0].checked = true;
          var k = b.find('input[name="reason"]'); k.each(function (p, o) { o.checked = false; }); k[10].checked = true; var j = b.find('input[type="radio"][name="time_value"]');
          if (j.length) { j.each(function (p, o) { o.checked = false; }); j[0].checked = true; } else {
            var j = b.find('input[type="radio"][name="time"]'); if (j.length) {
              j.each(function (p, o) {
                o.checked = false;
              }); j[0].checked = true;
            }
          } b.on("click", function (t) {
            var o = "nothing"; var r = b.find('input[name="additional_action"]'); r.each(function (v, u) {
              if (u.checked) {
                o = c(u).val();
              }
            }); var s = ["radio", "text"]; b.find("fieldset.ban_reason input").each(function (u, v) { if (s.indexOf(c(v).attr("type")) != -1) { v.disabled = (o == "nothing"); } }); b.find("fieldset.ban_time input").each(function (u, v) {
              if (s.indexOf(c(v).attr("type")) != -1) {
                v.disabled = (o != "ban");
              }
            }); if (o != "nothing") {
              var q = b.find('input[name="reason"]'); q.each(function (v, u) {
                if (u.checked) {
                  var w = b.find('input[name="reason_value"]'); if (w.length) {
                    w[0].disabled = (u.value != "0");
                  }
                }
              }); if (o == "ban") {
                var p = b.find('input[name="time"]'); p.each(function (v, u) {
                  if (u.checked) {
                    var w = b.find('input[name="time_value"]'); if (w.length) {
                      w[0].disabled = (u.value != "limited");
                    }
                  }
                });
              }
            } if ((c(t.target).attr("name") == "additional_action") && (c(t.target).val() == "warn")) {
              b.find('fieldset.ban_reason input[value="0"]').each(function (u, v) {
                v.checked = true;
              });
            }
          }); b.click();
        }, onCloseComplete: function () { this.destroy(); }
      }); f.open();
    } var d = new RegExp("^/topic/(delete|offtopic)/(\\d+)/", "i"); c("#content").on("click", "a[href]", function (f) {
      if (m = c(this).attr("href").match(d)) {
        f.preventDefault();
        c.ajax({ url: aRouter.topic + "ajax_topic_ban_dialog/", type: "POST", data: { topic_id: parseInt(m[2]), security_ls_key: LIVESTREET_SECURITY_KEY } }).then(function (g) {
          if (!g.bStateError) {
            if (c("#topic_ban_dialog_tpl").length) {
              c("#topic_ban_dialog_tpl").remove();
            } c("body").append(c(g.sHtml)); b = c("#topic_ban_dialog"); e(parseInt(m[2]), m[1]);
          } else { msgErrorBox.alert(g.sMsgTitle, g.sMsg); }
        });
      }
    }); c("#content").find("a[href]").each(function (f, g) {
      $el = c(g);
      if ($el.attr("href").match(d)) { $el.removeAttr("onclick").attr("title", "Принять меры."); }
    });
  });
})(jQuery);
(function ($) { function fillTopicZen(iTopicId) { var d = $.Deferred(); var zen = {}; var images = {}; var zenDialog = new jBox("Confirm", { id: "topicZenDialog", title: "Добавление топика в ленту Yandex.ZEN", confirmButton: "ОК", cancelButton: "Отмена", content: '\t\t\t<label for="zen_title">Название в ленте:</label>\t\t\t<input type="text" name="title" id="zen_title" value="" />\t\t\t<label for="zen_description">Аннотация:</label>\t\t\t<textarea name="description" id="zen_description"></textarea>\t\t\t<div class="image">\t\t\t\t<div>\t\t\t\t\t<img src="" />\t\t\t\t</div>\t\t\t\t<label for="zen_image_upload">Загрузить:</label>\t\t\t\t<input type="file" />\t\t\t</div>\t\t\t<label class="clear"><input type="checkbox" name="ok" />отправить в ленту</label>\t\t\t', confirm: function () { var self = this; var dialog = $("#" + this.id); var data = { topicId: iTopicId, security_ls_key: LIVESTREET_SECURITY_KEY }; data["zen_title"] = dialog.find("#zen_title").val(); data["zen_annotation"] = dialog.find("#zen_description").val(); data["zen_image"] = dialog.find("img").attr("src"); if (typeof data["zen_image"] == "undefined") data["zen_image"] = null; data["zen_ok"] = dialog.find("input:checkbox").is(":checked") ? 1 : 0; zen["zen_ok"] = data["zen_ok"]; JsHttpRequest.query("POST /topic/ajax_fill_zen/", data, function (result, errors) { if (!result) { msgErrorBox.alert("Error", "Please try again later") } if (result.bStateError) { msgErrorBox.alert(result.sMsgTitle, result.sMsg) } else { msgNoticeBox.alert(result.sMsgTitle, result.sMsg) } }, true) }, onOpen: function (a) { var dialog = $("#" + this.id); dialog.find("#zen_title").val("zen_title" in zen ? zen.zen_title : ""); dialog.find("#zen_description").val("zen_annotation" in zen ? zen.zen_annotation : ""); dialog.find("input:checkbox").prop("checked", "zen_ok" in zen ? parseInt(zen.zen_ok) : false); dialog.find("img").attr("src", "zen_image" in zen ? zen.zen_image : images.length ? images[0] : null); if ("zen_image" in zen && images.indexOf(zen.zen_image) == -1) images.push(zen.zen_image); dialog.find("img").on("click", function (e) { var i = images.indexOf($(this).attr("src")); i++; if (i == images.length) i = 0; $(this).attr("src", images[i]) }); dialog.find("input:file").on("change", function (e) { if (this.files.length) { var aFile = this.files[0]; var formData = new FormData; formData.append("type_add", "preview"); formData.append("img_file", aFile); formData.append("preview_size", "large"); formData.append("security_ls_key", LIVESTREET_SECURITY_KEY); return $.ajax({ url: "/include/ajax/uploadImg.php?JsHttpRequest=" + (new Date).getTime() + "-form", type: "POST", contentType: false, processData: false, data: formData }).then(function (result) { try { result = result.match(/top\.JsHttpRequestGlobal\.dataReady\((.+)\)/); if (result != null) result = JSON.parse(result[1]) } catch (e) { result = null } if (result == null) { msgErrorBox.alert("Ошибка", "Серверу сплохело на загрузке фотографии."); return } if (result.js.bStateError) { msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg) } else { var m = result.js.sText.match(/<a\s+[^\>]*?href="([^\"]+)"/i); if (m) { var url = m[1]; if (url[0] == "/") url = document.location.origin + url; dialog.find("img").attr("src", url); if (images.indexOf(url) == -1) images.push(url) } } }) } }) }, onClose: function () { var dialog = $("#" + this.id); dialog.find("img").off("click") }, onCloseComplete: function () { d.resolve(zen.zen_ok); this.destroy() } }); JsHttpRequest.query("GET /topic/ajax_fill_zen/", { topicId: iTopicId, security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) { if (!result) { msgErrorBox.alert("Error", "Please try again later") } if (result.bStateError) { msgErrorBox.alert(result.sMsgTitle, result.sMsg) } else { zen = result.aZen; images = result.aImages; zenDialog.open() } }, true); return d } window["zen_dialog"] = fillTopicZen; $(document).ready(function ($) { new jBox("Tooltip", { id: "extraTagsPopover", trigger: "click", adjustDistance: { top: 55, right: 5, bottom: 5, left: 5 }, closeOnClick: "body", closeOnEsc: true, animation: "move", attach: $(".extraTagEditLink"), zIndex: 8e3, position: { x: "center", y: "bottom" }, outside: "y", onOpen: function () { var self = this; var tid = $(this.target).attr("tid"); JsHttpRequest.query("GET /topic/ajax_edit_extratags/", { topicId: tid, security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) { if (!result) return; if (!result.bStateError) { if ("aAvailableExtraTags" in result || "aAvailableForumTags" in result) { var html = ""; var bNeedHr = false; if ("aAvailableExtraTags" in result) { html += "<label>Экстра-теги для топика:</label>"; for (var i in result.aAvailableExtraTags) { html += '<label><input type="checkbox" name="extra_tags[' + i + ']" value="' + i + '" ' + ($.inArray(i, result.aTopicExtraTags) >= 0 ? "checked" : "") + "/>" + result.aAvailableExtraTags[i]["description"] + "</label>" } bNeedHr = true } if ("bAvailableSmm" in result) { if (bNeedHr) html += "<hr />"; bNeedHr = true; html += '<label><input type="checkbox" name="smm" value="1" ' + (parseInt(result.bAvailableSmm) ? "checked" : "") + "/><strong>SMM pipeline</strong></label>" } if ("bAvailableNews" in result) { if (bNeedHr) html += "<hr />"; bNeedHr = false; html += '<label style="display: inline"><input type="checkbox" name="news" value="1" ' + (parseInt(result.bAvailableNews) ? "checked" : "") + "/><strong>NEWS</strong></label>" } if ("bAvailableNewsRedString" in result) { if (bNeedHr) html += "<hr />"; bNeedHr = true; html += '<label style="display: inline; margin-left:15px;"><input type="checkbox" name="news_red_string" value="1" ' + (parseInt(result.bAvailableNewsRedString) ? "checked" : "") + "/><strong>⚡</strong></label>" } if ("bAvailableForumTags" in result && result.bAvailableForumTags) { if (bNeedHr) html += "<hr />"; html += "<label>Компании для топика:</label>"; if ("aAvailableForumTags" in result) { for (var i in result.aAvailableForumTags) { html += '<label><input type="checkbox" name="forum_tags[' + i + ']" value="' + i + '" checked />' + result.aAvailableForumTags[i]["title"] + "</label>" } } html += '<input type="text" id="forumTagAutocomplete" />' } html += '<div style="text-align: right; margin-top:1em">'; html += '<input id="extraTagEditSubmit" type="button" value="Применить"/>'; html += "</div>"; self.setContent(html); $("#forumTagAutocomplete").autocomplete({ serviceUrl: "/forum/ajax_forum_tags/", type: "POST", dataType: "json", paramName: "value", params: { json: 1 }, preventBadQueries: false, containerClass: "autocomplete-suggestions width-auto", transformResult: function (response) { return { suggestions: response } }, onSelect: function (suggestion) { $("#forumTagAutocomplete").before($('<label><input type="checkbox" name="forum_tags[' + suggestion.data + ']" value="' + suggestion.data + '" checked />' + suggestion.value + "</label>")); $("#forumTagAutocomplete").val("") } }); $("#extraTagEditSubmit").on("click", function (e) { var aTopicExtraTags = {}; $("#" + self.id).find('input:checkbox[name^="extra_tags"]').each(function (i, el) { if (el.checked) aTopicExtraTags[$(el).val()] = true }); var aTopicForumTags = {}; $("#" + self.id).find('input:checkbox[name^="forum_tags"]').each(function (i, el) { if (el.checked) aTopicForumTags[$(el).val()] = true }); var bSmm = $("#" + self.id).find('input:checkbox[name^="smm"]').is(":checked"); var bNews = $("#" + self.id).find('input:checkbox[name="news"]').is(":checked"); var bNewsRedString = $("#" + self.id).find('input:checkbox[name="news_red_string"]').is(":checked"); var topicNode = $("#content").find('.extraTagEditLink[tid="' + tid + '"]').parents(".topic"); JsHttpRequest.query("POST /topic/ajax_edit_extratags/", { topicId: tid, aTopicExtraTags: aTopicExtraTags, aTopicForumTags: aTopicForumTags, bNews: bNews, bNewsRedString: bNewsRedString, bSmm: bSmm, security_ls_key: LIVESTREET_SECURITY_KEY }, function (result, errors) { if (!result) return; if (!result.bStateError) { if ("aResultTags" in result) { if ($.isArray(result.aResultTags)) { if (topicNode.find(".admin_tags").length) { topicNode.find(".admin_tags .tag, .admin_tags .no_tag").remove(); topicNode.find(".admin_tags").append($('<div class="no_tag">Нет тегов</div>')) } if (topicNode.find(".tags").length) topicNode.find(".tags").empty() } else { var block = topicNode.find(".admin_tags"); if (block.length) { block.find(".tag").remove(); block.find(".no_tag").remove(); for (var i in result.aResultTags) { var newTag = $('<div class="tag"><a href="/tag/' + encodeURIComponent(i) + '/"></a> | <span class="edit" title="Заменить тег в посте">ред.</span> | <span class="delete" title="Удалить тег у поста">X</span></div>'); newTag.find("a").text(result.aResultTags[i]); block.append(newTag) } } else { if (topicNode.find(".tags").length) { var block = topicNode.find(".tags"); block.append($("<li>Ключевые слова: </li>")); var c = 0; for (var i in result.aResultTags) { c++ } var ct = 0; for (var i in result.aResultTags) { ct++; var html = '<li><a href="/tag/' + encodeURIComponent(i) + '/"></a>' + (c != ct ? ", " : "") + "</li>"; html.find("a").text(result.aResultTags[i]); block.append(html) } } } } } if ("aResultExtraTags" in result) { if ($.isArray(result.aResultExtraTags)) { topicNode.find(".ext_tags").remove() } else { var etd = topicNode.find(".ext_tags"); if (etd.length) { etd.empty() } else { etd = $('<ul class="ext_tags"></ul>'); etd.insertBefore(topicNode.find("> hr, > .tags, > .admin_tags").first()) } etd.append("<li>спецраздел: </li>"); var c = 0; for (var i in result.aResultExtraTags) { c++ } var ct = 0; for (var i in result.aResultExtraTags) { ct++; var html = '<li><a href="' + DIR_WEB_ROOT + "/" + result.aResultExtraTags[i].url + '/">' + result.aResultExtraTags[i].description + "</a>" + (c != ct ? ", " : "") + "</li>"; etd.append(html) } } } if ("aResultForumTags" in result) { if ($.isArray(result.aResultForumTags)) { topicNode.find(".forum_tags").remove() } else { var etd = topicNode.find(".forum_tags"); if (etd.length) { etd.empty() } else { etd = $('<ul class="forum_tags"></ul>'); etd.insertBefore(topicNode.find("> hr, > .tags").first()) } etd.append("<li>обсудить на форуме: </li>"); var c = 0; for (var i in result.aResultForumTags) { c++ } var ct = 0; for (var i in result.aResultForumTags) { ct++; var html = '<li><a href="' + result.aResultForumTags[i].url + '">' + result.aResultForumTags[i].title + "</a>" + (c != ct ? ", " : "") + "</li>"; etd.append(html) } } } msgNoticeBox.alert(result.sMsgTitle, result.sMsg) } else { msgErrorBox.alert(result.sMsgTitle, result.sMsg) } }, true); self.close({ ignoreDelay: true }) }) } } else { msgErrorBox.alert(result.sMsgTitle, result.sMsg) } }, true) }, onClose: function () { $("#extraTagEditSubmit").off("click") } }) }) })(jQuery);
(function ($) {
  function adminTagAction(topicId, action, sourceTag, destinationTag) {
    var d = $.Deferred();
    var data = { security_ls_key: LIVESTREET_SECURITY_KEY, topic_id: topicId, action: action, source: sourceTag };
    if (action == 'edit') data['destination'] = destinationTag;

    $.ajax({
      type: 'POST',
      url: '/topic/admin_tags/' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
      data: data
    }).then(function (result) {
      if (result.bStateError) {
        msgErrorBox.alert(result.sMsgTitle, result.sMsg);
        return d.reject(result.sMsg);
      } else {
        if (result.sMsg) msgNoticeBox.alert(result.sMsgTitle, result.sMsg);
      }

      d.resolve(result);
    });

    return d;
  }


  $(document).ready(function ($) {
    $('body').on('click', '.admin_tags .add, .admin_tags .delete, .admin_tags .edit, .admin_tags .empty', function (e) {
      var btn = $(this);
      var topicId = btn.parents('.topic').attr('tid');
      var action = null;
      if (btn.hasClass('add')) {
        action = 'add';
      } else if (btn.hasClass('delete')) {
        action = 'delete';
      } else if (btn.hasClass('edit')) {
        action = 'edit';
      } else if (btn.hasClass('empty')) {
        action = 'empty';
      }

      var sourceTag = null;
      if ((action != 'add') && (action != 'empty')) sourceTag = btn.parents('.tag').find('a').text();


      switch (action) {
        case 'edit':
          {
            (new jBox('Confirm',
              {
                content: '<label>Новый тег:</label><br /><input type="text" name="tag" value="" />',
                addClass: 'adminTagEdit',
                confirmButton: 'Изменить',
                cancelButton: 'Отмена',
                confirm: function () {
                  destinationTag = $('.adminTagEdit').find('input[name="tag"]').val();

                  adminTagAction(topicId, action, sourceTag, destinationTag).then(function (result) {
                    if ('bUpdated' in result) {
                      btn.parents('.tag').find('a').attr('href', '/tag/' + encodeURIComponent(destinationTag) + '/').text(destinationTag);
                    }
                  });
                },
                cancel: function () { },
                onOpen: function () {
                  destinationTag = $('.adminTagEdit').find('input[name="tag"]').val(sourceTag);

                  $('.adminTagEdit').find('input[name="tag"]').autocomplete({
                    serviceUrl: DIR_WEB_ROOT + '/include/ajax/tagAutocompleter.php?security_ls_key=' + LIVESTREET_SECURITY_KEY,
                    type: 'POST',
                    dataType: 'json',
                    paramName: 'value',
                    params: { 'json': 1 },
                    preventBadQueries: false,
                    zIndex: 99999,


                    transformResult: function (response) {
                      return { suggestions: response['results'] };
                    }
                  });
                },
                onCloseComplete: function () {
                  this.destroy();
                }
              })).open();
            break;
          }

        case 'add':
          {
            (new jBox('Confirm',
              {
                content: '<label>Новые теги:</label><br /><input type="text" name="tag" value="" />',
                addClass: 'adminTagAdd',
                confirmButton: 'Добавить',
                cancelButton: 'Отмена',
                confirm: function () {
                  sourceTag = $('.adminTagAdd').find('input[name="tag"]').val();

                  adminTagAction(topicId, action, sourceTag).then(function (result) {
                    if ('bAdded' in result) {
                      var block = btn.parents('.admin_tags');
                      block.find('.no_tag').remove();
                      var aTags = sourceTag.split(',');

                      for (var i = 0, j = aTags.length; i < j; i++) {
                        var sTag = $.trim(aTags[i]);
                        if (sTag) {
                          var bNeeded = true;
                          block.find('.tag a').each(function (i, v) {
                            if ($(v).text().toLowerCase() == sTag.toLowerCase()) {
                              bNeeded = false;
                              return false;
                            }
                          });

                          if (bNeeded) {
                            var newTag = $('<div class="tag"><a href="/tag/' + encodeURIComponent(sTag) + '/"></a> | <span class="edit" title="Заменить тег в посте">ред.</span> | <span class="delete" title="Удалить тег у поста">X</span></div>');
                            newTag.find('a').text(sTag);
                            block.append(newTag);
                          }
                        }
                      }
                    }
                  });
                },
                cancel: function () { },
                onOpen: function () {
                  $('.adminTagAdd').find('input[name="tag"]').autocomplete({
                    serviceUrl: DIR_WEB_ROOT + '/include/ajax/tagAutocompleter.php?security_ls_key=' + LIVESTREET_SECURITY_KEY,
                    type: 'POST',
                    dataType: 'json',
                    paramName: 'value',
                    params: { 'json': 1 },
                    preventBadQueries: false,
                    zIndex: 99999,
                    delimiter: ',',

                    transformResult: function (response) {
                      return { suggestions: response['results'] };
                    },

                    onSelect: function (suggestion) {
                      if ($(this).val()) $(this).val($(this).val() + ',');
                    }
                  });
                },

                onCloseComplete: function () {
                  this.destroy();
                }
              })).open();
            break;
          }

        case 'delete':
          {
            adminTagAction(topicId, action, sourceTag).then(function () {
              var block = btn.parents('.admin_tags');
              btn.parents('.tag').remove();

              if (!block.find('.tag').length) block.append($('<div class="no_tag">Нет тегов</div>'));
            });
            break;
          }

        case 'empty':
          {
            (new jBox('Confirm',
              {
                content: 'Удалить все теги у поста?',
                addClass: 'adminTagDelete',
                confirmButton: 'Удалить',
                cancelButton: 'Отмена',
                confirm: function () {
                  adminTagAction(topicId, action, sourceTag).then(function () {
                    var block = btn.parents('.admin_tags');
                    block.find('.tag, .no_tag').remove();
                    block.append($('<div class="no_tag">Нет тегов</div>'));
                  });
                },
                cancel: function () { },
                onCloseComplete: function () {
                  this.destroy();
                }
              })).open();
            break;
          }
      }
    });
  });

})(jQuery);
(function ($) {
  $(document).ready(function ($) {
    $('#content .text > blockquote').each(function () {
      $(this).has('blockquote').addClass('bq_many');
      $(this).has('blockquote').children('blockquote').hide();
    });

    $('#content .text blockquote.bq_many').click(function () {
      $(this).children('blockquote').toggle();
      $(this).children('blockquote').toggleClass('bq_many_collapsed');
    });

  });

})(jQuery);
jQuery(document).ready(function ($) {
  $('#all_date').datepicker().on('hide', function (e) {
    e.preventDefault();

  }).on('changeDate', function (e) {
    if (('date' in e) && (e.format(0, 'yyyy-mm-dd'))) {
      location.replace($(this).attr('route') + 'date/' + e.format(0, 'yyyy-mm-dd') + '/');
    } else {
      location.replace($(this).attr('route'));
    }
  });

  $('.refres_btn').on('click', function (e) {
    var button = $(this);
    button.toggleClass('enabled');

    var data = {};

    if (typeof (CURRENT_USER_ID) != 'undefined') {
      data['security_ls_key'] = LIVESTREET_SECURITY_KEY;
      data[button.attr('field')] = button.hasClass('enabled') ? 1 : 0;
    } else {
      // Гость
      if (localStorage) localStorage.setItem(button.attr('field'), button.hasClass('enabled') ? 1 : 0);
      return button.trigger('update');
    }

    $.ajax({

      url: '/settings/some_settings_ajax/' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
      type: 'POST',
      data: data

    }).then(function (result) {
      try {
        result = JSON.parse(result);
        if (result.js.bStateError) {
          msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
          return;
        } else {
          if ((button.attr('field') in result.js) && parseInt(result.js[button.attr('field')])) {
            button.addClass('enabled');
          } else {
            button.removeClass('enabled');
          }
          button.trigger('update');
        }
      } catch (e) { }
    });

  }).on('update', function (e) {
    var button = $(this);

    if ((typeof (CURRENT_USER_ID) == 'undefined') && localStorage) {
      if (parseInt(localStorage.getItem(button.attr('field')))) {
        button.addClass('enabled');
      } else {
        button.removeClass('enabled');
      }
    }

    if (button.data('timer')) {
      clearTimeout(button.data('timer'));
      button.removeData('timer');
    }

    if (button.hasClass('enabled')) {
      button.data('timer', setTimeout(function () {
        document.location.reload(true);

      }, 60000));
    }

  }).trigger('update');


  $('#disclosure-filters').on('click', 'span', function () {
    $(this).toggleClass('selected');

    var e = '';
    $(this).parents('.disclosureFilters').find('>.selected[act_code]').each(function (i, n) {
      if (e != '') e += '&';
      e += encodeURIComponent('act_code[]') + '=' + encodeURIComponent($(n).attr('act_code'));
    });

    var h = document.location.href.toString().replace(/\/page\d+/, '').replace(/\?.*/, '');
    if (e) h += '?' + e;

    location.replace(h);
  });

  $('#allblog-filters').on('click', 'span', function () {
    $(this).toggleClass('selected');

    var e = '';
    $(this).parents('.disclosureFilters').find('>.selected[extra_id]').each(function (i, n) {
      if (e != '') e += '&';
      e += encodeURIComponent('extra[]') + '=' + encodeURIComponent($(n).attr('extra_id'));
    });

    var h = document.location.href.toString().replace(/\/page\d+/, '').replace(/\?.*/, '');
    if (e) h += '?' + e;

    location.replace(h);
  });

});
var ls = ls || {};
ls.plugin = ls.plugin || {};

ls.plugin.autoopenid = (function ($) {

  var that = this;

  this.goServiceLogin = function (service) {
    var sBackUrl = window.location.href;

    $.each(document.cookie.split(';'), function (i, el) {
      var aCookie = $.trim(el).split('=');
      if (aCookie[0] == 'openidreferal') {
        sBackUrl = decodeURIComponent(aCookie[1]);
        return false;
      }
    });

    var data = { service: service, referal: sBackUrl };
    if (window.LIVESTREET_SECURITY_KEY) data['security_ls_key'] = LIVESTREET_SECURITY_KEY;

    $.ajax({

      url: DIR_WEB_ROOT + '/login/autoopenid/login-oauth' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
      type: 'POST',
      data: data

    }).then(function (result) {
      try {
        result = JSON.parse(result);
        if (!result.js.bStateError) {
          window.location.href = result.js.sUrl;

        } else {
          msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
        }

      } catch (e) {

        msgErrorBox.alert(null, 'Вход через ' + service + ' временно не работает.');
      }
    });
  };

  this.removeService = function (type, id) {
    var data = { type: type, id: id };
    if (window.LIVESTREET_SECURITY_KEY) data['security_ls_key'] = LIVESTREET_SECURITY_KEY;


    $.ajax({

      url: DIR_WEB_ROOT + '/login/autoopenid/service-remove' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
      type: 'POST',
      data: data

    }).then(function (result) {
      try {
        result = JSON.parse(result);
        if (!result.js.bStateError) {
          $('#autoopenid-service-connect-item-' + res.id).remove();

        } else {
          msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
        }

      } catch (e) {

        msgErrorBox.alert(null, 'Вход через ' + service + ' временно не работает.');
      }
    });
  };

  this.showFormData = function () {
    $('#aoid-form-mail').hide();
    $('#aoid-form-data').show();
    $('#aoid-toggle-data').addClass('active');
    $('#aoid-toggle-mail').removeClass('active');
  };

  this.showFormMail = function () {
    $('#aoid-form-mail').show();
    $('#aoid-form-data').hide();
    $('#aoid-toggle-data').removeClass('active');
    $('#aoid-toggle-mail').addClass('active');
  };

  this.toggleFieldMail = function () {
    $('#aoid-field-mail').toggle();
  };

  $(function () {
    $(document).on('click', '.js-autoopenid-auth', function (e) {
      that.goServiceLogin($(this).data('service'));
      return false;
    });
    $(document).on('click', '.js-autoopenid-remove', function (e) {
      that.removeService($(this).data('serviceType'), $(this).attr('data-service-id'));
      return false;
    });
  }.bind(this));

  return this;

}).call(ls.plugin.autoopenid || {}, jQuery);


jQuery(document).ready(function ($) {

  function hideProfileDropdown() {
    $('body').off('click', hideProfileDropdown);
    $('.profile .drop-menu-main').removeClass('dropped');
    $('.profile .drop-menu-main-sub').removeClass('showing');
  }
 // синхронизация открытия/закрытия выпадающих окон
  $('.profile .drop-menu-main').on('click', function (e) {
    var bShowing = $('.profile .drop-menu-main-sub').hasClass('showing');

    $('.profile .drop-menu-main').toggleClass('dropped');
    $('.profile .drop-menu-main-sub').toggleClass('showing');

    if (!bShowing) {
      setTimeout(function () {
        // чтобы клик прошел в другие хендлеры, но не попал сразу
        $('body').on('click', hideProfileDropdown);

      }, 1);
    } else {
      $('body').off('click', hideProfileDropdown);
    }
  });


  function setGlobalCounter(iCounter) {
    $('#notifies_link').find('.notify_round').text(iCounter);
    if (iCounter) {
      $('#notifies_link').removeClass('empty');
    } else {
      $('#notifies_link').addClass('empty');
    }
  };


  function clearTabCounter(sTab) {
    var d = $.Deferred();

    $.ajax({
      url: '/profile/ajaxnotifiesclear/',
      type: 'POST',
      data: { security_ls_key: LIVESTREET_SECURITY_KEY, tabs: [sTab] }
    }).then(function (response) {
      if (!response.bStateError) {
        d.resolve(response.iCounter);
      } else {
        d.reject(response.sMsgTitle, response.sMsg);
      }
    });

    return d;
  };

  var nPopup = new jBox('Tooltip',
    {
      id: 'notifiesPopover',
      trigger: 'click',
      adjustDistance: { top: 55, right: 5, bottom: 5, left: 5 },
      //		preventDefault: true,
      //		closeOnClick: 'body',
      attach: $('#notifies_link'),
      zIndex: 12000,
      position: {
        x: 'center',
        y: 'bottom'
      },
      outside: 'y',
      pointer: 'right:20',
      
      clearTab: [$('#notifies_link').attr('tab') ? $('#notifies_link').attr('tab') : 'blog'],
      ajax: {
        url: '/profile/ajaxnotifies/',
        data: {
          security_ls_key: LIVESTREET_SECURITY_KEY,
          tab: $('#notifies_link').attr('tab') ? $('#notifies_link').attr('tab') : 'blog'
        },
        reload: 'strict',
        setContent: false,
        success: function (response) {
          if (response.bStateError) {
            this.close();
            return msgErrorBox.alert(response.sMsgTitle, response.sMsg);
          }
          this.setContent(response.sHtml);

          var nTab = this.content.find('.notify_tab.notify_tab__active');
          if (nTab.length && nTab.find('.notify_count > span').text() != '0') {
            var sTab = nTab.attr('tab');

            clearTabCounter(sTab).then(function (iCounter) {
              nPopup.options.globalCounter = iCounter;
            });
          } else {
            nPopup.options.globalCounter = parseInt($('#notifies_link > .notify_round').text());
          }
        },
        error: function () {
          msgErrorBox.alert('Ошибка', 'Неизвестная ошибка!');
          this.close();
        }
      },

      onOpen: function () {
        var nContent = this.content;
        nContent.on('click', '.notify_tab', function () {
          var nTab = $(this);
          var sTab = nTab.attr('tab');

          var nTabs = nContent.find('.notify_tabs');
          if (nTabs.length) {
            var nActiveTab = nTabs.find('.notify_tab.notify_tab__active');
            if (nActiveTab.attr('tab') === nTab.attr('tab')) return;

            nActiveTab.removeClass('notify_tab__active').addClass('empty');
            setGlobalCounter(nPopup.options.globalCounter);

            nTab.addClass('notify_tab__active');
            nContent.find('.notify_content').hide();
            nContent.find('.notify_content[id="' + sTab + '"]').show();

            clearTabCounter(sTab).then(function (iCounter) {
              nPopup.options.globalCounter = iCounter;
            });
          }
        }).on('click', '.reply_section', function () {
          var sLink = $(this).attr('link');
          if (sLink) {
            nPopup.close();
            document.location.href = sLink;
          }
        }).on('click', 'a', function () {
          nPopup.close();
        });
      },

      onClose: function () {
        var nTab = this.content.find('.notify_tab.notify_tab__active');
        if (nTab.length) {
          clearTabCounter('all').then(function (iCounter) {
            nPopup.options.globalCounter = iCounter;
            setGlobalCounter(iCounter);
          });
        }
        this.content.off('click');
      }
    });

  // кастыль глюкала
  $('body').on('click', function (e) {
    if ($(e.target).parents('#notifies_link').length) return;
    if ($(e.target).parents('#notifiesPopover').length) return;
    if (nPopup.isOpen) nPopup.close();
  });
});


(function ($) {

  function switchTheme(sTheme) {
    $('head').find('link[rel="stylesheet"]').filter(function ($i) {
      return ($(this).attr('href').match(/^\/templates\/skin\/smart-lab-x3\/themes\//i) !== null);

    }).remove();

    if (sTheme != 'black') $('<link/>').attr({ 'rel': 'stylesheet', 'type': 'text/css', 'href': '/templates/skin/smart-lab-x3/themes/' + sTheme + '.css' }).appendTo($('head'));
  }


  if (typeof (CURRENT_USER_ID) == 'undefined') {
    var sTheme = 'black';
    if ((typeof (localStorage) !== 'undefined') && (localStorage.getItem('sCurrentTheme') !== null)) sTheme = (['black', 'fullblack', 'white'].indexOf(localStorage.getItem('sCurrentTheme')) != -1) ? localStorage.getItem('sCurrentTheme') : 'black';
    switchTheme(sTheme);
  }

  jQuery(document).ready(function ($) {
    $(document).on('click', '.toggle_fz', function (event) {
      event.preventDefault();
      var bActive = !$('body').hasClass('large_font') ? 1 : 0;

      if (typeof (CURRENT_USER_ID) != 'undefined') {
        var data = { security_ls_key: LIVESTREET_SECURITY_KEY, bPostsLargeFont: bActive };
        $.ajax({

          url: '/settings/some_settings_ajax/' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
          type: 'POST',
          data: data

        }).then(function (result) {
          try {
            result = JSON.parse(result);
            if (result.js.bStateError) {
              msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
              return;
            } else {
              if (('bPostsLargeFont' in result.js) && parseInt(result.js['bPostsLargeFont'])) {
                $('body').addClass('large_font');
              } else {
                $('body').removeClass('large_font');
              }
            }
          } catch (e) { }
        });

      } else {
        // Гость
        if (typeof (localStorage) != 'undefined') localStorage.setItem('bPostsLargeFont', bActive);
        if (bActive) {
          $('body').addClass('large_font');
        } else {
          $('body').removeClass('large_font');
        }
      }
      return false;
    });

    if (typeof (CURRENT_USER_ID) == 'undefined') {
      var bActive = true;
      if ((typeof (localStorage) !== 'undefined') && (localStorage.getItem('bPostsLargeFont') !== null)) bActive = parseInt(localStorage.getItem('bPostsLargeFont')) ? true : false;

      if (bActive) {
        $('body').addClass('large_font');
      } else {
        $('body').removeClass('large_font');
      }
    }

    $(document).on('click', '.theme_switch_btn a', function (e) {
      e.preventDefault();

      var sTheme = $(this).attr('theme');
      if (typeof (CURRENT_USER_ID) != 'undefined') {
        document.location.href = '/settings/theme/' + sTheme + '/';

      } else {
        // Гость
        if (typeof (localStorage) != 'undefined') localStorage.setItem('sCurrentTheme', sTheme);
        switchTheme(sTheme);
      }
      return false;
    });
  });


})(jQuery);
;

jQuery(document).ready(function ($) {
  // $('.flistlink').on('click', function(e)
  // {
  // 	var t = $(e.target);
  // 	var url =  '/profile/ajax' + t.attr('type') + 'list/';
  // 	var login = t.attr('user');

  // 	var c =	t.parents('tr').next('tr').find('.friends_w');
  // 	$.get(url, {'JsHttpRequest' : (new Date()).getTime(), 'login': login}, function(result, errors)
  // 	{
  // 		var res = result.match(/^JsHttpRequest\.dataReady\((.+)\)/);
  // 		if (res != null) res = JSON.parse(res[1]);

  // 		if (!res.js)
  // 		{
  // 			msgErrorBox.alert('Error','Please try again later');
  // 		}
  // 		if (res.js.bStateError)
  // 		{
  // 			msgErrorBox.alert(res.js.sMsgTitle,res.js.sMsg);
  // 		} else
  // 		{
  // 			c.empty();
  // 			$.each(res.js.aUsersList, function(i,a)
  // 			{
  // 				$('<a></a>').attr('href', '/profile/' + a.user_login + '/').text(a.user_profile_name).appendTo(c);
  // 			});

  // 			c.show();
  // 		}
  // 	});
  // 	t.remove();

  // });

  $('#plus100link').on('click', function (e) {
    var sLogin = $(e.target).attr('login');
    $.post('/profile/ajaxplus100/?JsHttpRequest=' + (new Date()).getTime() + '-xml', { 'sLogin': sLogin, security_ls_key: LIVESTREET_SECURITY_KEY }, function (result) {
      try {
        result = JSON.parse(result);
      } catch (e) {
        return msgErrorBox.alert('Error', 'Please try again later');
      }
      if (!result) msgErrorBox.alert('Error', 'Please try again later');
      if (!result.js.bStateError) {
        $('#rating_span').text(result.js.sNewRating);
        msgNoticeBox.alert(result.js.sMsgTitle, result.js.sMsg);
      } else {
        msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
      }
    });
  });

  $('#allowPostNowlink').on('click', function (e) {
    var sLogin = $(e.target).attr('login');
    $.post('/profile/ajaxallownewbie/?JsHttpRequest=' + (new Date()).getTime() + '-xml', { 'sLogin': sLogin, security_ls_key: LIVESTREET_SECURITY_KEY }, function (result) {
      try {
        result = JSON.parse(result);
      } catch (e) {
        return msgErrorBox.alert('Error', 'Please try again later');
      }
      if (!result) msgErrorBox.alert('Error', 'Please try again later');
      if (!result.js.bStateError) {
        msgNoticeBox.alert(result.js.sMsgTitle, result.js.sMsg);
      } else {
        msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
      }
    });
  });

  $('#books_help_link').jBox('Tooltip', {
    position: {
      x: 'right',
      y: 'bottom'
    },
    width: '300px'
  });

  $('.detail_status .item, .user_status a, .reputation_item').jBox('Tooltip', {
    width: '300px'
  });
});
;
(function (b) {
  var c = '<div class="profile_popup bg"><img src="#"><div>	<div class="profile_avatar">		<a href="#" title="Посмотреть профиль пользователя">			<img src="{$DIR_STATIC_SKIN}/images/avatar_100x100.jpg" />		</a>	</div>	<div class="profile_info">		<div><a id="user_link" href="#" title="Посмотреть профиль пользователя">Фамилия Имя</a></div>		<div><span id="user_work">Работаю работником на работе большой большой текст не помещается на 2 строки</span></div>		<div><a id="user_city" href="#">Город</a></div>		<div class="profile_rating">			<div><a href="#" id="blog_link">Читать блог</a><span class="bsp">&nbsp</span><a href="#" id="forum_link">Читать форум</a></div>			<div>Подписчиков: <span id="user_subscribers">8888</span>, друзей: <span id="user_friends">55555</span></div>			<div>Рейтинг: <span id="user_rating">+881188</span>, сила: <span id="user_skill">55555323</span></div>			<div>Зарегистрирован: <span id="user_registred">22.22.2222</span></div>		</div>		<div class="profile_more">			<a><img src="/plugins/smartusers/templates/skin/default/img/more_vert-24px.svg" alt=""></a>			<div class="profile_more_menu">				<ul>					<li class="blacklist"><a>В черный список</a></li>				</ul>			</div>		</div>	</div>	<div class="profile_panel">		<div class="profile_panel__wrapper">			<div>				<input id="user_friend_btn" type="button" value="Дружить">				<svg class="user_add" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="20"><path d="M0 0h24v24H0z" fill="none"></path><path d="M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm-9-2V7H4v3H1v2h3v3h2v-3h3v-2H6zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"></path></svg>				<input id="user_subscribe_btn" type="button" value="Подписаться">			</div>			<div>				<button id="user_pm_btn" title="Отправить ЛС">					<svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="24"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg>				</button>			</div>		</div>	</div></div></div>';
  function a(f) {
    var d = b(c); if (f.background) { d.find("> img").attr("src", f.background); d.addClass("bg"); } else {
      d.find("> img").remove(); d.removeClass("bg");
    } d.find(".profile_avatar img").attr("src", f.avatar ? f.avatar : DIR_STATIC_SKIN + "/images/avatar_100x100.jpg"); d.find(".profile_avatar a").attr("href", f.profile);
    d.find("#user_link").attr("href", f.profile).text(f.name); if (f.work) { d.find("#user_work").text(f.work); } else {
      d.find("#user_work").parent("div").remove();
    } if (f.city) { d.find("#user_city").text(f.city).attr("href", aRouter.people + "city/" + f.city + "/"); } else { d.find("#user_city").parent("div").remove(); } d.find("#user_subscribers").text(f.readers);
    d.find("#user_friends").text(f.friends); d.find("#user_rating").text(Math.round(f.rating)); d.find("#user_skill").text(Math.round(f.skill)); d.find("#user_registred").text(f.registred);
    d.find("#blog_link").attr("href", f.blog_url); d.find("#forum_link").attr("href", f.forum_url); if (f.is_subscribed) {
      d.find("#user_subscribe_btn").addClass("active").val("Отписаться");
    } var e = d.find("#user_friend_btn"); if ((f.friendship == 1) && (f.is_friend)) { f.friendship = 2; } switch (f.friendship) {
      case 1: e.addClass("active").val("Заявка подана").attr("disabled", true);
        break; case 2: e.addClass("active").val("Удалить из друзей"); break; default: case 4: case 8: case 16: e.removeClass("active").val("Дружить"); break;
    }return d;
  } b(document).ready(function () {
    if (typeof (CURRENT_USER_ID) == "undefined") {
      return false;
    } var g = {}; c = c.replace("{$DIR_STATIC_SKIN}", DIR_STATIC_SKIN); var f = new RegExp("^/profile/([^\\/]+)/$", "i"); var d = new jBox("Tooltip", {
      id: "profilePopover", trigger: "mouseenter", adjustDistance: { top: 55, right: 5, bottom: 5, left: 5 }, delayOpen: 500, closeOnMouseleave: true, animation: "move", attach: b('a[href^="/profile/"]').filter(function (h) {
        if (this.hasAttribute("href")) {
          return ((b(this).attr("href").match(f) !== null) && (!b(this).parents(".drop-menu-main-sub").length));
        } return false;
      }), zIndex: 25000, position: { x: "center", y: "bottom" }, outside: "y", onOpen: function () {
        var i = this; var h = null; if (m = b(this.target).attr("href").match(f)) {
          h = m[1];
        } if (b(this.target).find("img").length) { this.target = b(this.target).find("img"); } var j = function (k) {
          this.setContent(a(k)); b("#user_pm_btn").on("click", function () {
            if (window.mailto_func && (typeof (window.mailto_func) == "function")) {
              window.mailto_func(h);
            } else { window.open("/talk/add/?talk_users=" + encodeURIComponent(h), "_blank"); } i.close({ ignoreDelay: true });
          }); b("#user_subscribe_btn").on("click", function () {
            if (!g[h]["is_subscribed"]) {
              window.fz("track", "subscribe mini-window-read");
            } JsHttpRequest.query("POST /friends/ajax_user_subscribe/", { login: h, subscribe: !(g[h]["is_subscribed"]), security_ls_key: LIVESTREET_SECURITY_KEY }, function (n, p) {
              if (!n) {
                return;
              } if (!n.bStateError) {
                if (h in g) { g[h]["is_subscribed"] = n.bSubscribeState; } var o = b("#user_subscribe_btn"); if (n.bSubscribeState) {
                  o.addClass("active").val("Отписаться");
                } else { o.removeClass("active").val("Подписаться"); } msgNoticeBox.alert(n.sMsgTitle, n.sMsg);
              } else { msgErrorBox.alert(n.sMsgTitle, n.sMsg); }
            }, true);
          }); b("#user_friend_btn").on("click", function () {
            switch (g[h].friendship) {
              case 1: case 2: JsHttpRequest.query("POST /profile/ajaxfrienddelete/", { idUser: g[h]["id"], sAction: "del", security_ls_key: LIVESTREET_SECURITY_KEY }, function (n, p) {
                if (!n) {
                  msgErrorBox.alert("Error", "Please try again later");
                } if (n.bStateError) { msgErrorBox.alert(n.sMsgTitle, n.sMsg); } else {
                  msgNoticeBox.alert(n.sMsgTitle, n.sMsg); var o = b("#user_friend_btn"); o.removeClass("active").val("Добавить в друзья");
                  g[h].friendship = 4; g[h].is_friend = false;
                }
              }, true); break; default: case 4: case 8: case 16: window.fz("track", "subscribe mini-window-addfriend"); JsHttpRequest.query("POST /profile/ajaxfriendadd/", { idUser: g[h]["id"], userText: "", security_ls_key: LIVESTREET_SECURITY_KEY }, function (n, p) {
                if (!n) {
                  msgErrorBox.alert("Error", "Please try again later");
                } if (n.bStateError) { msgErrorBox.alert(n.sMsgTitle, n.sMsg); } else {
                  msgNoticeBox.alert(n.sMsgTitle, n.sMsg); var o = b("#user_friend_btn"); if (g[h].friendship == 0) {
                    o.addClass("active").val("Заявка подана").attr("disabled", true);
                    g[h].friendship = 1; g[h].is_friend = false;
                  } else { o.addClass("active").val("Удалить из друзей"); g[h].friendship = 2; g[h].is_friend = true; }
                }
              }, true); break;
            }
          }); if ("ban" in window) {
            var l = b('<li class="ban"><a>Наказать</a></li>');
            if ("is_banned" in k) { l.attr("title", k.is_banned).addClass("banned"); } if ("is_warned" in k) { l.attr("title", k.is_warned).addClass("warned"); } b(".profile_more_menu").find("ul").append(l);
          } b(".profile_more a").on("click", function () { b(".profile_more_menu").slideToggle("fast"); }); b(".profile_more_menu").on("click", "li", function () {
            var q = b(this);
            if (q.hasClass("ban")) { i.close(); window.ban(k.login); } else {
              if (q.hasClass("blacklist")) {
                i.close(); var o = { idUser: k.id, action: "ban", security_ls_key: LIVESTREET_SECURITY_KEY };
                var p = "/blacklist/ajax/"; b.ajax({ url: p + "?JsHttpRequest=" + (new Date()).getTime() + "-xml", type: "POST", data: o }).then(function (n) {
                  try { n = JSON.parse(n); } catch (r) {
                    msgErrorBox.alert("Внимание!", "Неизвестная ошибка");
                    return;
                  } if (n.js.bStateError) { return msgErrorBox.alert(n.js.sMsgTitle, n.js.sMsg); } else { if (n.js.sMsg) { msgNoticeBox.alert(n.js.sMsgTitle, n.js.sMsg); } } setTimeout(function () {
                    document.location.reload();
                  }, 1000);
                });
              }
            }
          });
        }; if (!(h in g)) {
          JsHttpRequest.query("POST /profile/ajaxprofile/", { login: h, security_ls_key: LIVESTREET_SECURITY_KEY }, function (k, l) {
            if (!k) {
              return;
            } if (!k.bStateError) { k.aProfile.friendship = parseInt(k.aProfile.friendship); g[h] = k.aProfile; j.call(i, g[h]); }
          }, true);
        } else { j.call(this, g[h]); }
      }, onClose: function () {
        b("#user_pm_btn").off("click");
        b("#user_subscribe_btn").off("click"); b("#user_friend_btn").off("click"); b(".profile_more a").off("click");
      }, onCloseComplete: function () {
        b(".profile_popup").remove();
      }
    }); if (typeof (MutationObserver) === "function") {
      var e = new MutationObserver(function (i) {
        var h = []; b.each(i, function (k, j) {
          if (j.type == "childList") {
            b.each(j.addedNodes, function (o, n) {
              var l = b(n).find("a");
              h = b.merge(h, l);
            });
          }
        }); if (h.length) {
          h = h.filter(function (j) {
            if (j.hasAttribute("href") && (!b(j).parents("#profilePopover").length)) {
              return ((j.getAttribute("href").match(f) !== null) && (!b(j).parents(".drop-menu-main-sub").length));
            } return false;
          }); if (h.length) { d.attach(h); }
        }
      }); e.observe(b("body").get(0), { childList: true, subtree: true });
    }
  });
})(jQuery);
(function (c) {
  c(document).ready(function (d) {
    d("body").on("mousewheel", function (h) {
      var f = d(h.target); if (!(f.hasClass("pm_content") || f.parents(".pm_content").length)) {
        return;
      } var g = f.hasClass("pm_content") ? f.get(0) : f.parents(".pm_content").get(0); var i = h.originalEvent.deltaY || h.originalEvent.detail || h.originalEvent.wheelDelta;
      if (i < 0 && g.scrollTop == 0) { h.preventDefault(); } if (i > 0 && g.scrollHeight - g.clientHeight - g.scrollTop <= 1) { h.preventDefault(); }
    }); if (!d.browser.mobile && !window.ie && (typeof (localStorage) !== "undefined") && (typeof (CURRENT_USER_ID) !== "undefined")) {
      if (!("console" in window)) {
        window.console = { log: function () { } };
      } d(window).smartMessanger({ apiUrl: aRouter.talk + "messanger", checkUrl: "/talks", urlAppendParams: { security_ls_key: LIVESTREET_SECURITY_KEY, version: (typeof (SMART_MESSANGER_VERSION) !== "undefined") ? SMART_MESSANGER_VERSION : "2.5" }, userId: CURRENT_USER_ID, sound: (typeof (SMART_MESSANGER_SOUND) !== "undefined") ? SMART_MESSANGER_SOUND : false, soundPath: "/plugins/smartusers/templates/sound/bb2" });
      window.mailto_func = function (e) { d(window).smartMessanger("openTalkToUser", e); };
    }
  }); function a(g, f) {
    var i = this; this.options = c.extend({ handle: ".pm_header", flashInterval: 1000, splitNewMessages: 60000, scrollTimeout: 1000 }, g);
    this.users = f.users; this.thread = f.thread; this.draft = f.draft; var h = {
      blockScroll: false, animation: "tada", draggable: "title", closeButton: true, closeOnEsc: false, title: "Новая переписка", content: '<div class="pm_content"></div><div class="pm_footer"><textarea></textarea></div>', overlay: false, onOpen: function () {
        this.wrapper.addClass("pm_chat");
        this.titleContainer.addClass("pm_header").removeClass("jBox-title"); this.title.addClass("pm_title"); this.content.addClass("pm_wrapper");
      }
    }; if (!("newtalk" in g)) {
      h.animation = { open: false, close: "zoomOut" };
    } var d = new jBox("Modal", h); d.open(); this.node = d.wrapper.get(0); this.$node = d.wrapper; this.header = this.$node.find(this.options.handle); this.content = this.$node.find(".pm_content");
    this.textbox = this.$node.find(".pm_footer > textarea"); try { d.open({ ignoreDelay: true }); this.init(); } catch (j) { console.log(j); }
  } a.prototype = {
    init: function () {
      var d = this;
      this.$node.on("touchend click", ".jBox-closeButton", function (f) {
        f.preventDefault(); setTimeout(function () {
          d.sendMessage("closeTalk", d.options.talkId, true);
        }, 500);
      }); this.header.on("dblclick", function (f) {
        d.$node.toggleClass("collapsed"); if (!(d.$node.hasClass("collapsed"))) { d.flash(false); } d.saveWindowState();
      }); this.textbox.on("keydown", function (g) {
        if (g.keyCode == 13) {
          if (g.ctrlKey) {
            var h = this.value; if (typeof this.selectionStart == "number" && typeof this.selectionEnd == "number") {
              var i = this.selectionStart;
              this.value = h.slice(0, i) + "\n" + h.slice(this.selectionEnd); this.selectionStart = this.selectionEnd = i + 1;
            } else {
              if (document.selection && document.selection.createRange) {
                this.focus();
                var f = document.selection.createRange(); f.text = "\r\n"; f.collapse(false); f.select();
              }
            }
          } else {
            if (this.value) {
              d.sendMessage("appendDraft", { talkId: d.options.talkId, draftId: "draft_" + Math.round((Math.random() * 1000000)), text: this.value }, true);
              d.textbox.val("");
            }
          } return false;
        }
      }); this.content.on("scroll", function (h) {
        var g = h.target.scrollTop; var f = h.target.scrollTop + h.target.clientHeight; d.maxVisibleItem = 0;
        c("div[msgid]", d.content).each(function (j) {
          var k = this.getAttribute("msgid"); if (/^draft_/i.test(k)) { return; } var i = this.offsetTop + this.parentNode.offsetTop + this.parentNode.parentNode.offsetTop;
          var e = i + this.clientHeight; if ((i >= g) && (i < f)) { d.maxVisibleItem = Math.max(k, d.maxVisibleItem); } else {
            if ((e >= g) && (e < f)) {
              d.maxVisibleItem = Math.max(k, d.maxVisibleItem);
            } else { if ((i < g) && (e > f)) { d.maxVisibleItem = Math.max(k, d.maxVisibleItem); } }
          }
        }); if (d.scrollTimerId) { clearTimeout(d.scrollTimerId); d.scrollTimerId = 0; } d.scrollTimerId = setTimeout(function (i) {
          d.scrollTimerId = 0;
          if (d.thread.lastView < d.maxVisibleItem) { d.sendMessage("viewThread", { talkId: d.options.talkId, messageId: d.maxVisibleItem }, true); }
        }, d.options.scrollTimeout);
      }); this.$node.on("mousedown", function (f) { if (!c(f.target).hasClass("jBox-draggable")) { d.moveWindowToForeground(); } d.saveWindowState(); }).on("mouseup", function (f) {
        d.saveWindowState();
      }); this.loadWindowState(); this.restoreMessageState();
    }, resetup: function (d) {
      if (this.options.talkId != d) {
        try {
          pm = c.parseJSON(localStorage["pm.talks"]); if (this.options.talkId in pm) {
            delete pm[this.options.talkId];
          } localStorage["pm.talks"] = JSON.stringify(pm);
        } catch (f) { } this.options.talkId = d; this.saveWindowState();
      }
    }, halt: function (d) {
      if (this.scrollTimerId) {
        clearTimeout(this.scrollTimerId);
        this.scrollTimerId = 0;
      } this.flash(false); this.textbox.off("keydown"); this.textbox.get(0).disabled = true; this.textbox.val(d); this.textbox.css("color", "red");
      this.content.parents("div.pm_wrapper").css("opacity", 0.5);
    }, close: function () {
      if (this.scrollTimerId) {
        clearTimeout(this.scrollTimerId); this.scrollTimerId = 0;
      } this.flash(false); this.textbox.off("keydown"); delete this.textbox; this.header.off("dblclick"); delete this.header; this.$node.off("mousedown touchend click");
      c.removeData(this.$node, "smartMessangerWindow"); var d = this.$node.data("jBox"); if (d && d.isOpen) { d.close({ ignoreDelay: true }); } delete this.content; delete this.$node;
      delete this.node; delete this.users; delete this.thread;
    }, flash: function (d) {
      var e = this; if (this.flashIntervalId) {
        clearInterval(this.flashIntervalId); this.flashIntervalId = 0;
      } if (d) { if (this.$node.hasClass("collapsed")) { this.flashIntervalId = setInterval(function () { e.$node.toggleClass("hilite"); }, this.options.flashInterval); } } else {
        this.$node.removeClass("hilite");
      }
    }, collapsed: function (d) {
      if (d != undefined) {
        if (d) { this.$node.addClass("collapsed"); } else { this.$node.removeClass("collapsed"); this.flash(false); } this.saveWindowState();
      } else { return this.$node.hasClass("collapsed"); }
    }, focus: function () { this.textbox.focus(); }, moveWindowToForeground: function () {
      if (this.$node.css("zIndex") <= jBox.zIndexMax) {
        jBox.zIndexMax += 1;
        this.$node.css("zIndex", jBox.zIndexMax);
      }
    }, getWindowPlace: function (f) {
      var g = this; var h = c("html").get(0).clientWidth; var e = c("html").get(0).clientHeight - this.$node.height();
      c(".pm_chat").each(function (k, m) { var o = c(m); var j = parseInt(o.css("left")); if (!j) { return; } if (parseInt(o.css("top")) + o.height() > e) { h = Math.min(h, j); } }); var d = (h - this.$node.width() - 4);
      if (d < 0) { d = 0; } this.$node.css("left", d + "px"); this.$node.css("top", (e - 2) + "px"); this.$node.css("right", "auto"); this.$node.css("bottom", "auto"); this.$node.css("z-index", jBox.zIndexMax + 1);
    }, loadWindowState: function () {
      var h = false; var d = {}; var f = {}; if (!("pm.talks" in localStorage)) { localStorage["pm.talks"] = JSON.stringify({}); } try {
        f = c.parseJSON(localStorage["pm.talks"]);
        if (this.options.talkId in f) { d = f[this.options.talkId]; if (("left" in d) && (d.left != "auto") && ("top" in d) && (d.top != "auto")) { h = true; } }
      } catch (g) {
        console.log("Invalid pm.talks JSON while loading window state.");
      } this.$node.removeAttr("style"); if (!h) {
        this.getWindowPlace(f); d = { collapsed: false }; if (parseInt(this.$node.css("left")) < 0) { this.$node.css("left", "0px"); } d.left = this.$node.css("left");
        if (parseInt(this.$node.css("top")) < 0) { this.$node.css("top", "0px"); } d.top = this.$node.css("top"); d["z-index"] = this.$node.css("z-index"); f[this.options.talkId] = d;
        localStorage["pm.talks"] = JSON.stringify(f);
      } else {
        if ("z-index" in d) { this.$node.css("z-index", d["z-index"]); } if ("left" in d) {
          this.$node.css("left", d.left);
        } if ("top" in d) { this.$node.css("top", d.top); } if (("collapsed" in d) && (d.collapsed)) { this.$node.addClass("collapsed"); } else {
          this.$node.removeClass("collapsed");
          if ("width" in d) { this.$node.css("width", d.width); } if ("height" in d) { this.$node.find(".pm_content").css("height", d.height); }
        }
      } jBox.zIndexMax = Math.max(jBox.zIndexMax, d["z-index"]);
      var i = c(".pm_title", this.$node); if ("header" in this.thread) { i.text(this.thread.header).attr("title", this.thread.title); } else {
        i.text(this.thread.title).attr("title", this.thread.title);
      }
    }, saveWindowState: function () {
      var d = {}; var f = {}; try {
        f = ("pm.talks" in localStorage) ? c.parseJSON(localStorage["pm.talks"]) : {}; if (this.options.talkId in f) {
          d = f[this.options.talkId];
        }
      } catch (g) { console.log("Invalid pm.talks JSON while saving window state."); } if (parseInt(this.$node.css("left")) < 0) { this.$node.css("left", "0px"); } d.left = this.$node.css("left");
      if (parseInt(this.$node.css("top")) < 0) { this.$node.css("top", "0px"); } d.top = this.$node.css("top"); d["z-index"] = this.$node.css("z-index"); d.collapsed = this.$node.hasClass("collapsed");
      if (d.collapsed) { if ("width" in d) { delete d.width; } if ("height" in d) { delete d.height; } } else {
        d.width = this.$node.width() + "px"; d.height = this.$node.find(".pm_content").height() + "px";
      } f[this.options.talkId] = d; localStorage["pm.talks"] = JSON.stringify(f); this.sendMessage("refreshWindowState", this.options.talkId);
    }, clearWindowState: function () {
      try {
        var d = ("pm.talks" in localStorage) ? c.parseJSON(localStorage["pm.talks"]) : {};
        if (this.options.talkId in d) { delete d[this.options.talkId]; localStorage["pm.talks"] = JSON.stringify(d); }
      } catch (f) {
        console.log("Invalid pm.talks JSON while clearing window state.");
      }
    }, scrollToMessage: function (d) { this.content.scrollTo('[msgid="' + d + '"]'); }, restoreMessageState: function () {
      var f = this; this.content.empty(); var h = 0; if (this.thread.lastView) {
        for (var e = 0, d = this.thread.messages.length;
          e < d; e++) { if (this.thread.messages[e].id == this.thread.lastView) { h = e - 10 - 1; break; } }
      } if (h < 0) { h = 0; } var g = this.thread.messages.slice(h); c.each(g, function (k, j) {
        f.pushTalkMesage(j);
      }); c.each(this.draft, function (l, j) { var k = { id: j.draftId, text: j.text, uid: f.options.userId, time: j.time }; f.pushTalkMesage(k); }); if (this.draft.length) {
        this.scrollToMessage(this.draft[this.draft.length - 1].draftId);
      } else { this.scrollToMessage(this.thread.lastView); }
    }, formatMessageTime: function (f) {
      var e = new Date(); var d = new Date(f); var g = ""; if ((e.getDate() == d.getDate()) && (e.getMonth() == d.getMonth()) && (e.getFullYear() == d.getFullYear())) {
        g += d.getHours() < 10 ? "0" + d.getHours() : d.getHours();
        g += ":"; g += d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes();
      } else {
        g += d.getDate() < 10 ? "0" + d.getDate() : d.getDate(); g += "."; g += d.getMonth() < 10 ? "0" + d.getMonth() : d.getMonth();
        g += "."; g += d.getFullYear().toString().substr(2);
      } return g;
    }, pushTalkMesage: function (j) {
      if (this.content[0].querySelector('[msgid="' + j.id + '"]')) { return; } var i = false;
      var f = this.content[0].lastChild; if ((f != null) && (f.getAttribute("uid") == j.uid)) {
        var k = f.firstChild; if (k) {
          if (k.getAttribute("class") != "msg") {
            k = k.nextSibling;
          } var h = k.lastChild.previousSibling; if ((j.time - h.getAttribute("msgtime") < this.options.splitNewMessages)) {
            var e = c(k.lastChild); e.before(c('<div msgid="' + j.id + '" msgtime="' + j.time + '"></div>').html(j.text));
            e.text(this.formatMessageTime(j.time)); i = true;
          }
        }
      } if (!i) {
        var g = (j.uid != this.options.userId); var f = c('<div class="' + (g ? "in" : "out") + '" uid="' + j.uid + '"></div>');
        if (g) {
          if (j.uid in this.users) {
            var d = c('<a class="nick"></a>'); d.attr("href", this.users[j.uid].url); d.attr("title", this.users[j.uid].name); d.append(c('<img src="' + this.users[j.uid].avatar + '">'));
            f.append(d); d = null;
          }
        } var k = c('<div class="msg"></div>'); k.append(c('<div msgid="' + j.id + '" msgtime="' + j.time + '"></div>').html(j.text)); k.append(c('<div class="date"></div>').text(this.formatMessageTime(j.time)));
        f.append(k); this.content.append(f);
      }
    }, publicDraft: function (f, e, g) {
      var d = c('[msgid="' + f + '"]', this.content); if (d.length) {
        d.attr("msgid", e); d.attr("msgtime", g);
      }
    }, appendNewMessage: function (d) {
      this.pushTalkMesage(d); this.scrollToMessage(d.id); this.content.trigger("scroll"); if (this.options.userId != d.uid) {
        this.flash(true);
      }
    }, sendMessage: function (f, g, d) {
      var h = { event: f, data: g, time: (new Date()).getTime(), rand: Math.random() }; var e = JSON.stringify(h); if (window.ie) {
        c(window).data("smartMessangerLocalMessage", e);
      } localStorage["pm.message"] = e; if (d) {
        var f = c.Event("storage"); f.key = "pm.message"; f.oldValue = localStorage["pm.message"]; f.newValue = JSON.stringify(h); c(window).trigger(f);
      }
    },
  }; c.fn.smartMessangerWindow = function (f) {
    var d = Array.prototype.slice.call(arguments, 1); var e = []; this.each(function () {
      var i = c(this); var h = i.data("smartMessangerWindow");
      if (!h) {
        if (!("talkId" in f)) { throw "talkId should be specifed."; } if (d.length < 1) { throw "setup data should be specifed."; } else {
          if (!("users" in d[0])) {
            throw "users object should be specifed in setup data.";
          }
        } if (!("thread" in d[0])) { throw "thread object should be specifed in setup data."; } h = new a(this, f, d[0]); i.data("smartMessangerWindow", h);
      } if (typeof f === "string") {
        if (typeof h[f] !== "function") {
          throw "jquery.smartMessangerWindow has no '" + f + "' method";
        } var g = h[f].apply(h, d); if (g !== undefined) { e.push(g); }
      }
    }); return e.length > 0 ? e[0] : this;
  }; c.smartMessangerWindow = function (e, d) {
    var f = new a(e, d); f.$node.data("smartMessangerWindow", f);
    return f.$node;
  }; function b(e) {
    var d = this; this.halted = false; this.options = c.extend({ updateInterval: 10000, lazyUpdateInterval: 60000, hiddenUpdateInterval: 300000, userId: 0, userInStorageId: ("pm.userId" in localStorage) ? parseInt(localStorage["pm.userId"]) : 0, urlAppendParams: {}, sound: false, soundPath: "" }, e);
    this.updateTimer = 0; this.talks = {}; this.users = {}; this.threads = {}; this.drafts = {}; this.init(); if (this.options.userId != 0) { this.feedUpdateLoop(); } else {
      this.feedUpdate();
    }
  } b.prototype = {
    onLoad: function () {
      console.log("Loading..."); this.userChanged(this.options.userId, true); try {
        this.users = ("pm.users" in localStorage) ? c.parseJSON(localStorage["pm.users"]) : {};
      } catch (f) { console.log("Invalid pm.users JSON while loading."); } try {
        this.threads = ("pm.threads" in localStorage) ? c.parseJSON(localStorage["pm.threads"]) : {};
      } catch (f) { console.log("Invalid pm.threads JSON while loading."); } try {
        this.drafts = ("pm.drafts" in localStorage) ? c.parseJSON(localStorage["pm.drafts"]) : {};
      } catch (f) { console.log("Invalid pm.drafts JSON while loading."); } if ("pm.talks" in localStorage) {
        try {
          var d = c.parseJSON(localStorage["pm.talks"]); for (talkId in d) {
            this.openTalk(talkId);
          }
        } catch (f) { console.log("Invalid pm.talks data while loading."); }
      }
    }, onSave: function () { console.log("Saving..."); }, onActivityChanged: function (e) {
      if (("pm.lastUpdate" in localStorage) && e) {
        var d = (new Date(localStorage["pm.lastUpdate"])).getTime();
        if ((new Date()).getTime() - d > this.options.updateInterval) { return this.feedUpdate(true); }
      } this.feedUpdateLoop();
    }, onVisibilityChanged: function (e) {
      if (("pm.lastUpdate" in localStorage) && !e) {
        var d = (new Date(localStorage["pm.lastUpdate"])).getTime();
        if ((new Date()).getTime() - d > this.options.updateInterval) { return this.feedUpdate(true); }
      } this.feedUpdateLoop();
    }, halt: function (f, e) {
      console.log("Halted by: " + e);
      var g = { auth: "Войдите на сайт", unknown: "Временно недоступно", refresh: "Обновите страницу" }; if (this.updateTimer) {
        clearTimeout(this.updateTimer); this.updateTimer = 0;
      } var d = (f in g) ? g[f] : g.unknown; for (talkId in this.talks) { this.talks[talkId].smartMessangerWindow("halt", d); } this.halted = true;
    }, sound: function () {
      if (this.options.sound) {
        if (c(".jBox-Modal").length) {
          c(".jBox-Modal").data("jBox").audio({ url: this.options.soundPath, volume: 75 });
        } else { var d = new jBox("Modal"); d.audio({ url: this.options.soundPath, volume: 75 }); d.destroy(); }
      }
    }, openTalkToUser: function (e, d) { this.getUserTalkQuery(e, d); }, openTalk: function (d) {
      this.sendMessage("openTalk", d, true);
    }, closeTalk: function (d) { this.sendMessage("closeTalk", d, true); }, prepareApiUrl: function (d) {
      if (!c.isEmptyObject(this.options.urlAppendParams)) {
        for (var e in this.options.urlAppendParams) {
          d += (d.indexOf("?") == -1) ? "?" : "&";
          d += encodeURIComponent(e) + "=" + encodeURIComponent(this.options.urlAppendParams[e]);
        }
      } d += (d.indexOf("?") == -1) ? "?" : "&"; d += "r=" + Math.random(); return d;
    }, restarter: function (f) {
      var e = this;
      var d = false; c.ajax({
        url: e.prepareApiUrl(e.options.apiUrl + "/fresh"), processData: false, data: JSON.stringify({}), type: "POST", mimeType: "application/json", beforeSend: function (g) {
          console.log("Try refresh session");
          g.setRequestHeader("Content-Type", "application/json");
        }, success: function (g, i, h) {
          if (typeof (g) == "object") {
            d = true; if (("security_ls_key" in g) && ("userId" in g)) {
              e.options.urlAppendParams.security_ls_key = g.security_ls_key;
              if (g.userId != e.options.userId) { e.userChanged(g.userId, true); } else { if (typeof (f) == "function") { f(); } }
            } else { e.halt("auth", "network"); }
          }
        }, complete: function (g, h) {
          if (!d) {
            e.halt("unknown", "network");
          }
        }
      });
    }, executeQuery: function (d, f, h, g) {
      var e = this; c.ajax({
        url: this.prepareApiUrl(d), processData: false, data: f, type: "POST", mimeType: "application/json", beforeSend: function (i) {
          i.setRequestHeader("Content-Type", "application/json");
        }, success: function (i, k, j) {
          if (typeof (i) == "object") {
            if ("userId" in i) {
              if (i.userId != e.options.userId) { return e.userChanged(i.userId, true); } else {
                if (typeof (h) == "function") {
                  return h.call(e, i);
                } else { return true; }
              }
            } e.halt("unknown", "network");
          }
        }, complete: function (i, j) {
          if (i.status == 200) {
            if (i.responseText == "Hacking attemp!") {
              e.restarter(function () {
                e.executeQuery(d, f, h, g);
              });
            } else { if (typeof (g) == "function") { g.call(e); } }
          } else { e.halt("unknown", "network"); }
        }
      });
    }, newUserTalkQuery: function (d, g, e) {
      var f = { login: d, text: g }; this.executeQuery(this.options.apiUrl + "/newTalk", JSON.stringify(f), function (h) {
        h.draftId = e;
        this.sendMessage("newTalk", h, true);
      });
    }, getUserTalkQuery: function (e, d) {
      var f = { login: e }; this.executeQuery(this.options.apiUrl + "/getTalk", JSON.stringify(f), function (j) {
        if ("users" in j) {
          this.sendMessage("freshUserInfo", j.users, true);
        } if (("talks" in j) && !c.isEmptyObject(j.talks) && !d) {
          this.sendMessage("freshTalkInfo", j.talks, true); for (g in j.talks) {
            if (g in this.talks) {
              if (this.talks[g].smartMessangerWindow("collapsed")) {
                this.talks[g].smartMessangerWindow("collapsed", false);
              } this.talks[g].smartMessangerWindow("focus");
            } break;
          }
        } else {
          for (var h in j.users) {
            if (h == this.options.userId) { continue; } for (g in this.talks) {
              if (g.match(/^draft_/) && (g in this.threads)) {
                if (("draftLogin" in this.threads[g]) && (this.threads[g]["draftLogin"] == e)) {
                  if (this.talks[g].smartMessangerWindow("collapsed")) {
                    this.talks[g].smartMessangerWindow("collapsed", false);
                  } this.talks[g].smartMessangerWindow("focus"); return;
                }
              }
            } var g = "draft_" + Math.round((Math.random() * 1000000)); var i = {}; i[g] = { draftLogin: this.users[h]["login"], header: this.users[h]["name"], title: "Новая переписка с пользователем " + this.users[h]["name"], url: "/talk/add/?talk_users=" + this.users[h]["login"], lastView: 0, messages: [] };
            this.sendMessage("freshTalkInfo", i, true); break;
          }
        }
      });
    }, updateQuery: function () {
      var g = { views: {}, loaded: {}, messages: {} }; for (var e in this.threads) {
        if (e.toString().match(/^draft_/i)) {
          continue;
        } if (this.threads[e] != null) { g.views[e] = this.threads[e].lastView; }
      } for (var e in this.threads) {
        if (e.toString().match(/^draft_/i)) { continue; } if (this.threads[e] != null) {
          if (this.threads[e].messages.length) {
            g.loaded[e] = this.threads[e].messages[this.threads[e].messages.length - 1].id;
          }
        } else { g.loaded[e] = null; }
      } var h = {}; for (var e in this.drafts) {
        if (e.toString().match(/^draft_/i)) { continue; } if (this.drafts[e].length) {
          for (var f = 0, d = this.drafts[e].length;
            f < d; f++) {
              if (!this.drafts[e][f]["sended"]) {
                if (!(e in g.messages)) { g.messages[e] = []; } g.messages[e].push({ draftId: this.drafts[e][f].draftId, text: this.drafts[e][f].text });
                this.drafts[e][f]["sended"] = true; if (!(e in h)) { h[e] = {}; } h[e][this.drafts[e][f].draftId] = true;
              }
          }
        }
      } if (!c.isEmptyObject(h)) {
        localStorage["pm.drafts"] = JSON.stringify(this.drafts);
        this.sendMessage("sendDrafts", h);
      } this.executeQuery(this.options.apiUrl + "/update", JSON.stringify(g), function (i) {
        if ("appends" in i) {
          this.sendMessage("freshDraftsInfo", i.appends, true);
        } if ("users" in i) { this.sendMessage("freshUserInfo", i.users, true); } if ("talks" in i) { this.sendMessage("freshTalkInfo", i.talks, true); } if ("errors" in i) {
          this.sendMessage("freshTalkErrorInfo", i.errors, true);
        }
      }, function () { localStorage["pm.lastUpdate"] = (new Date()).toUTCString(); this.sendMessage("feedUpdateReset", null, true); });
    }, feedUpdate: function (d) {
      if (this.halted) {
        return;
      } this.sendMessage("feedUpdateReset", null); if (d && this.options.userId) {
        console.log("Check before Feed update"); var h = this; var f = this.options.checkUrl + "/";
        var k = this.options.userId.toString(); for (var g = 0, e = k.length; g < e; g++) { f += k.charAt(g) + "/"; } f += "notify_" + k + ".txt?r=" + Math.random(); c.ajax({
          url: f, type: "GET", complete: function (i, j) {
            if ((i.readyState == 4) && (i.status == 200)) {
              if (!("pm.lastTag" in localStorage) || (i.responseText != localStorage["pm.lastTag"])) {
                localStorage["pm.lastTag"] = i.responseText;
                h.feedUpdate();
              } else { h.sendMessage("feedUpdateReset", null, true); }
            } else { h.sendMessage("feedUpdateReset", null, true); }
          }
        });
      } else {
        console.log("Feed update loop");
        this.updateQuery();
      }
    }, feedUpdateLoop: function () {
      var d = this; var e = this.options.updateInterval; if (c.isEmptyObject(this.talks) || !document.active) {
        e = this.options.lazyUpdateInterval;
      } if (document.hidden) { e = this.options.hiddenUpdateInterval; } console.log("Feed update timer set to " + e); if (this.updateTimer) {
        clearTimeout(this.updateTimer);
      } this.updateTimer = setTimeout(function (f) { d.updateTimer = 0; d.feedUpdate(true); }, e + Math.round(Math.random() * 1000));
    }, userChanged: function (f, e) {
      if (this.options.userInStorageId != f) {
        for (var d in this.talks) {
          this.talks[talkId].smartMessangerWindow("clearWindowState");
          this.talks[talkId].smartMessangerWindow("close"); this.talks[talkId].remove(); delete this.talks[d];
        } this.options.userInStorageId = f; this.options.userId = f;
        this.talks = {}; this.threads = {}; this.users = {}; this.drafts = {}; if (e) {
          delete localStorage["pm.talks"]; delete localStorage["pm.threads"]; delete localStorage["pm.drafts"];
          delete localStorage["pm.users"]; delete localStorage["pm.lastUpdate"]; delete localStorage["pm.lastTag"]; localStorage["pm.userId"] = f;
        } console.log("User changed to " + this.options.userId);
      }
    }, onMessage: function (d, l, n) {
      switch (d) {
        case "freshTalkInfo": var t = false; var g = []; for (var o in l) {
          if ((o in this.threads) && (this.threads[o] != null)) {
            if ("title" in l[o]) {
              this.threads[o].title = l[o].title;
            } if ("header" in l[o]) { this.threads[o].header = l[o].header; } if ("url" in l[o]) { this.threads[o].url = l[o].url; } if ("reset" in l[o]) {
              delete l[o].reset; delete this.threads[o].messages;
              c.extend(true, this.threads[o], l[o]); if (o in this.talks) { this.talks[o].smartMessangerWindow("restoreMessageState"); }
            } else {
              var u = this.threads[o].messages.length ? this.threads[o].messages[this.threads[o].messages.length - 1] : null;
              for (var m = 0, k = l[o].messages.length; m < k; m++) {
                if ((u == null) || (l[o].messages[m].id > u.id)) {
                  this.threads[o].messages.push(l[o].messages[m]); if (o in this.talks) {
                    this.talks[o].smartMessangerWindow("appendNewMessage", l[o].messages[m]);
                    if (l[o].messages[m].uid != this.options.userId) { t = true; }
                  }
                }
              }
            }
          } else { if ("reset" in l[o]) { delete l[o].reset; } this.threads[o] = l[o]; t = true; } if (!(o in this.talks)) {
            g.push(o);
          }
        } if (n) {
          localStorage["pm.threads"] = JSON.stringify(this.threads); for (var m = 0, k = g.length; m < k; m++) { this.bNewTalk = true; this.openTalk(g[m], true); } if (t) {
            this.sound();
          }
        } break; case "freshUserInfo": c.extend(true, this.users, l); if (n) { localStorage["pm.users"] = JSON.stringify(this.users); } break; case "freshDraftsInfo": for (var o in l) {
          if (o in this.drafts) {
            for (var q in l[o]) {
              for (var m = 0, k = this.drafts[o].length;
                m < k; m++) {
                  if (this.drafts[o][m].draftId == q) {
                    this.drafts[o].splice(m, 1); if (o in this.talks) {
                      this.talks[o].smartMessangerWindow("publicDraft", q, l[o][q], (new Date()).getTime());
                    } if ((o in this.threads) && (this.threads[o].lastView < l[o][q])) { this.threads[o].lastView = l[o][q]; } break;
                  }
              }
            }
          }
        } if (n) {
          localStorage["pm.drafts"] = JSON.stringify(this.drafts);
        } break; case "freshTalkErrorInfo": if ("add" in l) { for (var o in l.add) { var h = l.add[o]; if (o in this.talks) { this.talks[o].smartMessangerWindow("halt", h); } } } break;
        case "viewThread": if (l.talkId in this.threads) {
          this.threads[l.talkId].lastView = l.messageId; if (n) {
            localStorage["pm.threads"] = JSON.stringify(this.threads);
          }
        } break; case "sendDrafts": for (var o in l) { for (var q in l[o]) { c.each(this.drafts[o], function (e, j) { if (j.draftId == q) { this.drafts[o][e]["sended"] = true; } }); } } break;
        case "appendDraft": if (l.talkId in this.threads) {
          this.drafts[l.talkId].push({ draftId: l.draftId, text: l.text, sended: false, time: (new Date()).getTime() }); if (n) {
            localStorage["pm.drafts"] = JSON.stringify(this.drafts);
          } this.talks[l.talkId].smartMessangerWindow("pushTalkMesage", { id: l.draftId, uid: this.options.userId, text: l.text, time: (new Date()).getTime() }); this.talks[l.talkId].smartMessangerWindow("scrollToMessage", l.draftId);
          if (n) {
            if (l.talkId.toString().match(/^draft_/i) && (l.talkId in this.threads)) {
              this.newUserTalkQuery(this.threads[l.talkId]["draftLogin"], l.text, l.talkId);
            } else { this.feedUpdate(); }
          }
        } break; case "feedUpdateReset": this.feedUpdateLoop(); break; case "refreshWindowState": if (l in this.talks) {
          this.talks[l].smartMessangerWindow("loadWindowState");
        } break; case "changeWindowForeground": for (o in this.talks) { this.talks[o].smartMessangerWindow("loadWindowState"); } break; case "newTalk": var q = l.draftId; if ("users" in l) {
          this.sendMessage("freshUserInfo", l.users, n);
        } if (("errors" in l) && !c.isEmptyObject(l.errors)) {
          for (var m in l.errors) {
            var p = "error_" + Math.round((Math.random() * 1000000)); this.talks[q].smartMessangerWindow("pushTalkMesage", { id: p, uid: 0, text: l.errors[m], time: (new Date()).getTime() });
            this.talks[q].smartMessangerWindow("scrollToMessage", p);
          }
        } else {
          if (("talks" in l) && !c.isEmptyObject(l.talks)) {
            for (var o in l.talks) {
              this.talks[o] = this.talks[q];
              this.talks[o].smartMessangerWindow("resetup", o); delete this.talks[q]; this.drafts[o] = this.drafts[q]; delete this.drafts[q]; l.appends = {}; l.appends[o] = {}; l.appends[o][this.drafts[o][0].draftId] = 0;
              this.onMessage("freshDraftsInfo", l.appends, n); this.threads[o] = this.threads[q]; delete this.threads[q]; delete this.threads[o]["draftLogin"]; this.onMessage("freshTalkInfo", l.talks, n);
              break;
            }
          }
          } break; case "openTalk": var o = l; var v = false; if (!(o in this.talks)) {
            if (!(o in this.threads) || (this.threads[o] == null)) {
              this.threads[o] = null; if (n) {
                v = true;
              }
            } else {
              if (!(o in this.drafts)) { this.drafts[o] = []; } var f = { talkId: o, userId: this.options.userId }; if ("bNewTalk" in this) {
                f.newtalk = true; delete this.bNewTalk;
              } this.talks[o] = c.smartMessangerWindow(f, { users: this.users, thread: this.threads[o], draft: this.drafts[o] });
            }
          } if (v) {
            try { this.feedUpdate(); } catch (r) {
              console.log(r);
            }
          } else { this.feedUpdateLoop(); } break; case "closeTalk": var o = l; if (o in this.talks) {
            this.talks[o].smartMessangerWindow("clearWindowState"); this.talks[o].smartMessangerWindow("close");
            this.talks[o].remove();
          } if (o in this.threads) { var s = 0; c.each(this.threads[o].messages, function (e, j) { s = Math.max(s, j.id); }); this.threads[o].lastView = s; } if (n) {
            if (o.toString().match(/^draft_/i) == null) {
              try {
                this.feedUpdate();
              } catch (r) { console.log(r); }
            } else { this.feedUpdateLoop(); }
          } delete this.talks[o]; delete this.threads[o]; if (!this.drafts[o].length) { delete this.drafts[o]; } if (n) {
            localStorage["pm.threads"] = JSON.stringify(this.threads);
            localStorage["pm.drafts"] = JSON.stringify(this.drafts);
          } break; case "userChanged": this.userChanged(l, n); break; case "halt": this.halt(l, "client"); break;
      }
    }, sendMessage: function (f, g, d) {
      var h = { event: f, data: g, time: (new Date()).getTime(), rand: Math.random() };
      var e = JSON.stringify(h); if (window.ie) { c(window).data("smartMessangerLocalMessage", e); } localStorage["pm.message"] = e; if (d) {
        var f = c.Event("storage"); f.key = "pm.message";
        f.oldValue = localStorage["pm.message"]; f.newValue = e; c(window).trigger(f);
      }
    }, init: function () {
      var f = this; var l = ("pm.version" in localStorage) ? localStorage["pm.version"] : "0";
      var e = this.options.urlAppendParams.version; if (parseFloat(e) > parseFloat(l)) {
        this.sendMessage("halt", "refresh", false); if (parseFloat(l) < 2.4) {
          var k = { "pm.userId": true, "pm.lastUpdate": true };
          for (var g in localStorage) { if (!(g in k)) { delete localStorage[g]; } }
        } localStorage["pm.version"] = e;
      } else {
        if (parseFloat(e) < parseFloat(l)) {
          this.halt("unknown", "client");
          return;
        }
      } c(window).bind("beforeunload", function (i) { if (f.halted) { return; } c(window).unbind("beforeunload", arguments.callee); f.onSave(); }); c(window).bind("storage", function (n) {
        if (f.halted) {
          return;
        } if (n.key == "pm.message") {
          try {
            var i = !("originalEvent" in n); if (!i && window.ie && (c(window).data("smartMessangerLocalMessage") === n.newValue)) {
              c.removeData(c(window), "smartMessangerLocalMessage");
              return;
            } var o = c.parseJSON(i ? n.newValue : n.originalEvent.newValue); if (!("event" in o)) { throw true; } try {
              if ("data" in o) { f.onMessage(o.event, o.data, i); } else {
                f.onMessage(o.event, null, i);
              }
            } catch (m) { console.log(m); }
          } catch (m) { console.log("Unknown message:" + (("originalEvent" in n) ? n.originalEvent.newValue : n.newValue)); }
        } else { }
      }); var j, d; if (typeof document.hidden !== "undefined") {
        j = "hidden";
        d = "visibilitychange";
      } else {
        if (typeof document.mozHidden !== "undefined") { j = "mozHidden"; d = "mozvisibilitychange"; } else {
          if (typeof document.msHidden !== "undefined") {
            j = "msHidden";
            d = "msvisibilitychange";
          } else { if (typeof document.webkitHidden !== "undefined") { j = "webkitHidden"; d = "webkitvisibilitychange"; } }
        }
      } if (j != "hidden") {
        document.hidden = document[j];
      } document.active = !document.hidden; c(document).on(d, function (i) {
        if (f.halted) { return; } if (j != "hidden") { document.hidden = document[j]; } try {
          f.onVisibilityChanged(document[j]);
        } catch (i) { console.log(i); }
      }); var h = 0; c(document).on("scroll mouseover keydown", function (i) {
        if (f.halted) { return; } if (h) { clearTimeout(h); h = 0; } if (!document.active) {
          try {
            document.active = !document.active;
            f.onActivityChanged(document.active);
          } catch (i) { console.log(i); }
        } h = setTimeout(function (m) {
          h = 0; if (document.active) {
            try {
              document.active = !document.active; f.onActivityChanged(document.active);
            } catch (m) { console.log(m); }
          }
        }, 20000);
      }); c(document).trigger("scroll"); this.onLoad();
    }
  }; c.fn.smartMessanger = function (f) {
    var d = Array.prototype.slice.call(arguments, 1);
    var e = []; this.each(function () {
      var i = c(this); var h = i.data("smartMessanger"); if (!h) { h = new b(f); i.data("smartMessanger", h); } if (typeof f === "string") {
        if (typeof h[f] !== "function") {
          throw "jquery.smartMessanger has no '" + f + "' method";
        } var g = h[f].apply(h, d); if (g !== undefined) { e.push(g); }
      }
    }); return e.length > 0 ? e[0] : this;
  }; window.ie = (function () {
    if (window.ActiveXObject === undefined) {
      return null;
    } if (!document.querySelector) { return 7; } if (!document.addEventListener) { return 8; } if (!window.atob) { return 9; } if (!document.__proto__) { return 10; } return 11;
  })(); (function (d) {
    (jQuery.browser = jQuery.browser || {}).mobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(d) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(d.substr(0, 4));
    jQuery.browser.mobile = jQuery.browser.mobile || d.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i);
  })(navigator.userAgent || navigator.vendor || window.opera);
})(jQuery);
(function ($) {

  function TopicDonateDialog(iTopicId) {
    var dialog = null;
    var options =
    {
      id: 'topicDonateDialog',
      title: 'Поблагодарить пользователя',
      closeOnConfirm: false,
      confirmButton: 'Дать',
      cancelButton: 'Отмена',
      content: 'Вы благодарите <a id="user" target="_blank" /> за пост <a id="topic" target="_blank" /><br/><br/> У вас на счету: <span id="bill" />₽<br/><br/>Сколько даете? <input type="text" id="donate" />',

      confirm: function () {
        if (!parseInt(dialog.wrapper.find('#donate').val())) {
          return msgErrorBox.alert('Ошибка!', 'Нельзя дать 0 рублей');
        }

        if (parseInt(dialog.wrapper.find('#donate').val()) > options.iBill) {
          return msgErrorBox.alert('Ошибка!', 'У вас нет столько денег. Вы можете дать не более ' + options.iBill + '₽');
        }

        $.post(aRouter['money'] + 'donate_ajax?JsHttpRequest=' + (new Date()).getTime() + '-xml', { target_id: iTopicId, target_type: 'topic', amount: parseInt(dialog.wrapper.find('#donate').val()), security_ls_key: LIVESTREET_SECURITY_KEY }, function (result) {
          try {
            result = JSON.parse(result);
            result = result.js;

          } catch (e) { result = null; }

          if (!result) {
            return msgErrorBox.alert('Error', 'Please try again later');
          }

          if (result.bStateError) {
            msgErrorBox.alert(result.sMsgTitle, result.sMsg);
          } else {
            msgNoticeBox.alert(result.sMsgTitle, result.sMsg);
            var topic = $('.topic[tid=' + iTopicId + ']');
            if (topic.length) {
              var node = null;
              var container = topic.find('.views-total, .views-total-topic');
              container.find('span').each(function (i, el) {
                if ($(el).text().indexOf('₽') != -1) {
                  node = $(el);
                  return false;
                }

              });

              if (node === null) {
                node = $('<span />');
                if (container.find('span').length) container.append(' | ');
                container.append(node);
              }

              node.attr('title', 'Топик собрал ' + result.iBill + ' рублей').text('₽ ' + result.iBill);
            }
            dialog.close();
          }
        });
      },

      onOpen: function () {
        this.wrapper.find('#user').text(options.sUserTitle).attr('href', options.sUserUrl);
        this.wrapper.find('#topic').text(options.sTargetTitle).attr('href', options.sTargetUrl);
        this.wrapper.find('#bill').text(options.iBill);
        this.wrapper.find('#donate').on('keypress', function (e) {
          var digits = '1234567890';
          if (digits.indexOf(e.key) == -1) e.preventDefault();
        });
      },

      onClose: function () {
        this.wrapper.find('#donate').off('keypress');
      },

      onCloseComplete: function () {
        this.destroy();
      }
    };

    $.getJSON(aRouter['money'] + 'donate_ajax', { target_id: iTopicId, target_type: 'topic', security_ls_key: LIVESTREET_SECURITY_KEY, JsHttpRequest: (new Date()).getTime() + '-xml' }, function (result) {
      if (result.js.bStateError) {
        msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
        return;
      }

      options['iBill'] = result.js.iBill;
      options['sTargetTitle'] = result.js.sTargetTitle;
      options['sTargetUrl'] = result.js.sTargetUrl;
      options['sUserTitle'] = result.js.sUserTitle;
      options['sUserUrl'] = result.js.sUserUrl;

      dialog = new jBox('Confirm', options);
      dialog.open();
    });
  }

  $(document).ready(function () {
    $('#content').on('click', '.topic > .voting > .donate > a', function (e) {
      e.preventDefault();
      var iTopicId = $(this).parents('.topic').attr('tid');
      TopicDonateDialog(iTopicId);
    });
  });

})(jQuery);
(function ($) {
  $(document).ready(function ($) {
    var cache = {};
    var timer = 0;
    var targetId = null;
    var targetType = null;
    var vpopup = $('<div class="WhoFavourited"></div>');
    $('body').append(vpopup);

    function vPopupFill(node, data) {
      vpopup.empty();
      if ($.isEmptyObject(data)) {
        vpopup.append('Нет данных');
      } else {
        $.each(data, function (i, v) {
          vpopup.append('<div>' + v['name'] + '</div>');
        });
      }

      var off = $(node).offset();
      vpopup.css('left', off.left + $(node).outerWidth());
      vpopup.css('top', off.top + $(node).outerHeight());
      vpopup.show();
    }

    $('div.topic[tid]').on('mouseover', '.favourited_menu', function (e) {
      var node = e.target;
      $(node).removeAttr('title');

      timer = setTimeout(function () {
        timer = 0;

        var nTopic = $(node).parents('.topic[tid]');
        if (nTopic.length) {
          targetType = 'topic';
          targetId = nTopic.attr('tid');
        }

        if ((targetType in cache) && (targetId in cache[targetType])) {
          vPopupFill(node, cache[targetType][targetId]);
        } else {
          var off = $(node).offset();
          vpopup.empty();
          vpopup.append('<div>Загрузка...</div>');
          vpopup.css('left', off.left + $(this).outerWidth());
          vpopup.css('top', off.top + $(this).outerHeight());
          vpopup.show();

          var sLoadingTargetType = targetType;
          var iLoadingTargetId = targetId;
          JsHttpRequest.query('POST /profile/favourited/' + targetType + '/' + targetId + '/?security_ls_key=' + LIVESTREET_SECURITY_KEY, {}, function (result, errors) {
            if (sLoadingTargetType !== targetType) return;
            if (iLoadingTargetId !== targetId) return;

            if (result && !result.bStateError) {
              if (!(targetType in cache)) cache[targetType] = {};
              cache[targetType][targetId] = result.data;
              vPopupFill(node, cache[targetType][targetId]);

            } else {
              vpopup.find('div').text('Ошибка!');
            }
          });
        }
      }, 500);

    }).on('mouseout', '.favourited_menu', function (e) {
      targetId = null;
      targetType = null;
      if (timer) {
        clearTimeout(timer);
        timer = 0;
      }
      vpopup.hide();
    });
  });

})(jQuery);
jQuery(document).ready(function ($) {

  // подписка на тему
  $('.notifies_table').on('click', '.article_subscribe', function (e) {
    var btn = $(this);
    var sArticleId = btn.data('target-id');
    var sType = btn.data('subscribe-type');
    var bSubscribe = btn.is(':checked');

    if (sType && sArticleId) {
      e.preventDefault();
      $.ajax({

        url: '/finansoviy-slovar/ajaxsubscribe/' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
        type: 'POST',
        data: { id: sArticleId, type: sType, subscribe: bSubscribe ? 1 : 0, security_ls_key: LIVESTREET_SECURITY_KEY }
      }).then(function (result) {
        try {
          result = JSON.parse(result);
        } catch (e) {
          msgErrorBox.alert('Внимание!', 'Неизвестная ошибка');
          return;
        }

        if (result.js.bStateError) {
          msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
          return;
        } else {
          msgNoticeBox.alert(result.js.sMsgTitle, result.js.sMsg);
          btn.prop('checked', bSubscribe);
        }
      });
    }
  });

});
jQuery(document).ready(function ($) {
  // панель слева - забаненые
  var addEmployeeBtn = $('#add_company_employee').first();
  if (addEmployeeBtn.length && addEmployeeBtn.attr('company-id')) {
    var sWindowContent = '<div class="employeeBox">\
								<div>\
									<span>Введите имя:</span><br/>\
									<div>\
										<input type="text"/>\
									</div>\
								</div><br/>\
								<span>Список сотрудников:</span>\
								<ul>\
									<li>Загружаю...</li>\
								</ul>\
						</div>';

    var employeeDialogParam = {

      id: 'employeeDialog',
      title: 'Список сотрудников компании',
      confirmButton: 'ОК',
      cancelButton: 'Отмена',
      content: sWindowContent,
      companyId: addEmployeeBtn.attr('company-id'),
      width: 450,

      onOpen: function () {
        var self = this;
        if ('confirmed' in this.options) delete this.options.confirmed;
        this.options.loadEmployeeList.call(this);

        var list = self.wrapper.find('ul');
        this.wrapper.on('click', '.removeFromEmployee', function () {
          $(this).parents('li').remove();
          if (!list.find('li').length) list.append('<li id="0">Нет сотрудников.</li>');
        });

        this.wrapper.find('input:text').autocomplete({
          serviceUrl: '/summoner/nick_autocomplete2/',
          type: 'GET',
          dataType: 'json',
          paramName: 'q',
          preventBadQueries: false,
          zIndex: 99999,
          transformResult: function (response) {
            return { suggestions: response.results };
          },
          onSelect: function (suggestion) {
            var list = self.wrapper.find('ul');
            if (!list.find('li#' + suggestion.id).length) {
              var a = $('<a/>').attr('href', suggestion.url).text(suggestion.value);
              var li = $('<li/>').attr('id', suggestion.id);
              li.append(a);
              li.append($('<span class="removeFromEmployee" title="Удалить из сотрудников">&ndash;</span>'));
              list.append(li);
              $(this).val('');

              if (list.find('li#0').length) list.find('li#0').remove(); // убираем "нет сотрудников"

              var iScroll = list[0].scrollHeight - list[0].clientHeight;
              list[0].scrollTop = iScroll ? iScroll : 0;
            }
          }
        });
      },

      loadEmployeeList: function () {
        var self = this;
        $.ajax({

          url: '/panel/ajaxemployeelist' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
          type: 'GET',
          data: { id: this.options.companyId, security_ls_key: LIVESTREET_SECURITY_KEY }

        }).then(function (result) {
          try {
            result = JSON.parse(result);
            if (result.js.bStateError) {
              msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
              return;
            }

          } catch (e) { }

          var list = self.wrapper.find('ul');
          list.empty();
          if (('employee' in result.js) && result.js.employee.length) {
            $.each(result.js.employee, function (i, v) {
              var li = $('<li/>');
              li.attr('id', v['id']);
              var a = $('<a/>').attr('href', v['url']).text(v['name']);
              li.append(a);

              li.append($('<span class="removeFromEmployee" title="Удалить из сотрудников">&ndash;</span>'));
              list.append(li);
            });

          } else {
            list.append('<li id="0">Нет сотрудников.</li>');
          }
        });
      },

      saveEmployeeList: function () {
        var self = this;

        var aEmployee = [];
        this.wrapper.find('ul').find('li').each(function (i, n) {
          aEmployee.push(this.id);
        });

        if (aEmployee.indexOf(0) !== -1) aEmployee = aEmployee.splice(aEmployee.indexOf(0), 1);

        $.ajax({

          url: '/panel/ajaxemployeelist' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
          type: 'POST',
          data: { id: self.options.companyId, employee: aEmployee, security_ls_key: LIVESTREET_SECURITY_KEY }

        }).then(function (result) {
          try {
            result = JSON.parse(result);
          } catch (e) {
            msgErrorBox.alert('Внимание!', 'Неизвестная ошибка');
            return;
          }

          if (result.js.bStateError) {
            msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
          } else {
            if (result.js.sMsg) msgNoticeBox.alert(result.js.sMsgTitle, result.js.sMsg);
          }
        });
      },

      confirm: function () {
        this['confirmed'] = true;
      },

      onClose: function () {
        if (('confirmed' in this.options) && (this.options.confirmed)) this.options.saveEmployeeList.call(this);
        this.wrapper.off('click');
      }
    };

    addEmployeeBtn.on('click', function () {
      var box = new jBox('Confirm', employeeDialogParam);
      box.open();
    });
  }

});
(function (c) {
  var b = '<div class="book_popup">	<div class="book_thumbnail">		<a href="#" title="Посмотреть страницу книги">			<img src="/plugins/books/templates/skin/default/img/nocover.png" />		</a>	</div>	<div class="book_info">		<div><a class="book_title" href="#" title="Посмотреть страницу книги">Длинное длинное название книги на несколько строк и в одну не влезает</a></div>		<div><span class="book_subtitle">Дополнительный заголовок если есть, возможно заголовок оригинальный на забугорном языке</span></div>		<div class="book_authors"><a href="#">Автор книги</a>, <a href="#">Автор книги 2</a></div>		<div class="book_rating">			<div style="width: 10%"></div>		</div>	</div>	<div class="profile_panel">		<div>			<a href="#">Купить</a>			<a href="#">Скачать</a>			<a href="#">Хочу прочитать потом</a>			<a href="#">Я ее читал</a>		</div>	</div></div>';
  function a(j) {
    var d = c(b); d.find(".book_thumbnail img").attr("src", j.thumbnail ? j.thumbnail : DIR_WEB_ROOT + "/plugins/books/templates/skin/default/img/nocover.png");
    d.find(".book_thumbnail a").attr("href", j.profile); d.find(".book_title").attr("href", j.profile).text(j.title); if ("title_second" in j) {
      d.find(".book_subtitle").text(j.title_second);
    } else { d.find(".book_subtitle").parent("div").remove(); } if ("authors" in j) {
      var i = d.find(".book_authors").empty(); var h = false; for (var g in j.authors) {
        if (h) {
          i.append(c(document.createTextNode(", ")));
        } var f = c("<a></a>").attr("href", j.authors[g]).text(g); i.append(f); h = true;
      }
    } else { d.find(".book_authors").remove(); } d.find(".book_rating > div").css("width", Math.round(parseFloat(j.rating) * 20) + "%");
    d.find(".book_rating").attr("title", "Рейтинг: " + Math.round(parseFloat(j.rating) * 100) / 100 + ", Проголосовало: " + j.votes); var e = d.find(".profile_panel > div");
    e.empty(); if ("buy_url" in j) { e.append(c('<a href="' + j.buy_url + '" target="_blank">Купить</a>')); } if ("buy_in_english_url" in j) {
      e.append(c('<a href="' + j.buy_in_english_url + '" target="_blank">Buy</a>'));
    } if ("download_url" in j) { e.append(c('<a href="' + j.download_url + '" target="_blank">Скачать</a>')); } if (!("reviewed" in j)) {
      if (!("wishlisted" in j)) {
        e.append(c('<a href="' + (("guest_mode" in j) ? "/login" : "/books/book_add_to_wishlist/" + j.id) + '/" target="_blank">Хочу прочитать потом</a>'));
      } else { e.append(c('<a href="/books/book_remove_from_wishlist/' + j.id + '/" target="_blank">Не буду читать</a>')); } e.append(c('<a href="' + (("guest_mode" in j) ? "/login" : "/review/add/for/" + j.id) + '/" target="_blank">Я ее читал</a>'));
    } if (d.scrollHeight > 0) { d.css("height", (d.height() + d.scrollHeight) + "px"); e.css("bottom", "0"); } return d;
  } c(document).ready(function () {
    var g = {}; var f = new RegExp("^/books/([^\\/]+)/$", "i");
    var e = new RegExp("^/books/book_view/(\\d+)/?$", "i"); var d = ["book_add_to_wishlist", "book_remove_from_wishlist", "wishlist_of", "autocomplete", "book_add", "book_edit", "book_delete", "book_view", "book_list", "book_search", "reviewed_by", "genre_add", "genre_edit", "genre_up", "genre_down", "genre_delete", "genre_list", "publisher_add", "publisher_edit", "publisher_up", "publisher_down", "publisher_delete", "publisher_list", "top", "list"];
    new jBox("Tooltip", {
      id: "bookPopover", trigger: "mouseenter", adjustDistance: { top: 55, right: 5, bottom: 5, left: 5 }, delayOpen: 500, closeOnMouseleave: true, animation: "move", attach: c('a[href^="/books/"]').filter(function (j) {
        if (c(this).attr("href").match(e) !== null) {
          return true;
        } var h = c(this).attr("href").match(f); if (h && (d.indexOf(h[1]) == -1)) { return true; } return false;
      }), zIndex: 8000, position: { x: "center", y: "bottom" }, followMouse: true, outside: "y", onOpen: function () {
        var j = this;
        var n = null; var k = null; if (m = c(this.target).attr("href").match(e)) { n = m[1]; } if (m = c(this.target).attr("href").match(f)) { k = m[1]; } if (c(this.target).find("img").length) {
          this.target = c(this.target).find("img");
        } var l = function (o) { this.setContent(a(o)); }; var i = (n != null) ? "id:" + n : "u:" + k; if (!(i in g)) {
          var h = {}; if ("LIVESTREET_SECURITY_KEY" in window) {
            h.security_ls_key = LIVESTREET_SECURITY_KEY;
          } if (k != null) { h.url = k; } if (n != null) { h.id = n; } JsHttpRequest.query("POST /books/ajaxprofile/", h, function (o, p) {
            if (!o) { return; } if (!o.bStateError) {
              g[i] = o.aProfile;
              l.call(j, g[i]);
            }
          }, true);
        } else { l.call(this, g[i]); }
      }, onCloseComplete: function () { c(".book_popup").remove(); }
    });
  });
})(jQuery);
/**
 * Cursor Functions
 *
 * Used for setting and getting text cursor position within an input
 * and textarea field. Also used to get and set selection range.
 * 
 * @author Branden Cash
 * @email brandencash@crutzdesigns.com
 */

(function ($) {
  jQuery.fn.getCursorPosition = function () {
    if (this.lengh == 0) return -1;
    return $(this).getSelectionStart();
  }

  jQuery.fn.setCursorPosition = function (position) {
    if (this.lengh == 0) return this;
    return $(this).setSelection(position, position);
  }

  jQuery.fn.getSelection = function () {
    if (this.lengh == 0) return -1;
    var s = $(this).getSelectionStart();
    var e = $(this).getSelectionEnd();
    return this[0].value.substring(s, e);
  }

  jQuery.fn.getSelectionStart = function () {
    if (this.lengh == 0) return -1;
    input = this[0];

    var pos = input.value.length;

    if (input.createTextRange) {
      var r = document.selection.createRange().duplicate();
      r.moveEnd('character', input.value.length);
      if (r.text == '')
        pos = input.value.length;
      pos = input.value.lastIndexOf(r.text);
    } else if (typeof (input.selectionStart) != "undefined")
      pos = input.selectionStart;

    return pos;
  }

  jQuery.fn.getSelectionEnd = function () {
    if (this.lengh == 0) return -1;
    input = this[0];

    var pos = input.value.length;

    if (input.createTextRange) {
      var r = document.selection.createRange().duplicate();
      r.moveStart('character', -input.value.length);
      if (r.text == '')
        pos = input.value.length;
      pos = input.value.lastIndexOf(r.text);
    } else if (typeof (input.selectionEnd) != "undefined")
      pos = input.selectionEnd;

    return pos;
  }

  jQuery.fn.setSelection = function (selectionStart, selectionEnd) {
    if (this.lengh == 0) return this;
    input = this[0];

    if (input.createTextRange) {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveEnd('character', selectionEnd);
      range.moveStart('character', selectionStart);
      range.select();
    } else if (input.setSelectionRange) {
      input.focus();
      input.setSelectionRange(selectionStart, selectionEnd);
    }

    return this;
  }
})(jQuery);
(function ($) {

  $.fn.smart_console = function (options) {
    var self = this;

    var input = this.find('input');
    var help = $('<div class="help"></div>').appendTo(this);
    var combo = $('<div class="console_combo"></div>').insertAfter(this);

    options = options || {};
    var settings = {

      combo_timeout: 100,
      commands: {},
      aliases: {},
      autocomplete_url: {

        'login': '/summoner/nick_autocomplete/$query$/',
        'company': '/company/autocomplete/$query$/',
        'forum': '/console/ajaxCompany/?value=$query$',
        'symbol': '/g/autocomplete/$query$/',
        'tag': '/include/ajax/tagAutocompleterConsole.php?q=$query$',
        'wiki': '/include/ajax/dictionaryAutocompleterConsole.php?q=$query$',
        'book': '/books/autocomplete/$query$/'
      }
    };

    var autocomplete = {

      box: null,
      search_empty: '',
      mode: '',
      cache: { login: {}, company: {}, forum: {}, symbol: {}, tag: {}, wiki: {}, book: {} }
    };

    if (options) $.extend(settings, options);

    /* -------------------- Autocompleter begin -------------------*/

    function autocomplete_from() {
      var command = input.val();
      var from_spaces = 0;
      var m = command.match(/^(\s*)?(.*)/);
      if (m !== null) {
        command = m[2];
        from_spaces = (typeof (m[1]) == 'undefined') ? 0 : m[1].length;
      }

      var params = command.split(' ');

      // $GAZP hack
      if (command[0] == '$') {
        params[0] = params[0].substr(1);
        params.unshift('$');
      }


      var cmd = $.trim(params.shift().toUpperCase());
      if (cmd in settings.aliases) cmd = settings.aliases[cmd];
      if (cmd in settings.commands) {
        function autocomplete_try(cmd, info) {
          autocomplete.mode = '';
          if ('ac' in info) {
            var param_test = $.trim(params.join(' '));
            var param_val = info.ac.exec(param_test);

            if (param_val !== null) {
              if ((info.ac.toString().indexOf('@') !== -1) && (info.ac.toString().indexOf('[^@') === -1)) {
                // login
                autocomplete.mode = 'login';
                return command.indexOf('@') + 1;

              } else if (info.act == 'forum$') {
                // forum
                autocomplete.mode = 'forum';
                return cmd.length; // strlen corp (without space // for $GAZP)

              } else if ('act' in info) {
                autocomplete.mode = info.act;
                return cmd.length + 1 + param_val['index'] + param_val[0].search(param_val[1]);
              }
            }
          }
          return -1;
        }

        var res = false;
        if ('variants' in settings.commands[cmd]) {
          try {
            $.each(settings.commands[cmd]['variants'], function (i, v) {
              res = autocomplete_try(cmd, v);
              if (res !== -1) {
                res += from_spaces;
                //console.log(res + ' ' + autocomplete.mode);
                throw true;
              }
            });

          } catch (e) { }
        } else {
          res = autocomplete_try(cmd, settings.commands[cmd]);
          if (res !== -1) res += from_spaces;
        }
        return (input.getCursorPosition() >= res) ? res : -1;
      }
      return -1;
    }

    function autocomplete_close() {
      if (autocomplete.search_ajax != null) {
        autocomplete.search_ajax.abort();
        autocomplete.search_ajax = null;
      }

      autocomplete.box.hide();
    }

    function autocomplete_fill() {
      if (autocomplete.search_ajax != null) {
        autocomplete.search_ajax.abort();
        autocomplete.search_ajax = null;
      }

      var word = $.trim(input.val().substr(autocomplete_from()));
      if (word !== '') {
        function autocomplete_fill_results(data) {
          if (data !== null) {
            autocomplete.search_empty = '';
            autocomplete.cache[autocomplete.mode][word] = data;
            autocomplete.box.trigger({ type: 'reset', message: { items: data, mode: autocomplete.mode } });
          } else {
            if (!autocomplete.search_empty) autocomplete.search_empty = word;
            autocomplete_close();
          }
        }

        if (autocomplete.search_empty && (autocomplete.search_empty.length <= word.length) && (word.indexOf(autocomplete.search_empty) == 0)) {
          autocomplete_close();
        } else {
          if (word in autocomplete.cache[autocomplete.mode]) {
            autocomplete_fill_results(autocomplete.cache[autocomplete.mode][word]);
          } else {
            autocomplete.search_ajax = $.getJSON(settings.autocomplete_url[autocomplete.mode].replace('$query$', encodeURIComponent(word)), function (res) {
              var data = ((('results' in res) && res.results.length) ? res.results : null);
              autocomplete.cache[autocomplete.mode][word] = data;
              autocomplete_fill_results(data);
            });
          }
          return true;
        }
      } else {
        autocomplete_close();
      }
      return false;
    }

    function autocomplete_open() {
      var from = autocomplete_from();
      if (from !== -1) {
        var word = $.trim(input.val().substr(from));
        // не искать дальше, если на предыдущий запрос ничего не нашлось. Не всегда работает с финсловарями, т.к. там поиск от 3х символов
        if (autocomplete.search_empty && (autocomplete.search_empty.length > 3) && (autocomplete.search_empty.length <= word.length) && (word.indexOf(autocomplete.search_empty) == 0)) return false;
        if (word in autocomplete.cache[autocomplete.mode]) {
          var ct = 0;
          var founded = false;
          $.each(autocomplete.cache[autocomplete.mode][word], function (i, v) {
            ct++;
            if (v.l === word) founded = true;
          });

          if (founded && (ct == 1)) {
            if (autocomplete.box.css('display') != 'none') autocomplete_close();
            return false;
          }
        }

        if (autocomplete.box.css('display') == 'none') {
          autocomplete.search_empty = '';
          var offset = input.offset();
          autocomplete.box.css('top', offset.top + input.outerHeight() + 'px');
          autocomplete.box.css('left', offset.left + (from * 13) + 'px');
          autocomplete.box.trigger({ type: 'reset', message: { items: [] } });
          autocomplete.box.show();
        }

        return autocomplete_fill();
      } else {
        if (autocomplete.box.css('display') != 'none') autocomplete_close();
      }

      return false;
    }

    function autocomplete_done(unique) {
      var from = autocomplete_from();
      if (from != -1) {
        var word = $.trim(input.val().substr(from));
        var res = autocomplete.cache[autocomplete.mode][word];
        try {
          $.each(res, function (i, v) {
            if (v.l == unique) {
              var t = input.val().substr(0, from) + unique;
              input.val(t);
              input.setCursorPosition(t.length);
              throw true;
            }
          });

        } catch (e) { }
      }
      autocomplete_close();
    }


    /* -------------------- Autocompleter end -------------------*/


    function tooltip_help(value) {
      if (help.length) {
        help.text(value);
        if (value.length) {
          help.show();
        } else {
          help.hide();
        }
      }
    }


    function need_auth(command) {
      return ((!('login' in settings)) && ('auth_required' in command) && (command.auth_required === true));
    }

    function help_func(command) {
      if (!command.length) {
        var data = [];
        var needed = ['FIND ', 'FIND @', 'BLOG @', '$', 'G', 'FIND B ', 'FIND F ', 'TAG '];
        $.each(needed, function (i, command) {
          for (var cmd in settings.commands) {
            if (cmd == command) {
              var v = settings.commands[cmd];
              var t = ('start_title' in v) ? v['start_title'] : v['title'];
              data.push({ l: cmd, t: t, s: ('syntax' in v) ? v['syntax'] : cmd, a: need_auth(settings.commands[cmd]), oc: cmd });

            } else {
              var variants = ('variants' in settings.commands[cmd]) ? settings.commands[cmd]['variants'] : [settings.commands[cmd]];
              $.each(variants, function (i, v) {
                var u = ('command' in v) ? v['command'] : (('syntax' in v) ? v['syntax'] : i);
                if (u == command) {
                  var t = ('start_title' in v) ? v['start_title'] : v['title'];
                  data.push({ l: u, t: t, s: ('syntax' in v) ? v['syntax'] : cmd, a: need_auth(v), oc: cmd });
                  return false;
                }
              });
            }
          }
        });

        combo.trigger({ type: 'reset', message: { items: data, mode: 'help_reverse' } });
        return true;
      }

      var params = command.replace(/^\s+/, '').split(' ');
      var cmd = params.shift().toUpperCase();
      if (cmd in settings.aliases) cmd = settings.aliases[cmd];

      if (cmd in settings.commands) {
        var data = [];
        var variants = ('variants' in settings.commands[cmd]) ? settings.commands[cmd]['variants'] : [settings.commands[cmd]];
        $.each(variants, function (i, v) {
          if (!(('hidden' in v) && v['hidden'])) {
            var u = ('command' in v) ? v['command'] : (('syntax' in v) ? v['syntax'] : cmd);
            data.push({ l: u, t: v['title'], s: ('syntax' in v) ? v['syntax'] : cmd, a: need_auth(v), oc: cmd });
            if ((u == command.toUpperCase()) && ('tooltip' in v)) tooltip_help(v['tooltip']);
          }
        });
        combo.trigger({ type: 'reset', message: { items: data, mode: 'help_reverse' } });
        return true;

      } else if (cmd == 'HELP') {
        var data = [];
        for (var i in settings.commands) {
          if (('hidden' in settings.commands[i]) && (settings.commands[i]['hidden'])) continue;
          var item = { l: i, t: settings.commands[i]['title'], c: 'Подробнее о команде ' + i, a: need_auth(settings.commands[i]) };
          data.push(item);
        }
        data.push({ l: 'HELP', t: 'Выводит это сообщение', c: 'Это вся доступная помощь \'(', a: false });
        combo.trigger({ type: 'reset', message: { items: data, mode: 'help' } });

        return true;

      } else if (cmd) {
        var data = [];
        var rx = new RegExp('^' + cmd.replace('\\', '\\\\'), 'i');
        for (var i in settings.commands) {
          var variants = ('variants' in settings.commands[i]) ? settings.commands[i]['variants'] : [settings.commands[i]];
          $.each(variants, function (ii, v) {
            var u = ('command' in v) ? v['command'] : (('syntax' in v) ? v['syntax'] : i);
            if (('command' in v) && rx.test(v['command'])) {
              data.push({ l: u, t: v['title'], s: ('syntax' in v) ? v['syntax'] : i, a: need_auth(v), oc: i });

            } else if (rx.test(i) && (!('params' in v))) {
              data.push({ l: u, t: v['title'], s: ('syntax' in v) ? v['syntax'] : i, a: need_auth(v), oc: i });

            } else if (rx.test(v['title'])) {
              data.push({ l: u, t: v['title'], s: ('syntax' in v) ? v['syntax'] : i, a: need_auth(v), oc: i });
            } else if ('keywords' in v) {
              var aw = v['keywords'].split(',');
              $.each(aw, function (iii, w) {
                if (rx.test(w)) {
                  data.push({ l: u, t: v['title'], s: ('syntax' in v) ? v['syntax'] : i, a: need_auth(v), oc: i });
                  return false;
                }
              });
            }
          });
        }

        if (data.length) {
          combo.trigger({ type: 'reset', message: { items: data, mode: 'help_reverse' } });
          return true;
        }

      }
      return false;
    };


    function need_help(value, prepend) {
      var arglen = arguments.length;
      //value = $.trim(value);

      if ('combo_timer' in settings) {
        clearTimeout(settings.combo_timer);
        delete settings.combo_timer;
      }

      settings.combo_timer = setTimeout(function () {
        var show = help_func(value);
        if (!show) {
          if (combo.css('display') != 'none') combo.slideToggle('fast');
        } else {
          if (arglen > 1) combo.prepend(prepend);
          combo.css('max-height') < combo.height() ? combo.css('overflow-y', 'scroll') : combo.css('overflow-y', 'auto');
          if (combo.css('display') == 'none') combo.slideToggle('fast');
        }

      }, settings.combo_timeout);
    };


    function redirect(url, new_tab) {
      new_tab = true;
      //	if (url[0] == '/') url = 'http://smart-lab.ru' + url;

      if (new_tab) {
        window.open(url, '_blank');
      } else {
        document.location = url;
      }
    }


    function command_func(command) {
      var params = $.trim(command).split(' ');

      // $GAZP hack
      if (command[0] == '$') {
        params[0] = params[0].substr(1);
        params.unshift('$');
      }

      var cmd = params.shift().toUpperCase();
      if (cmd in settings.aliases) cmd = settings.aliases[cmd];
      if (cmd in settings.commands) {
        var ERR_OK = 0;
        var ERR_SYNTAX = 1;
        var ERR_UNKNOWN = 2;
        var ERR_AUTH = 3;

        var err_msg = {};
        err_msg[ERR_SYNTAX] = 'Ошибка синтаксиса.';
        err_msg[ERR_UNKNOWN] = 'Неизвестная команда.';
        err_msg[ERR_AUTH] = 'Необходима авторизация.';

        function notifyStat(sCommand) {
          $.get('/console/ajaxCommand', { 'command': sCommand, 'line': command });
        }

        function execute(info, sCommand) {
          function execute_simple() {
            if ('redirect_url' in info) {
              if (need_auth(info)) return ERR_AUTH;
              redirect(info['redirect_url']);
              return ERR_OK;

            } else if ('url' in info) {
              if (need_auth(info)) return ERR_AUTH;

              var u = info['url'];
              if (u.indexOf('$login') !== -1) u = u.replace('$login', encodeURIComponent(settings.login));
              redirect(u);
              return ERR_OK;

            } else if ('func' in info) {
              if (need_auth(info)) return ERR_AUTH;
              var func = (info['func'] in window) ? window[info['func']] : info['func'];
              if (typeof (func)) func.call(window, settings.login);
              return ERR_OK;
            }
            return ERR_SYNTAX;
          }


          if (params.length == 0) {
            if (!('params' in info)) return execute_simple();

          } else {
            if ('params' in info) {
              var param_val = info.params.exec(params.join(' '));
              if (param_val !== null) {
                if ('url' in info) {
                  if (need_auth(info)) return ERR_AUTH;

                  var u = info['url'];
                  for (var i = 1; i < param_val.length; i++) {
                    u = u.replace('$' + i, encodeURIComponent(param_val[i]));
                  }
                  if (u.indexOf('$login') !== -1) u = u.replace('$login', encodeURIComponent(settings.login));
                  redirect(u);
                  return ERR_OK;

                } else if ('func' in info) {
                  if (need_auth(info)) return ERR_AUTH;
                  var func = (info['func'] in window) ? window[info['func']] : info['func'];
                  if (typeof (func)) func.apply(window, param_val.slice(1));
                  return ERR_OK;
                }
              }

            } else {
              var cmp = ('command' in info) ? info['command'] : (('syntax' in info) ? info['syntax'] : '');
              if (cmp == command.toUpperCase()) return execute_simple();
            }
          }
          return ERR_SYNTAX;
        }

        var res = ERR_UNKNOWN;
        if ('variants' in settings.commands[cmd]) {
          try {
            $.each(settings.commands[cmd]['variants'], function (i, v) {
              res = execute(v, cmd);
              if ((res === ERR_OK) || (res === ERR_AUTH)) throw true;
            });

          } catch (e) { }
        } else {
          res = execute(settings.commands[cmd], cmd);
        }

        if (res !== ERR_OK) {
          need_help(cmd, $('<div class="console_error">' + err_msg[res] + '</div>'));
          return false;
        } else {
          notifyStat(cmd);
          return true;
        }

      } else if ((cmd === 'HELP') || (cmd === '')) {
        document.location = '/page/help/';
        return true;
      } else {
        // Неизвестная команда
        document.location = '/search/topics/?q=' + encodeURIComponent(command);
        return true;
      }
      return false;
    };


    input.on('keydown', function (e) {
      switch (e.which) {
        case 27:
          {
            if (autocomplete.box.css('display') != 'none') {
              autocomplete_close();
              e.preventDefault();

            } else if (combo.css('display') != 'none') combo.slideToggle('fast');
            break;
          }

        case 13:
          {
            if ((autocomplete.box.css('display') == 'none') && (combo.css('display') == 'none')) {
              e.preventDefault();

              if ('combo_timer' in settings) {
                clearTimeout(settings.combo_timer);
                delete settings.combo_timer;
              }

              if (command_func($(this).val().replace(/^\s+/, ''))) $(this).val('');
              break;

            }

            // тут идет проверка на открытый попап
          }
        case 38:
        case 40:
          {
            if (autocomplete.box.css('display') != 'none') {
              e.preventDefault();
              autocomplete.box.trigger(jQuery.Event('keypress', { keyCode: e.which }));

            } else if (combo.css('display') != 'none') {
              e.preventDefault();
              combo.trigger(jQuery.Event('keypress', { keyCode: e.which }));
            }
            break;
          }

        default:
          {
            setTimeout(function (e) {
              if (!autocomplete_open()) need_help(input.val());

            }, 1);
            break;
          }
      }

    }).on('change', function (e) {
      need_help($(this).val());

    }).on('command', function (e) {
      if ('fromPopup' in e) {
        if (e.fromPopup == autocomplete.box) {
          if (autocomplete.box.css('display') != 'none') autocomplete_done(e.message);

        } else if (e.fromPopup == combo) {
          if (combo.css('display') != 'none') {
            var cmd = e.message; //$.trim(); - you should not do this
            var command = $(this).val().replace(/^\s+/, '');

            var command_cmd = command.split(' ').shift().toUpperCase();
            if (command_cmd[0] == '$') command_cmd = '$';

            if (command_cmd in settings.aliases) {
              command = settings.aliases[command_cmd] + command.substr(command_cmd.length);
              command_cmd = settings.aliases[command_cmd].toUpperCase();
            }


            if (command.substr(0, cmd.length).toUpperCase() == cmd.toUpperCase()) {
              if (command_cmd in settings.commands) {
                if (command.length > cmd.length) {
                  if (command_func($(this).val())) $(this).val('');
                } else {
                  var variants = ('variants' in settings.commands[command_cmd]) ? settings.commands[command_cmd]['variants'] : [settings.commands[command_cmd]];
                  var input = $(this);
                  var bExec = false;

                  $.each(variants, function (i, v) {
                    bExec = false;
                    if (!('params' in v)) {
                      if ('command' in v) {
                        if (v['command'].toUpperCase() == command.toUpperCase()) bExec = true;

                      } else if ('syntax' in v) {
                        if (v['syntax'].toUpperCase() == command.toUpperCase()) bExec = true;

                      } else if (command_cmd == cmd) bExec = true;
                    }

                    if (bExec) {
                      if (command_func(input.val())) input.val('');
                      return false;
                    }
                  });

                  if (!bExec) {
                    $(this).val(cmd);
                    need_help($(this).val());
                  }
                }

              } else {
                $(this).val(cmd);
                need_help($(this).val());
              }
            } else {
              $(this).val(cmd);
              need_help($(this).val());
            }
          }
        }
      }

    }).on('blur', function (e) {
      if (autocomplete.box.css('display') != 'none') {
        if (!autocomplete.box.attr('mouse_pressed')) autocomplete_close();
      }

      if (combo.css('display') != 'none') {
        if (!combo.attr('mouse_pressed')) combo.slideToggle('fast');
      }
      tooltip_help('');

    }).on('focus', function (e) {
      if (!$.trim($(this).val())) {
        tooltip_help('Напишите, что вы ищете или воспользуйтесь подсказками внизу');
        need_help('', '');
      } else {
        need_help($(this).val());
      }
    });

    combo.on('click', 'span.helplink, span.authlink', function (e) {
      if ($(this).hasClass('helplink')) {
        input.val($(this).text()).focus();
        need_help($(this).text());

      } else if ($(this).hasClass('authlink')) {
        if ('login_url' in settings) document.location = settings.login_url;
      }
    });

    combo.smart_console_dropdown({
      parent: input, filler: function (mode, item) {
        switch (mode) {
          case 'help':
            {
              return $('<div><span class="helplink" title="' + item.c + '">' + item.l + '</span> &mdash; <span>' + item.t + '</span>' + (item.a ? ' [<span class="authlink">Необходима авторизация</span>]' : '') + '</div>');
            }

          case 'help_reverse':
            {

              var link = ('oc' in item) ? item.s.replace(item['oc'], '<span class="helplink"' + (('c' in item) ? ' title="' + item.c + '"' : '') + '>' + item['oc'] + '</span>') : '<span class="helplink"' + (('c' in item) ? ' title="' + item.c + '"' : '') + '>' + item.s + '</span>';
              return $('<div><span>' + item.t + '</span> ' + link + (item.a ? ' [<span class="authlink">Необходима авторизация</span>]' : '') + '</div>');
            }

          default:
            {
              return null;
            }
        }

      }
    });

    if (autocomplete.box === null) {
      autocomplete.box = $('<div class="console_acc_menu"></div>').hide();
      autocomplete.box.insertAfter(input);
      autocomplete.box.smart_console_dropdown({
        parent: input, filler: function (mode, item) {
          switch (mode) {
            case 'book':
              {
                return $('<div class="dbi"><div class="dbdd"><div>' + item.t + '</div><div>' + item.c + '</div></div></div>');
              }
            case 'wiki':
            case 'tag':
              {
                return $('<div class="dbi"><div class="dbst"><div>' + item.t + '</div></div></div>');
              }
            case 'symbol':
              {
                return $('<div class="dbi"><div class="dbsb"><div>' + item.l + '</div><div>' + item.t + '</div></div></div>');
              }
            default:
              {
                return $('<div class="dbi"><div class="dbid"><img src="' + item.i + '" /></div><div class="dbdd"><div>' + item.t + '</div><div>' + item.c + '</div></div></div>');
              }
          }

        }
      });
    }

    return self;
  };

})(jQuery);
;
(function ($) {


  $.fn.smart_console_dropdown = function (options) {
    var self = this;

    options = options || {};
    var settings = {

      filler: null,
      parent: null
    };

    if (options) $.extend(settings, options);

    this.on('mousedown', '> div', function (e) {
      $('> div', self).removeClass('hilited');
      $(this).addClass('hilited');

      self.attr('mouse_pressed', true);

    }).on('mouseup', '> div', function (e) {
      if (self.attr('mouse_pressed')) {
        self.removeAttr('mouse_pressed');
        settings.parent.trigger({ type: 'command', fromPopup: self, message: $(this).attr('unique') });
        settings.parent.focus();
      }

    }).on('reset', function (e) {
      e.preventDefault();

      var selected = $('.hilited', self).attr('unique');
      self.empty();
      self.attr('mode', e.message.mode);

      $.each(e.message.items, function (i, v) {
        var d = settings.filler(e.message.mode, v);
        d.attr('unique', v.l);
        self.append(d);
      });

      if (typeof (selected) != 'undefined') self.find('[unique="' + selected + '"]').first().addClass('hilited');
      if (!self.find('.hilited').length) self.find('> div').first().addClass('hilited');

    }).on('keypress', function (e) {
      switch (e.keyCode) {
        case 38: //up
          {
            var i = self.find('.hilited');
            self.find('> div').removeClass('hilited');
            ((i.prev().length) ? i.prev() : self.find('> div:last')).addClass('hilited');
            break;
          }

        case 40: // down
          {
            var i = self.find('.hilited');
            self.find('> div').removeClass('hilited');
            ((i.next().length) ? i.next() : self.find('> div:first')).addClass('hilited');
            break;
          }

        case 13: // enter
          {
            var selected = self.find('.hilited');
            settings.parent.trigger({ type: 'command', fromPopup: self, message: selected.length ? selected.attr('unique') : null });
            settings.parent.focus();
            break;
          }
      }

      // visible item ?
      if (self.find('.hilited').length) {
        var i = self.find('.hilited').get(0);
        var s = self.get(0);

        var ifrom = i.offsetTop;
        var from = s.scrollTop;
        var to = s.scrollTop + s.clientHeight;

        if (from - ifrom > 0) s.scrollTop -= from - ifrom;
        if (to - (ifrom + i.clientHeight) < 0) s.scrollTop -= to - (ifrom + i.clientHeight);
      }
    });
  };

})(jQuery);;
var console_commands = {
  'FIND': {
    title: 'Поиск', variants:
      [
        { title: 'Поиск по финсловарю', start_title: 'По словарю', command: 'FIND F ', syntax: 'FIND F искомое', params: /^F\s(.*)$/i, ac: /^F\s([^@]+)$/i, act: 'wiki', url: '/search/results/?q=$1&in=articles', tooltip: 'Введите слово' },
        { title: 'Поиск книг', start_title: 'Книгу', command: 'FIND B ', syntax: 'FIND B искомое', params: /^B\s(.*)$/i, ac: /^B\s([^@]+)$/i, act: 'book', url: '/books/book_search?q=$1', tooltip: 'Введите название книги', keywords: 'искать книгу,найти книгу' },
        { title: 'Поиск людей', start_title: 'Людей', command: 'FIND @', syntax: 'FIND @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)$/i, url: '/search/results/?q=$1&in=users', tooltip: 'Введите логин или имя', keywords: 'искать человека,найти человека' },
        { title: 'Поиск по блогам', start_title: 'Текст в блогах', command: 'FIND ', syntax: 'FIND искомое', params: /^(.*)$/, url: '/search/results/?q=$1&in=topics', tooltip: 'Введите текст', keywords: 'искать текст,найти текст' }, // ac: /^([^@]+)$/i, act: 'tag',
        { title: 'Поиск записей трейдера в блогах', command: 'FIND ', syntax: 'FIND искомое@login', params: /^(.*)$/, ac: /(.+)\@(.*)$/i, url: '/search/results/?q=$1&in=topics' }
      ]
  },
  'BLOG': {
    title: 'Блог', variants:
      [
        { title: 'Ваш блог', url: '/my/$login/blog/', auth_required: true, keywords: 'мой блог' },
        { title: 'Блог Романа Андреева', syntax: 'BLOG @RomanAndreev', redirect_url: '/my/RomanAndreev/blog/', keywords: 'Роман Андреев' },
        { title: 'Блог пользователя', start_title: 'Блоги людей', command: 'BLOG @', syntax: 'BLOG @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)/i, url: '/my/$1/blog/', tooltip: 'Введите логин или имя' }
      ]
  },
  'TAG': { title: 'Записи по тегу', start_title: 'Теги', command: 'TAG ', syntax: 'TAG тег', params: /^(.*)$/, ac: /^(.*)/i, act: 'tag', url: '/tag/$1/', tooltip: 'Введите тег' },
  'MSG': {
    title: 'Личная переписка', auth_required: true, variants:
      [
        { title: 'Личное сообщение', command: 'MSG @', syntax: 'MSG @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)$/i, func: 'mailto_func', auth_required: true, keywords: 'личное сообщение,написать сообщение,сообщение написать', tooltip: 'Введите имя кому' }
      ]
  },

  'ALL': { title: 'Все блоги подряд', command: 'ALL', syntax: 'ALL или BLOGS', redirect_url: '/allblog/', keywords: 'лента всех постов' },
  'ECO': { title: 'Календарь всех событий', redirect_url: '/calendar/', keywords: 'календарь' },
  'WIKI': {
    title: 'Финансовый словарь', variants:
      [
        { title: 'Финансовый словарь', redirect_url: '/finansoviy-slovar/', keywords: 'словарь' },
        { title: 'Написать статью в словарь', syntax: 'WIKI ADD', redirect_url: '/finansoviy-slovar/add/', auth_required: true, keywords: 'написать статью в словарь' },
        { title: 'Поиск в финсловаре', command: 'WIKI ', syntax: 'WIKI искомое', params: /^(.*)$/, ac: /^(.*)/i, act: 'wiki', url: '/finansoviy-slovar/$1' }
      ]
  },
  'G': {
    title: 'Графики онлайн', variants:
      [
        { title: 'Графики любых инструментов', start_title: 'График', redirect_url: '/g/', keywords: 'график' },
        { title: 'Графики онлайн', command: 'G ', syntax: 'G ticker timeframe', params: /^([0-9a-z]+)(?:\s(\d+|D|W|M))?$/i, ac: /^([A-Z]+)/i, act: 'symbol', url: '/g/$1/$2/', tooltip: 'Введите тикер инструмента' }
      ]
  },

  'Q': {
    title: 'Котировки', variants:
      [
        { title: 'Котировки акций на МосБирже', redirect_url: '/q/shares/', keywords: 'акции котировки,котировки акций,курс акций' },
        { title: 'Перейти на форум акции', command: 'Q ', syntax: 'Q ticker-акции', params: /^(.*)$/, ac: /^(.*)/i, act: 'forum', url: '/forum/company_go/$1/' } // params: /^([0-9a-z]+)$/i,
      ]
  },

  'OIL': { title: 'Нефть: график, запасы, новости', redirect_url: '/oil/', keywords: 'нефть' },
  'B': { title: 'Каталог книг', redirect_url: '/books/', keywords: 'книги' },
  'TOP': { title: 'Лучше посты смартлаба', redirect_url: '/top/', keywords: 'лучшие посты,рейтинг постов' },
  'SGNL': { title: 'Лента торговых сигналов', redirect_url: '/blog/tradesignals/', keywords: 'лента сигналов,сигналы,торговые сигналы' },
  'TAGS': { title: 'Список всех тегов', redirect_url: '/tags/', keywords: 'теги все' },
  'CORP': {
    title: 'Корпоративные блоги', variants:
      [
        { title: 'Корпоративные блоги', redirect_url: '/company/', keywords: 'брокеры блоги,корпоративные блоги' },
        { title: 'Создать корпоративный блог', syntax: 'CORP ADD', redirect_url: '/company/add/', keywords: 'корпоративный блог создать,создать корп блог' },
        { title: 'Корпоративный блог компании', command: 'CORP ', syntax: 'CORP название', params: /^(.*)$/, ac: /^(.*)$/i, act: 'company', url: '/company/$1/' }
      ]
  },

  '$': { title: 'Форум компании', start_title: 'Акции компаний', command: '$', syntax: '$название или тикер', params: /^(.*)$/, ac: /^(.*)/i, act: 'forum$', url: '/forum/company_go/$1/', tooltip: 'Введите название компании', keywords: 'искать компанию,найти акцию компании' }, // hardcoded

  'FAV': {
    title: 'Избранное', variants:
      [
        { title: 'Ваши избранные посты', url: '/profile/$login/favourites/', auth_required: true, keywords: 'избранное мое,мое избранное' },
        { title: 'Избранное пользователя', command: 'FAV @', syntax: 'FAV @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)$/i, url: '/profile/$1/favourites/', tooltip: 'введите имя чтобы посмотреть избранное', keywords: 'избранное человека' }
      ]
  },

  'FRND': {
    title: 'Френдлента', variants:
      [
        { title: 'Ваша лента друзей', url: '/friends/$login/', auth_required: true, keywords: 'лента друзей,френдлента' },
        { title: 'Френдлента пользователя', command: 'FRND @', syntax: 'FRND @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)$/i, url: '/friends/$1/' }
      ]
  },

  'LINKS': {
    title: 'Ссылки', variants:
      [
        { title: 'Ваши сохраненные ссылки', url: '/my/$login/tree/links/', auth_required: true, keywords: 'избранные ссылки,мои ссылки' },
        { title: 'Ссылки пользователя', command: 'LINKS @', syntax: 'LINKS @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)$/i, url: '/my/$1/tree/links/' }
      ]
  },

  'CMT': {
    title: 'Комментарии', variants:
      [
        { title: 'Ваши комментарии', url: '/my/$login/comment/', auth_required: true, keywords: 'комментарии мои,мои комментарии' },
        { title: 'Комментарии пользователя', command: 'CMT @', syntax: 'CMT @login', params: /^\@([0-9a-z\_\-]+)$/i, ac: /^\@(.*)$/i, url: '/my/$1/comment/' }
      ]
  },


  'TV': { title: 'Лента всех видео', redirect_url: '/smartlab-tv/', keywords: 'видео на смартлабе' },
  'POST': { title: 'Написать пост в свой блог', redirect_url: '/topic/add/', auth_required: true, keywords: 'написать пост,пост написать' },
  'ACC': { title: 'Статистика вашего счета', redirect_url: '/my-trading-account/', auth_required: true, keywords: 'мой счет,статистика счета' },
  'MAIL': {
    title: 'Личная переписка', auth_required: true, variants:
      [
        { title: 'Личная переписка', command: 'MAIL', syntax: 'MAIL или PM', redirect_url: '/talk/', auth_required: true },
        { title: 'Написать письмо', command: 'MAIL TO @', syntax: 'MAIL TO @login', params: /^TO\s\@([0-9a-z\_\-]+)$/i, ac: /^TO\s\@(.*)$/i, func: 'mailto_func', auth_required: true }
      ]
  },

  'CCI': { title: 'Индексы доверия смартлаба', redirect_url: '/consumer-confidence-russia/' },
  'CHAT': { title: 'Секретный клуб', redirect_url: '/chat/', hidden: true },
  'CAT': { title: 'Каталог финансовых услуг', redirect_url: '/page/catalog/' },
  'ADV': { title: 'Размещение рекламы', redirect_url: 'https://smart-lab.ru/blog/mytrading/7053.php' },
  'MAIN': { title: 'Перекидывает на главную', redirect_url: '/' },
  'FINAM': { title: 'Сайт Финам', redirect_url: 'http://www.finam.ru/' },
  'MAP': { title: 'Тепловая карта рынка, форума и блогов', redirect_url: '/q/map/', keywords: 'акции карта рынка,карта рынка' },
  'FLOW': { title: 'Все блоги одним потоком', redirect_url: '/flow/', keywords: 'поток постов всех блогов' },
  'FXPF': { title: 'Графики-онлайн на Forexpf', redirect_url: 'http://www.forexpf.ru/chart/' },
  'NEWS': {
    title: 'Новости по российским акциям', variants:
      [
        { title: 'Все новости', redirect_url: '/news/', keywords: 'лента новостей,новости' },
        { title: 'Новости по Сбербанку', syntax: 'NEWS $SBER', redirect_url: '/forum/news/SBER/' },
        { title: 'Новости по любой компании', syntax: 'NEWS $TICKER', params: /^\$([0-9a-z\_\-]+)$/i, ac: /^\$(.*)$/i, act: 'forum', url: '/forum/$1/attached/' }
      ]
  },
  'OFFTOP': {
    title: 'Оффтоп', variants:
      [
        { title: 'Посмотреть раздел ОФФТОП', redirect_url: '/blog/offtop/', keywords: 'оффтоп раздел' },
        { title: 'Написать пост не по теме смартлаба', syntax: 'OFFTOP ADD', redirect_url: '/topic/add/?blog_id=4107', keywords: 'написать в оффтоп,оффтоп написать', auth_required: true }
      ]
  },
  'EVENTS': { title: 'Календарь тусовок', redirect_url: '/calendar/index/party/' },
  'SWITCH': {
    title: 'Переключить цветовую схему сайта', auth_required: true, variants:
      [
        { title: 'Стандартная тема', syntax: 'SWITCH BLACK', redirect_url: '/settings/theme/black', auth_required: true },
        { title: 'Белая тема', syntax: 'SWITCH WHITE', redirect_url: '/settings/theme/white', auth_required: true, keywords: 'сделать смартлаб белым' },
        { title: 'Полностью черная тема', syntax: 'SWITCH FULLBLACK', redirect_url: '/settings/theme/fullblack', auth_required: true, keywords: 'сделать смартлаб полностью черным' },
        { title: 'Оригинальная тема', syntax: 'SWITCH ORIGINAL', redirect_url: '/settings/theme/original', auth_required: true, keywords: 'сделать смартлаб в старой теме' }
      ]
  },
  'LINK': { title: 'Переход по спец-ссылке', command: 'LINK ', syntax: 'LINK name', params: /^(.*)$/, url: '/console/link/$1/' },
  'EXIT': { title: 'Разлогиниться', redirect_url: '/login/exit/', auth_required: true },


  'STOCKS': { title: 'Форум по акциям', redirect_url: '/forum/', keywords: 'акции форум,форум акций' },
  'BONDS': { title: 'Форум по облигациям', redirect_url: '/bonds/', keywords: 'форум облигаций' },
  'FX': { title: 'Форум по Forex', redirect_url: '/forex/', keywords: 'форекс,форум forex' },
  'BANKS': { title: 'Форум по банкам', redirect_url: '/banki/', keywords: 'форум банков' },
  'OPT': { title: 'Форум по опционам', redirect_url: '/options/', keywords: 'опционы форум' },
  'ALGO': { title: 'Форум по торговым роботам', redirect_url: '/algotrading/', keywords: 'алготрейдинг форум,торговые роботы форум' },
  'BROK': { title: 'Рейтинг брокеров и отзывы', redirect_url: '/brokers-rating/', keywords: 'брокеры,выбрать брокера,рейтинг брокеров' },

  'ECOS': { title: 'Календарь событий по акциям', redirect_url: '/calendar/stocks/', keywords: 'акции календарь,календарь акций' },
  'FA': { title: 'Фундаментальный анализ акций', redirect_url: '/q/shares_fundamental/', keywords: 'акции фунд.анализ,мультипликаторы компаний,фундаментальный анализ акций' },
  'QBO': { title: 'Котировки облигаций', redirect_url: '/q/ofz/', keywords: 'бонды котировки,котировки ОФЗ,облигации ОФЗ,ОФЗ' },
  'BROKG': { title: 'Рейтинг глобальных брокеров', redirect_url: '/brokers-rating/global/', keywords: 'брокеры Глобальные' },
  'BROKR': { title: 'Рейтинг российских брокеров', redirect_url: '/brokers-rating/russia/', keywords: 'брокеры Россия' },
  'BROKF': { title: 'Рейтинг форекс брокеров', redirect_url: '/brokers-rating/forex/', keywords: 'брокеры Forex' },
  'ASK': { title: 'Задать вопрос на смартлабе', redirect_url: '/vopros/add/', keywords: 'вопрос задать,задать вопрос', auth_required: true },
  'ANSWER': { title: 'Лента всех вопросов', redirect_url: '/vopros/', keywords: 'вопросы лента,лента вопросов,ответы на вопросы' },
  'W': {
    title: 'Ваши портфели (portfolio)', auth_required: true, variants: [
      { title: 'Ваш портфели (portfolio)', command: 'W', redirect_url: '/q/portfolio', keywords: 'портфолио,мое портфолио,портфель,списки акций мои,portfolio', auth_required: true },
      { title: 'Создать портфель', command: 'W ADD', syntax: 'W ADD', func: 'new_portfolio_func', keywords: 'создать портфель,создать портфолио', auth_required: true },
    ]
  },
  'DIV': { title: 'Таблица дивидендов и даты отсечек', redirect_url: '/dividends/', keywords: 'дивиденды,закрытие реестров дивиденды,календарь дивидендов,реестр дивидендов' },
  'DIVR': { title: 'Информация о поступивших дивидендах', redirect_url: '/forum/Поступление%20дивидендов/', keywords: 'дивиденды поступление,поступление дивидендов' },

  'QBE': { title: 'Котировки еврооблигаций', redirect_url: '/q/eurobonds/', keywords: 'еврооблигации,котировки еврооблигаций' },
  'REG': { title: 'Календарь отсечек по акциям', redirect_url: '/calendar/index/stocks_otsechka', keywords: 'закрытие реестров календарь' },
  'PICS': { title: 'Лента всех картинок', redirect_url: '/pics/', keywords: 'картинки,лента картинок' },
  'BR': {
    title: 'Книжные рецензии', variants: [

      { title: 'Лента книжных рецензий', syntax: 'BR', redirect_url: '/blog/reviews/', keywords: 'книги рецензии,рецензии книг' },
      { title: 'Написать отзыв к книге', syntax: 'BR ADD', redirect_url: '/review/add/', keywords: 'написать рецензию на книгу,рецензия написать', auth_required: true }
    ]
  },

  'TOPB': { title: '100 лучших книг', redirect_url: '/books/top/', keywords: 'книги топ-100,рейтинг книг' },
  'CMTS': { title: 'Лента всех комментариев', redirect_url: '/comments/', keywords: 'комментарии все,лента комментариев' },
  'CMTME': { title: 'Комментарии к вашим постам', redirect_url: '/my/$login/comment-to-me/', auth_required: true, keywords: 'комментарии к моим постам' },
  'QA': { title: 'Котировки АДР', redirect_url: '/q/adr/', keywords: 'котировки АДР' },
  'QW': { title: 'Котировки мировых индексов и Forex', redirect_url: '/q/world-quotes/', keywords: 'котировки мировые,курсы валют' },
  'QBC': { title: 'Котировки корпоративных облигаций', redirect_url: '/q/bonds/', keywords: 'котировки облигаций корп,облигации корпоративные' },
  'QBS': { title: 'Котировки облигаций субъектов РФ', redirect_url: '/q/subfed/', keywords: 'котировки облигаций субфед,облигации субъектов' },
  'QR': { title: 'Котировки валютного рынка Мосбиржи', redirect_url: '/q/currencies/', keywords: 'котировки рубля,курсы рубля' },
  'QF': { title: 'Котировки срочного рынка Мосбиржи', redirect_url: '/q/futures/', keywords: 'котировки фьючерсов' },
  'FORUMS': { title: 'Все записи форумов подряд', redirect_url: '/forums/', keywords: 'лента форумов,форумы лента' },
  'READS': { title: 'Самые полезные статьи (выбор редактора)', redirect_url: '/tradingreads/', keywords: 'лучшие статьи за все время,нетленка,трейдинг лучшие статьи' },
  'PEOPLE': { title: 'Все пользователи смартлаба', redirect_url: '/people/', keywords: 'люди,рейтинг блогеров,трейдеры все' },
  'MOB': { title: 'Переключиться на мобильную версию', redirect_url: '/mobile/', keywords: 'мобильная версия' },
  'BL': { title: 'Ваш черный список', redirect_url: '/blacklist/', keywords: 'мой черный список,черный список,чс', auth_required: true },
  'FORUMMY': { title: 'Ваши сообщения на форумах', redirect_url: '/my/$login/comment-forum/', keywords: 'мои сообщения на форуме', auth_required: true },
  'BOOKSDONE': { title: 'Книги, которые вы прочли и оценили', redirect_url: '/books/reviewed_by/$login/', keywords: 'мои прочитанные книги', auth_required: true },
  'REPORTS': { title: 'Таблица последних отчетов по МСФО', redirect_url: '/q/shares_fundamental3?&type=MSFO', keywords: 'мсфо' },
  'SETPROFILE': { title: 'Настройки вашего профиля', redirect_url: '/settings/profile/', keywords: 'настройки профиля', auth_required: true },
  'SETTINGS': { title: 'Настройки ваших уведомлений', redirect_url: '/settings/notifications/', keywords: 'настройки уведомлений', auth_required: true },
  'QBI': { title: 'Индексы российских облигаций', redirect_url: '/q/index_bonds/', keywords: 'облигации индексы' },
  'ECOB': { title: 'Календарь событий по облигациям', redirect_url: '/calendar/bonds/', keywords: 'облигации календарь' },

  'POLL': {
    title: 'Опросы', variants: [

      { title: 'Создайте опрос', syntax: 'POLL ADD', redirect_url: '/question/add/', keywords: 'опрос создать', auth_required: true }

    ]
  },

  'REPLY': { title: 'Ответы на мои комментарии', redirect_url: '/my/$login/reply-to-me/', keywords: 'ответы на мои комментарии', auth_required: true },
  'FREPLY': { title: 'Ответы мне на форуме', redirect_url: '/my/$login/reply-to-me-forum/', keywords: 'ответы мне на форуме', auth_required: true },
  'RULES': { title: 'Правила смартлаба', redirect_url: '/blog/mytrading/5161.php', keywords: 'правила смартлаба' },
  'FORUMERS': { title: 'Рейтинг участников форума', redirect_url: '/people/all/order_by_stocks/desc/', keywords: 'рейтинг форумчан' },
  'READERS': { title: 'Рейтинг читателей книг', redirect_url: '/people/all/order_by_books/desc/', keywords: 'рейтинг читателей' },
  'RAS': { title: 'Таблица последних отчетов по РСБУ', redirect_url: '/q/shares_fundamental3?&type=RSBU', keywords: 'рсбу' },
  'SOFT': { title: 'Форум софта для трейдинга', redirect_url: '/trading-software/', keywords: 'торговый софт' },









};

var console_aliases = { '1': 'POST', '2': 'BLOG', '3': 'CMT', '4': 'LINKS', '5': 'FAV', '6': 'ACC', '7': 'FRND', 'BLOGS': 'ALL', 'PM': 'MAIL', '/': 'MAIN', 'PPL': 'PEOPLE' };
window['mailto_func'] = function (login) {
  window.open('/talk/add/?talk_users=' + encodeURIComponent(login), '_blank');
};


window['new_portfolio_func'] = function (login) {
  if (!('cachedScript' in jQuery)) {
    jQuery.cachedScript = function (url, options) {
      // Allow user to set any option except for dataType, cache, and url
      options = jQuery.extend(options || {},
        {
          dataType: "script",
          cache: true,
          url: url
        });
      // Use $.ajax() since it is more flexible than $.getScript
      // Return the jqXHR object so we can chain callbacks
      return jQuery.ajax(options);
    };
  }

  jQuery.cachedScript('/plugins/trade/templates/skin/default/actions/ActionQ/js/portfolio.js').done(function (script, textStatus) {
    var od = $;
    $ = jQuery;
    AddPortfolioEvent('Создание нового списка', 'add_list').then(function (sMsgTitle, sMsg, iListId, sListTitle) {
      msgNoticeBox.alert(sMsgTitle, sMsg);
      if (typeof (CURRENT_USER_LOGIN) != 'undefined') {
        setTimeout(function (e) {
          document.location.href = '/q/portfolio/' + encodeURIComponent(CURRENT_USER_LOGIN) + '/' + iListId + '/';
        }, 1000);
      }

    }, function (sMsgTitle, sMsg) {
      msgErrorBox.alert(sMsgTitle, sMsg);

    }).always(function () {
      $ = od;
    });
  });
};
(function ($) {
  $(document).ready(function () {
    var symbols = [];
    function success(data) {
      //console.log(data.short_name, data.original_name);
      var tr = $('.trade tr[tkr="' + data.original_name.replace(':', '.') + '"]');
      if (tr.length) {
        var chg = (Math.round(parseFloat(data.change_percent) * 10) / 10);
        var val = parseFloat(data.last_price);

        switch (data.original_name) {
          case 'CME_MINI_DL:ES1!':
          case 'BITSTAMP:BTCUSD':
          case 'FX_IDC:USDRUB':
          case 'FX_IDC:XAUUSD':
            {
              val = val.toFixed(1);
              break;
            }

          case 'FX:USDJPY':
          case 'FX_IDC:USDBRO':
          case 'FX_IDC:XAGUSD':
            {
              val = val.toFixed(2);
              break;
            }

          case 'EUSTX50':
          case 'UK100':
          case 'OANDA:DE30EUR':
          case 'FRA40':
          case 'SHCOMP':
          case 'ESP35':
          case 'OANDA:JP225USD':
          case 'OANDA:EU50EUR':
          case 'AUS200':
            {
              val = val.toFixed(0);
              break;
            }

          case 'OANDA:CN50USD':
            {
              val = Math.round(data.last_price);
              break;
            }

          default:
            {
              val = val.toFixed(4);
              break;
            }
        }


        $($('td', tr)[1]).text(val.toString().replace('.', ','));
        $($('td', tr)[2]).text(((chg > 0) ? '+' : '') + chg.toString().replace('.', ',') + '%');
        if (chg < 0) {
          $($('td', tr)[2]).addClass('down');

        } else {
          $($('td', tr)[2]).removeClass('down');
        }
      }
    }

    if ($('.trades').length) {
      $.ajax({ url: 'https://dwq4do82y8xi7.cloudfront.net/static/js/tv.js', dataType: 'script', cache: true }).done(function () {
        $('.trade tr[tkr]').each(function (i, el) {
          symbols.push({ 'symbol': ($(el).attr('tkr')).replace('.', ':'), success: success, error: function () { } });
        });

        if (symbols.length) {
          new TradingView.QuotesProvider({ container_id: 'hif', symbols: symbols });
        };
      });
    }
  });

})(jQuery);
(function (b) {
  function a() {
    b('<div id="abuse_dialog_tpl" style="display: none;"><div id="abuse_dialog"><fieldset class="abuse_title"><legend>Текст жалобы (до 60 символов):</legend><textarea id="abuse_text" maxlength="64"></textarea></fieldset></div></div>').appendTo(b("body"));
    var c = b("#abuse_dialog"); function d(g, h) {
      var f = { topic: "топик", comment: "комментарий", profile: "профиль" }; var e = new jBox("Confirm", {
        id: "abuseDialog", title: "Пожаловаться на " + (h in f ? f[h] : " жизнь"), confirmButton: "ОК", cancelButton: "Отмена", content: c, confirm: function () {
          var j = this;
          var k = { targetId: g, targetType: h, security_ls_key: LIVESTREET_SECURITY_KEY }; var i = c.find("textarea#abuse_text"); if (i.length) { k.text = i.val(); } b.post("/abuse/abuse_ajax/", k, function (l, m) {
            if (!l) {
              msgErrorBox.alert("Error", "Please try again later");
            } if (l.bStateError) { msgErrorBox.alert(l.sMsgTitle, l.sMsg); } else { msgNoticeBox.alert(l.sMsgTitle, l.sMsg); }
          });
        }, onOpen: function () {
          var i = c.find("textarea#abuse_text");
          i.val("");
        }, onCloseComplete: function () { this.destroy(); }
      }); e.open();
    } window.abuse = d;
  } b(document).ready(function () {
    if (typeof (CURRENT_USER_ID) !== "undefined") {
      a();
    }
  });
})(jQuery);
(function (a) {
  a(document).ready(function () {
    window.ban = function (h) {
      var f = a("#user_ban_dialog"); var g = {
        id: "userBanDialog", title: "Предупреждение пользователя", confirmButton: "ОК", cancelButton: "Отмена", content: f, confirm: function () {
          var i = this;
          var m = { userLogin: h, security_ls_key: LIVESTREET_SECURITY_KEY }; var l = f.find('input[name="time"]'); l.each(function (o, n) { if (n.checked) { m.time = n.value; } }); var j = f.find('input[name="time_value"]');
          if (j.length) { m.time_value = j.val(); } var k = f.find('input[name="reason"]'); k.each(function (o, n) { if (n.checked) { m.reason = n.value; } }); var j = f.find('input[name="reason_value"]');
          if (j.length) { m.reason_value = j.val(); } a.ajax({ url: "/profile/ajaxwarning/", type: "POST", data: m }).then(function (n) {
            if (!n) {
              msgErrorBox.alert("Error", "Please try again later");
            } if (n.bStateError) { msgErrorBox.alert(n.sMsgTitle, n.sMsg); } else { document.location.reload(); }
          });
        }, onOpen: function () {
          var i = f.find('input[name="time"]'); i.each(function (l, k) {
            k.checked = false;
          }); i[0].checked = true; var j = f.find('input[name="reason"]'); j.each(function (l, k) { k.checked = false; }); j[10].checked = true; f.on("click", function (k) {
            f.find('input[name="time"]').each(function (m, l) {
              if (l.checked) {
                var n = f.find('input[name="time_value"]');
                if (n.length) { n[0].disabled = (l.value != "limited"); }
              }
            }); f.find('input[name="reason"]').each(function (m, l) {
              if (l.checked) {
                var n = f.find('input[name="reason_value"]');
                if (n.length) { n[0].disabled = (l.value != "0"); }
              }
            });
          });
        }, onClose: function () { f.off("click"); }, onCloseComplete: function () { this.destroy(); }
      }; var e = null; a.ajax({ url: aRouter.profile + "ajaxwarning/", type: "GET", data: { userLogin: h, security_ls_key: LIVESTREET_SECURITY_KEY } }).then(function (i) {
        if (!i.bStateError) {
          if (a("#user_ban_dialog_tpl").length) {
            a("#user_ban_dialog_tpl").remove();
          } a("body").append(a(i.sHtml)); f = a("#user_ban_dialog"); g.content = f; e = new jBox("Confirm", g); e.open();
        } else { msgErrorBox.alert(i.sMsgTitle, i.sMsg); }
      });
    }; window.unban = window.unwarn = function (e) {
      var f = { userLogin: e, security_ls_key: LIVESTREET_SECURITY_KEY };
      a.ajax({ url: "/profile/ajaxwarningclear/", type: "POST", data: f }).then(function (g) {
        if (!g) { msgErrorBox.alert("Error", "Please try again later"); } if (g.bStateError) {
          msgErrorBox.alert(g.sMsgTitle, g.sMsg);
        } else {
          if (g.sMsgTitle) { msgNoticeBox.alert(g.sMsgTitle, g.sMsg); setTimeout(function () { document.location.reload(); }, 1000); } else {
            document.location.reload();
          }
        }
      });
    }; var c = a("#login_pn"); if (c) {
      var d = a('<span title="IP адреса пользователя">(X)</span>').css({ display: "inline-block", verticalAlign: "middle", marginLeft: "1em", cursor: "pointer", color: "#868894", fontSize: "16px", fontWeight: "normal" }).click(function (g) {
        g.preventDefault();
        var f = a("#login_ipn"); if (f) { f.css("display", (f.css("display") == "block") ? "none" : "block"); } return false;
      }).appendTo(c); var b = a('<span title="Забанить или предупредить юзера">(Б)</span>').css({ display: "inline-block", verticalAlign: "middle", marginLeft: "0.2em", cursor: "pointer", color: "#868894", fontSize: "16px", fontWeight: "normal" }).click(function (h) {
        h.preventDefault();
        var g = document.getElement('link[rel="canonical"]'); if (g) { var f = g.href.match(/\/profile\/([\da-z0-9\_\-]+)/i); if (f) { window.ban(f[1]); } } return false;
      }).appendTo(c);
    }
  });
})(jQuery);
/*
 Highcharts JS v6.0.6 (2018-02-05)

 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (S, L) { "object" === typeof module && module.exports ? module.exports = S.document ? L(S) : L : S.Highcharts = L(S) })("undefined" !== typeof window ? window : this, function (S) {
  var L = function () {
    var a = "undefined" === typeof S ? window : S, B = a.document, H = a.navigator && a.navigator.userAgent || "", G = B && B.createElementNS && !!B.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, n = /(edge|msie|trident)/i.test(H) && !a.opera, l = -1 !== H.indexOf("Firefox"), f = -1 !== H.indexOf("Chrome"), t = l && 4 > parseInt(H.split("Firefox/")[1],
      10); return a.Highcharts ? a.Highcharts.error(16, !0) : {
        product: "Highcharts", version: "6.0.6", deg2rad: 2 * Math.PI / 360, doc: B, hasBidiBug: t, hasTouch: B && void 0 !== B.documentElement.ontouchstart, isMS: n, isWebKit: -1 !== H.indexOf("AppleWebKit"), isFirefox: l, isChrome: f, isSafari: !f && -1 !== H.indexOf("Safari"), isTouchDevice: /(Mobile|Android|Windows Phone)/.test(H), SVG_NS: "http://www.w3.org/2000/svg", chartCount: 0, seriesTypes: {}, symbolSizes: {}, svg: G, win: a, marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"], noop: function () { },
        charts: []
      }
  }(); (function (a) {
    a.timers = []; var B = a.charts, H = a.doc, G = a.win; a.error = function (n, l) { n = a.isNumber(n) ? "Highcharts error #" + n + ": www.highcharts.com/errors/" + n : n; if (l) throw Error(n); G.console && console.log(n) }; a.Fx = function (a, l, f) { this.options = l; this.elem = a; this.prop = f }; a.Fx.prototype = {
      dSetter: function () {
        var a = this.paths[0], l = this.paths[1], f = [], t = this.now, q = a.length, v; if (1 === t) f = this.toD; else if (q === l.length && 1 > t) for (; q--;)v = parseFloat(a[q]), f[q] = isNaN(v) ? l[q] : t * parseFloat(l[q] - v) + v; else f = l; this.elem.attr("d",
          f, null, !0)
      }, update: function () { var a = this.elem, l = this.prop, f = this.now, t = this.options.step; if (this[l + "Setter"]) this[l + "Setter"](); else a.attr ? a.element && a.attr(l, f, null, !0) : a.style[l] = f + this.unit; t && t.call(a, f, this) }, run: function (n, l, f) {
        var t = this, q = t.options, v = function (a) { return v.stopped ? !1 : t.step(a) }, u = G.requestAnimationFrame || function (a) { setTimeout(a, 13) }, b = function () { for (var d = 0; d < a.timers.length; d++)a.timers[d]() || a.timers.splice(d--, 1); a.timers.length && u(b) }; n === l ? (delete q.curAnim[this.prop],
          q.complete && 0 === a.keys(q.curAnim).length && q.complete.call(this.elem)) : (this.startTime = +new Date, this.start = n, this.end = l, this.unit = f, this.now = this.start, this.pos = 0, v.elem = this.elem, v.prop = this.prop, v() && 1 === a.timers.push(v) && u(b))
      }, step: function (n) {
        var l = +new Date, f, t = this.options, q = this.elem, v = t.complete, u = t.duration, b = t.curAnim; q.attr && !q.element ? n = !1 : n || l >= u + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), f = b[this.prop] = !0, a.objectEach(b, function (a) { !0 !== a && (f = !1) }), f && v && v.call(q), n =
          !1) : (this.pos = t.easing((l - this.startTime) / u), this.now = this.start + (this.end - this.start) * this.pos, this.update(), n = !0); return n
      }, initPath: function (n, l, f) {
        function t(a) { var b, c; for (g = a.length; g--;)b = "M" === a[g] || "L" === a[g], c = /[a-zA-Z]/.test(a[g + 3]), b && c && a.splice(g + 1, 0, a[g + 1], a[g + 2], a[g + 1], a[g + 2]) } function q(a, b) { for (; a.length < c;) { a[0] = b[c - a.length]; var d = a.slice(0, e);[].splice.apply(a, [0, 0].concat(d)); r && (d = a.slice(a.length - e), [].splice.apply(a, [a.length, 0].concat(d)), g--) } a[0] = "M" } function v(a, b) {
          for (var g =
            (c - a.length) / e; 0 < g && g--;)m = a.slice().splice(a.length / z - e, e * z), m[0] = b[c - e - g * e], k && (m[e - 6] = m[e - 2], m[e - 5] = m[e - 1]), [].splice.apply(a, [a.length / z, 0].concat(m)), r && g--
        } l = l || ""; var u, b = n.startX, d = n.endX, k = -1 < l.indexOf("C"), e = k ? 7 : 3, c, m, g; l = l.split(" "); f = f.slice(); var r = n.isArea, z = r ? 2 : 1, K; k && (t(l), t(f)); if (b && d) { for (g = 0; g < b.length; g++)if (b[g] === d[0]) { u = g; break } else if (b[0] === d[d.length - b.length + g]) { u = g; K = !0; break } void 0 === u && (l = []) } l.length && a.isNumber(u) && (c = f.length + u * z * e, K ? (q(l, f), v(f, l)) : (q(f, l), v(l,
          f))); return [l, f]
      }
    }; a.Fx.prototype.fillSetter = a.Fx.prototype.strokeSetter = function () { this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0) }; a.merge = function () { var n, l = arguments, f, t = {}, q = function (f, n) { "object" !== typeof f && (f = {}); a.objectEach(n, function (b, d) { !a.isObject(b, !0) || a.isClass(b) || a.isDOMElement(b) ? f[d] = n[d] : f[d] = q(f[d] || {}, b) }); return f }; !0 === l[0] && (t = l[1], l = Array.prototype.slice.call(l, 2)); f = l.length; for (n = 0; n < f; n++)t = q(t, l[n]); return t }; a.pInt = function (a,
      l) { return parseInt(a, l || 10) }; a.isString = function (a) { return "string" === typeof a }; a.isArray = function (a) { a = Object.prototype.toString.call(a); return "[object Array]" === a || "[object Array Iterator]" === a }; a.isObject = function (n, l) { return !!n && "object" === typeof n && (!l || !a.isArray(n)) }; a.isDOMElement = function (n) { return a.isObject(n) && "number" === typeof n.nodeType }; a.isClass = function (n) { var l = n && n.constructor; return !(!a.isObject(n, !0) || a.isDOMElement(n) || !l || !l.name || "Object" === l.name) }; a.isNumber = function (a) {
        return "number" ===
          typeof a && !isNaN(a) && Infinity > a && -Infinity < a
      }; a.erase = function (a, l) { for (var f = a.length; f--;)if (a[f] === l) { a.splice(f, 1); break } }; a.defined = function (a) { return void 0 !== a && null !== a }; a.attr = function (n, l, f) { var t; a.isString(l) ? a.defined(f) ? n.setAttribute(l, f) : n && n.getAttribute && (t = n.getAttribute(l)) : a.defined(l) && a.isObject(l) && a.objectEach(l, function (a, f) { n.setAttribute(f, a) }); return t }; a.splat = function (n) { return a.isArray(n) ? n : [n] }; a.syncTimeout = function (a, l, f) {
        if (l) return setTimeout(a, l, f); a.call(0,
          f)
      }; a.extend = function (a, l) { var f; a || (a = {}); for (f in l) a[f] = l[f]; return a }; a.pick = function () { var a = arguments, l, f, t = a.length; for (l = 0; l < t; l++)if (f = a[l], void 0 !== f && null !== f) return f }; a.css = function (n, l) { a.isMS && !a.svg && l && void 0 !== l.opacity && (l.filter = "alpha(opacity\x3d" + 100 * l.opacity + ")"); a.extend(n.style, l) }; a.createElement = function (n, l, f, t, q) { n = H.createElement(n); var v = a.css; l && a.extend(n, l); q && v(n, { padding: 0, border: "none", margin: 0 }); f && v(n, f); t && t.appendChild(n); return n }; a.extendClass = function (n,
        l) { var f = function () { }; f.prototype = new n; a.extend(f.prototype, l); return f }; a.pad = function (a, l, f) { return Array((l || 2) + 1 - String(a).length).join(f || 0) + a }; a.relativeLength = function (a, l, f) { return /%$/.test(a) ? l * parseFloat(a) / 100 + (f || 0) : parseFloat(a) }; a.wrap = function (a, l, f) { var t = a[l]; a[l] = function () { var a = Array.prototype.slice.call(arguments), v = arguments, u = this; u.proceed = function () { t.apply(u, arguments.length ? arguments : v) }; a.unshift(t); a = f.apply(this, a); u.proceed = null; return a } }; a.formatSingle = function (n,
          l, f) { var t = /\.([0-9])/, q = a.defaultOptions.lang; /f$/.test(n) ? (f = (f = n.match(t)) ? f[1] : -1, null !== l && (l = a.numberFormat(l, f, q.decimalPoint, -1 < n.indexOf(",") ? q.thousandsSep : ""))) : l = (f || a.time).dateFormat(n, l); return l }; a.format = function (n, l, f) {
            for (var t = "{", q = !1, v, u, b, d, k = [], e; n;) {
              t = n.indexOf(t); if (-1 === t) break; v = n.slice(0, t); if (q) { v = v.split(":"); u = v.shift().split("."); d = u.length; e = l; for (b = 0; b < d; b++)e && (e = e[u[b]]); v.length && (e = a.formatSingle(v.join(":"), e, f)); k.push(e) } else k.push(v); n = n.slice(t + 1); t = (q =
                !q) ? "}" : "{"
            } k.push(n); return k.join("")
          }; a.getMagnitude = function (a) { return Math.pow(10, Math.floor(Math.log(a) / Math.LN10)) }; a.normalizeTickInterval = function (n, l, f, t, q) { var v, u = n; f = a.pick(f, 1); v = n / f; l || (l = q ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === t && (1 === f ? l = a.grep(l, function (a) { return 0 === a % 1 }) : .1 >= f && (l = [1 / f]))); for (t = 0; t < l.length && !(u = l[t], q && u * f >= n || !q && v <= (l[t] + (l[t + 1] || l[t])) / 2); t++); return u = a.correctFloat(u * f, -Math.round(Math.log(.001) / Math.LN10)) }; a.stableSort = function (a, l) {
            var f =
              a.length, t, q; for (q = 0; q < f; q++)a[q].safeI = q; a.sort(function (a, f) { t = l(a, f); return 0 === t ? a.safeI - f.safeI : t }); for (q = 0; q < f; q++)delete a[q].safeI
          }; a.arrayMin = function (a) { for (var l = a.length, f = a[0]; l--;)a[l] < f && (f = a[l]); return f }; a.arrayMax = function (a) { for (var l = a.length, f = a[0]; l--;)a[l] > f && (f = a[l]); return f }; a.destroyObjectProperties = function (n, l) { a.objectEach(n, function (a, t) { a && a !== l && a.destroy && a.destroy(); delete n[t] }) }; a.discardElement = function (n) {
            var l = a.garbageBin; l || (l = a.createElement("div")); n && l.appendChild(n);
            l.innerHTML = ""
          }; a.correctFloat = function (a, l) { return parseFloat(a.toPrecision(l || 14)) }; a.setAnimation = function (n, l) { l.renderer.globalAnimation = a.pick(n, l.options.chart.animation, !0) }; a.animObject = function (n) { return a.isObject(n) ? a.merge(n) : { duration: n ? 500 : 0 } }; a.timeUnits = { millisecond: 1, second: 1E3, minute: 6E4, hour: 36E5, day: 864E5, week: 6048E5, month: 24192E5, year: 314496E5 }; a.numberFormat = function (n, l, f, t) {
            n = +n || 0; l = +l; var q = a.defaultOptions.lang, v = (n.toString().split(".")[1] || "").split("e")[0].length, u,
              b, d = n.toString().split("e"); -1 === l ? l = Math.min(v, 20) : a.isNumber(l) ? l && d[1] && 0 > d[1] && (u = l + +d[1], 0 <= u ? (d[0] = (+d[0]).toExponential(u).split("e")[0], l = u) : (d[0] = d[0].split(".")[0] || 0, n = 20 > l ? (d[0] * Math.pow(10, d[1])).toFixed(l) : 0, d[1] = 0)) : l = 2; b = (Math.abs(d[1] ? d[0] : n) + Math.pow(10, -Math.max(l, v) - 1)).toFixed(l); v = String(a.pInt(b)); u = 3 < v.length ? v.length % 3 : 0; f = a.pick(f, q.decimalPoint); t = a.pick(t, q.thousandsSep); n = (0 > n ? "-" : "") + (u ? v.substr(0, u) + t : ""); n += v.substr(u).replace(/(\d{3})(?=\d)/g, "$1" + t); l && (n += f + b.slice(-l));
            d[1] && 0 !== +n && (n += "e" + d[1]); return n
          }; Math.easeInOutSine = function (a) { return -.5 * (Math.cos(Math.PI * a) - 1) }; a.getStyle = function (n, l, f) {
            if ("width" === l) return Math.min(n.offsetWidth, n.scrollWidth) - a.getStyle(n, "padding-left") - a.getStyle(n, "padding-right"); if ("height" === l) return Math.min(n.offsetHeight, n.scrollHeight) - a.getStyle(n, "padding-top") - a.getStyle(n, "padding-bottom"); G.getComputedStyle || a.error(27, !0); if (n = G.getComputedStyle(n, void 0)) n = n.getPropertyValue(l), a.pick(f, "opacity" !== l) && (n = a.pInt(n));
            return n
          }; a.inArray = function (n, l) { return (a.indexOfPolyfill || Array.prototype.indexOf).call(l, n) }; a.grep = function (n, l) { return (a.filterPolyfill || Array.prototype.filter).call(n, l) }; a.find = Array.prototype.find ? function (a, l) { return a.find(l) } : function (a, l) { var f, t = a.length; for (f = 0; f < t; f++)if (l(a[f], f)) return a[f] }; a.map = function (a, l) { for (var f = [], t = 0, q = a.length; t < q; t++)f[t] = l.call(a[t], a[t], t, a); return f }; a.keys = function (n) { return (a.keysPolyfill || Object.keys).call(void 0, n) }; a.reduce = function (n, l, f) {
            return (a.reducePolyfill ||
              Array.prototype.reduce).call(n, l, f)
          }; a.offset = function (a) { var l = H.documentElement; a = a.parentElement ? a.getBoundingClientRect() : { top: 0, left: 0 }; return { top: a.top + (G.pageYOffset || l.scrollTop) - (l.clientTop || 0), left: a.left + (G.pageXOffset || l.scrollLeft) - (l.clientLeft || 0) } }; a.stop = function (n, l) { for (var f = a.timers.length; f--;)a.timers[f].elem !== n || l && l !== a.timers[f].prop || (a.timers[f].stopped = !0) }; a.each = function (n, l, f) { return (a.forEachPolyfill || Array.prototype.forEach).call(n, l, f) }; a.objectEach = function (a,
            l, f) { for (var t in a) a.hasOwnProperty(t) && l.call(f, a[t], t, a) }; a.addEvent = function (n, l, f) { var t, q, v = n.addEventListener || a.addEventListenerPolyfill; n.hcEvents && !Object.prototype.hasOwnProperty.call(n, "hcEvents") && (q = {}, a.objectEach(n.hcEvents, function (a, b) { q[b] = a.slice(0) }), n.hcEvents = q); t = n.hcEvents = n.hcEvents || {}; v && v.call(n, l, f, !1); t[l] || (t[l] = []); t[l].push(f); return function () { a.removeEvent(n, l, f) } }; a.removeEvent = function (n, l, f) {
              function t(b, k) {
                var e = n.removeEventListener || a.removeEventListenerPolyfill;
                e && e.call(n, b, k, !1)
              } function q() { var b, k; n.nodeName && (l ? (b = {}, b[l] = !0) : b = u, a.objectEach(b, function (a, b) { if (u[b]) for (k = u[b].length; k--;)t(b, u[b][k]) })) } var v, u = n.hcEvents, b; u && (l ? (v = u[l] || [], f ? (b = a.inArray(f, v), -1 < b && (v.splice(b, 1), u[l] = v), t(l, f)) : (q(), u[l] = [])) : (q(), n.hcEvents = {}))
            }; a.fireEvent = function (n, l, f, t) {
              var q; q = n.hcEvents; var v, u; f = f || {}; if (H.createEvent && (n.dispatchEvent || n.fireEvent)) q = H.createEvent("Events"), q.initEvent(l, !0, !0), a.extend(q, f), n.dispatchEvent ? n.dispatchEvent(q) : n.fireEvent(l,
                q); else if (q) for (q = q[l] || [], v = q.length, f.target || a.extend(f, { preventDefault: function () { f.defaultPrevented = !0 }, target: n, type: l }), l = 0; l < v; l++)(u = q[l]) && !1 === u.call(n, f) && f.preventDefault(); t && !f.defaultPrevented && t(f)
            }; a.animate = function (n, l, f) {
              var t, q = "", v, u, b; a.isObject(f) || (b = arguments, f = { duration: b[2], easing: b[3], complete: b[4] }); a.isNumber(f.duration) || (f.duration = 400); f.easing = "function" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine; f.curAnim = a.merge(l); a.objectEach(l, function (b,
                k) { a.stop(n, k); u = new a.Fx(n, f, k); v = null; "d" === k ? (u.paths = u.initPath(n, n.d, l.d), u.toD = l.d, t = 0, v = 1) : n.attr ? t = n.attr(k) : (t = parseFloat(a.getStyle(n, k)) || 0, "opacity" !== k && (q = "px")); v || (v = b); v && v.match && v.match("px") && (v = v.replace(/px/g, "")); u.run(t, v, q) })
            }; a.seriesType = function (n, l, f, t, q) { var v = a.getOptions(), u = a.seriesTypes; v.plotOptions[n] = a.merge(v.plotOptions[l], f); u[n] = a.extendClass(u[l] || function () { }, t); u[n].prototype.type = n; q && (u[n].prototype.pointClass = a.extendClass(a.Point, q)); return u[n] }; a.uniqueKey =
              function () { var a = Math.random().toString(36).substring(2, 9), l = 0; return function () { return "highcharts-" + a + "-" + l++ } }(); G.jQuery && (G.jQuery.fn.highcharts = function () { var n = [].slice.call(arguments); if (this[0]) return n[0] ? (new (a[a.isString(n[0]) ? n.shift() : "Chart"])(this[0], n[0], n[1]), this) : B[a.attr(this[0], "data-highcharts-chart")] })
  })(L); (function (a) {
    var B = a.each, H = a.isNumber, G = a.map, n = a.merge, l = a.pInt; a.Color = function (f) { if (!(this instanceof a.Color)) return new a.Color(f); this.init(f) }; a.Color.prototype =
    {
      parsers: [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function (a) { return [l(a[1]), l(a[2]), l(a[3]), parseFloat(a[4], 10)] } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function (a) { return [l(a[1]), l(a[2]), l(a[3]), 1] } }], names: { none: "rgba(255,255,255,0)", white: "#ffffff", black: "#000000" }, init: function (f) {
        var l, q, v, u; if ((this.input = f = this.names[f && f.toLowerCase ? f.toLowerCase() : ""] || f) && f.stops) this.stops = G(f.stops,
          function (b) { return new a.Color(b[1]) }); else if (f && f.charAt && "#" === f.charAt() && (l = f.length, f = parseInt(f.substr(1), 16), 7 === l ? q = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === l && (q = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1])), !q) for (v = this.parsers.length; v-- && !q;)u = this.parsers[v], (l = u.regex.exec(f)) && (q = u.parse(l)); this.rgba = q || []
      }, get: function (a) {
        var f = this.input, q = this.rgba, l; this.stops ? (l = n(f), l.stops = [].concat(l.stops), B(this.stops, function (q, b) { l.stops[b] = [l.stops[b][0], q.get(a)] })) :
          l = q && H(q[0]) ? "rgb" === a || !a && 1 === q[3] ? "rgb(" + q[0] + "," + q[1] + "," + q[2] + ")" : "a" === a ? q[3] : "rgba(" + q.join(",") + ")" : f; return l
      }, brighten: function (a) { var f, q = this.rgba; if (this.stops) B(this.stops, function (q) { q.brighten(a) }); else if (H(a) && 0 !== a) for (f = 0; 3 > f; f++)q[f] += l(255 * a), 0 > q[f] && (q[f] = 0), 255 < q[f] && (q[f] = 255); return this }, setOpacity: function (a) { this.rgba[3] = a; return this }, tweenTo: function (a, l) {
        var q = this.rgba, f = a.rgba; f.length && q && q.length ? (a = 1 !== f[3] || 1 !== q[3], l = (a ? "rgba(" : "rgb(") + Math.round(f[0] + (q[0] -
          f[0]) * (1 - l)) + "," + Math.round(f[1] + (q[1] - f[1]) * (1 - l)) + "," + Math.round(f[2] + (q[2] - f[2]) * (1 - l)) + (a ? "," + (f[3] + (q[3] - f[3]) * (1 - l)) : "") + ")") : l = a.input || "none"; return l
      }
    }; a.color = function (f) { return new a.Color(f) }
  })(L); (function (a) {
    var B, H, G = a.addEvent, n = a.animate, l = a.attr, f = a.charts, t = a.color, q = a.css, v = a.createElement, u = a.defined, b = a.deg2rad, d = a.destroyObjectProperties, k = a.doc, e = a.each, c = a.extend, m = a.erase, g = a.grep, r = a.hasTouch, z = a.inArray, K = a.isArray, y = a.isFirefox, I = a.isMS, A = a.isObject, D = a.isString, x = a.isWebKit,
    E = a.merge, C = a.noop, J = a.objectEach, F = a.pick, h = a.pInt, p = a.removeEvent, M = a.stop, O = a.svg, N = a.SVG_NS, P = a.symbolSizes, Q = a.win; B = a.SVGElement = function () { return this }; c(B.prototype, {
      opacity: 1, SVG_NS: N, textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "), init: function (a, h) { this.element = "span" === h ? v(h) : k.createElementNS(this.SVG_NS, h); this.renderer = a }, animate: function (w, h, b) {
        h = a.animObject(F(h, this.renderer.globalAnimation,
          !0)); 0 !== h.duration ? (b && (h.complete = b), n(this, w, h)) : (this.attr(w, null, b), h.step && h.step.call(this)); return this
      }, colorGradient: function (w, h, b) {
        var p = this.renderer, c, g, m, d, r, N, R, x, k, C, z = [], O; w.radialGradient ? g = "radialGradient" : w.linearGradient && (g = "linearGradient"); g && (m = w[g], r = p.gradients, R = w.stops, C = b.radialReference, K(m) && (w[g] = m = { x1: m[0], y1: m[1], x2: m[2], y2: m[3], gradientUnits: "userSpaceOnUse" }), "radialGradient" === g && C && !u(m.gradientUnits) && (d = m, m = E(m, p.getRadialAttr(C, d), { gradientUnits: "userSpaceOnUse" })),
          J(m, function (a, w) { "id" !== w && z.push(w, a) }), J(R, function (a) { z.push(a) }), z = z.join(","), r[z] ? C = r[z].attr("id") : (m.id = C = a.uniqueKey(), r[z] = N = p.createElement(g).attr(m).add(p.defs), N.radAttr = d, N.stops = [], e(R, function (w) { 0 === w[1].indexOf("rgba") ? (c = a.color(w[1]), x = c.get("rgb"), k = c.get("a")) : (x = w[1], k = 1); w = p.createElement("stop").attr({ offset: w[0], "stop-color": x, "stop-opacity": k }).add(N); N.stops.push(w) })), O = "url(" + p.url + "#" + C + ")", b.setAttribute(h, O), b.gradient = z, w.toString = function () { return O })
      }, applyTextOutline: function (w) {
        var h =
          this.element, b, p, c, g, d; -1 !== w.indexOf("contrast") && (w = w.replace(/contrast/g, this.renderer.getContrast(h.style.fill))); w = w.split(" "); p = w[w.length - 1]; if ((c = w[0]) && "none" !== c && a.svg) {
            this.fakeTS = !0; w = [].slice.call(h.getElementsByTagName("tspan")); this.ySetter = this.xSetter; c = c.replace(/(^[\d\.]+)(.*?)$/g, function (a, w, h) { return 2 * w + h }); for (d = w.length; d--;)b = w[d], "highcharts-text-outline" === b.getAttribute("class") && m(w, h.removeChild(b)); g = h.firstChild; e(w, function (a, w) {
              0 === w && (a.setAttribute("x", h.getAttribute("x")),
                w = h.getAttribute("y"), a.setAttribute("y", w || 0), null === w && h.setAttribute("y", 0)); a = a.cloneNode(1); l(a, { "class": "highcharts-text-outline", fill: p, stroke: p, "stroke-width": c, "stroke-linejoin": "round" }); h.insertBefore(a, g)
            })
          }
      }, attr: function (a, h, b, p) {
        var w, c = this.element, e, g = this, m, d; "string" === typeof a && void 0 !== h && (w = a, a = {}, a[w] = h); "string" === typeof a ? g = (this[a + "Getter"] || this._defaultGetter).call(this, a, c) : (J(a, function (w, h) {
          m = !1; p || M(this, h); this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(h) &&
            (e || (this.symbolAttr(a), e = !0), m = !0); !this.rotation || "x" !== h && "y" !== h || (this.doTransform = !0); m || (d = this[h + "Setter"] || this._defaultSetter, d.call(this, w, h, c), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(h) && this.updateShadows(h, w, d))
        }, this), this.afterSetters()); b && b.call(this); return g
      }, afterSetters: function () { this.doTransform && (this.updateTransform(), this.doTransform = !1) }, updateShadows: function (a, h, b) {
        for (var w = this.shadows, p = w.length; p--;)b.call(w[p], "height" === a ? Math.max(h -
          (w[p].cutHeight || 0), 0) : "d" === a ? this.d : h, a, w[p])
      }, addClass: function (a, h) { var w = this.attr("class") || ""; -1 === w.indexOf(a) && (h || (a = (w + (w ? " " : "") + a).replace("  ", " ")), this.attr("class", a)); return this }, hasClass: function (a) { return -1 !== z(a, (this.attr("class") || "").split(" ")) }, removeClass: function (a) { return this.attr("class", (this.attr("class") || "").replace(a, "")) }, symbolAttr: function (a) {
        var w = this; e("x y r start end width height innerR anchorX anchorY".split(" "), function (h) { w[h] = F(a[h], w[h]) }); w.attr({
          d: w.renderer.symbols[w.symbolName](w.x,
            w.y, w.width, w.height, w)
        })
      }, clip: function (a) { return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none") }, crisp: function (a, h) { var w; h = h || a.strokeWidth || 0; w = Math.round(h) % 2 / 2; a.x = Math.floor(a.x || this.x || 0) + w; a.y = Math.floor(a.y || this.y || 0) + w; a.width = Math.floor((a.width || this.width || 0) - 2 * w); a.height = Math.floor((a.height || this.height || 0) - 2 * w); u(a.strokeWidth) && (a.strokeWidth = h); return a }, css: function (a) {
        var w = this.styles, b = {}, p = this.element, e, g = "", m, d = !w, r = ["textOutline", "textOverflow",
          "width"]; a && a.color && (a.fill = a.color); w && J(a, function (a, h) { a !== w[h] && (b[h] = a, d = !0) }); d && (w && (a = c(w, b)), e = this.textWidth = a && a.width && "auto" !== a.width && "text" === p.nodeName.toLowerCase() && h(a.width), this.styles = a, e && !O && this.renderer.forExport && delete a.width, p.namespaceURI === this.SVG_NS ? (m = function (a, w) { return "-" + w.toLowerCase() }, J(a, function (a, w) { -1 === z(w, r) && (g += w.replace(/([A-Z])/g, m) + ":" + a + ";") }), g && l(p, "style", g)) : q(p, a), this.added && ("text" === this.element.nodeName && this.renderer.buildText(this),
            a && a.textOutline && this.applyTextOutline(a.textOutline))); return this
      }, strokeWidth: function () { return this["stroke-width"] || 0 }, on: function (a, h) { var w = this, b = w.element; r && "click" === a ? (b.ontouchstart = function (a) { w.touchEventFired = Date.now(); a.preventDefault(); h.call(b, a) }, b.onclick = function (a) { (-1 === Q.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (w.touchEventFired || 0)) && h.call(b, a) }) : b["on" + a] = h; return this }, setRadialReference: function (a) {
        var w = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = a; w && w.radAttr && w.animate(this.renderer.getRadialAttr(a, w.radAttr)); return this
      }, translate: function (a, h) { return this.attr({ translateX: a, translateY: h }) }, invert: function (a) { this.inverted = a; this.updateTransform(); return this }, updateTransform: function () {
        var a = this.translateX || 0, h = this.translateY || 0, b = this.scaleX, p = this.scaleY, c = this.inverted, e = this.rotation, g = this.matrix, m = this.element; c && (a += this.width, h += this.height); a = ["translate(" + a + "," + h + ")"]; u(g) && a.push("matrix(" + g.join(",") +
          ")"); c ? a.push("rotate(90) scale(-1,1)") : e && a.push("rotate(" + e + " " + F(this.rotationOriginX, m.getAttribute("x"), 0) + " " + F(this.rotationOriginY, m.getAttribute("y") || 0) + ")"); (u(b) || u(p)) && a.push("scale(" + F(b, 1) + " " + F(p, 1) + ")"); a.length && m.setAttribute("transform", a.join(" "))
      }, toFront: function () { var a = this.element; a.parentNode.appendChild(a); return this }, align: function (a, h, b) {
        var w, p, c, e, g = {}; p = this.renderer; c = p.alignedObjects; var d, r; if (a) {
          if (this.alignOptions = a, this.alignByTranslate = h, !b || D(b)) this.alignTo =
            w = b || "renderer", m(c, this), c.push(this), b = null
        } else a = this.alignOptions, h = this.alignByTranslate, w = this.alignTo; b = F(b, p[w], p); w = a.align; p = a.verticalAlign; c = (b.x || 0) + (a.x || 0); e = (b.y || 0) + (a.y || 0); "right" === w ? d = 1 : "center" === w && (d = 2); d && (c += (b.width - (a.width || 0)) / d); g[h ? "translateX" : "x"] = Math.round(c); "bottom" === p ? r = 1 : "middle" === p && (r = 2); r && (e += (b.height - (a.height || 0)) / r); g[h ? "translateY" : "y"] = Math.round(e); this[this.placed ? "animate" : "attr"](g); this.placed = !0; this.alignAttr = g; return this
      }, getBBox: function (a,
        h) {
          var w, p = this.renderer, g, m = this.element, d = this.styles, r, N = this.textStr, x, k = p.cache, C = p.cacheKeys, E; h = F(h, this.rotation); g = h * b; r = d && d.fontSize; u(N) && (E = N.toString(), -1 === E.indexOf("\x3c") && (E = E.replace(/[0-9]/g, "0")), E += ["", h || 0, r, d && d.width, d && d.textOverflow].join()); E && !a && (w = k[E]); if (!w) {
            if (m.namespaceURI === this.SVG_NS || p.forExport) {
              try {
                (x = this.fakeTS && function (a) { e(m.querySelectorAll(".highcharts-text-outline"), function (w) { w.style.display = a }) }) && x("none"), w = m.getBBox ? c({}, m.getBBox()) : {
                  width: m.offsetWidth,
                  height: m.offsetHeight
                }, x && x("")
              } catch (W) { } if (!w || 0 > w.width) w = { width: 0, height: 0 }
            } else w = this.htmlGetBBox(); p.isSVG && (a = w.width, p = w.height, d && "11px" === d.fontSize && 17 === Math.round(p) && (w.height = p = 14), h && (w.width = Math.abs(p * Math.sin(g)) + Math.abs(a * Math.cos(g)), w.height = Math.abs(p * Math.cos(g)) + Math.abs(a * Math.sin(g)))); if (E && 0 < w.height) { for (; 250 < C.length;)delete k[C.shift()]; k[E] || C.push(E); k[E] = w }
          } return w
      }, show: function (a) { return this.attr({ visibility: a ? "inherit" : "visible" }) }, hide: function () { return this.attr({ visibility: "hidden" }) },
      fadeOut: function (a) { var w = this; w.animate({ opacity: 0 }, { duration: a || 150, complete: function () { w.attr({ y: -9999 }) } }) }, add: function (a) { var w = this.renderer, h = this.element, b; a && (this.parentGroup = a); this.parentInverted = a && a.inverted; void 0 !== this.textStr && w.buildText(this); this.added = !0; if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter(); b || (a ? a.element : w.box).appendChild(h); if (this.onAdd) this.onAdd(); return this }, safeRemoveChild: function (a) { var w = a.parentNode; w && w.removeChild(a) }, destroy: function () {
        var a =
          this, h = a.element || {}, b = a.renderer.isSVG && "SPAN" === h.nodeName && a.parentGroup, p = h.ownerSVGElement, c = a.clipPath; h.onclick = h.onmouseout = h.onmouseover = h.onmousemove = h.point = null; M(a); c && p && (e(p.querySelectorAll("[clip-path],[CLIP-PATH]"), function (a) { var h = a.getAttribute("clip-path"), w = c.element.id; (-1 < h.indexOf("(#" + w + ")") || -1 < h.indexOf('("#' + w + '")')) && a.removeAttribute("clip-path") }), a.clipPath = c.destroy()); if (a.stops) { for (p = 0; p < a.stops.length; p++)a.stops[p] = a.stops[p].destroy(); a.stops = null } a.safeRemoveChild(h);
        for (a.destroyShadows(); b && b.div && 0 === b.div.childNodes.length;)h = b.parentGroup, a.safeRemoveChild(b.div), delete b.div, b = h; a.alignTo && m(a.renderer.alignedObjects, a); J(a, function (h, w) { delete a[w] }); return null
      }, shadow: function (a, h, b) {
        var w = [], p, c, g = this.element, e, m, d, r; if (!a) this.destroyShadows(); else if (!this.shadows) {
          m = F(a.width, 3); d = (a.opacity || .15) / m; r = this.parentInverted ? "(-1,-1)" : "(" + F(a.offsetX, 1) + ", " + F(a.offsetY, 1) + ")"; for (p = 1; p <= m; p++)c = g.cloneNode(0), e = 2 * m + 1 - 2 * p, l(c, {
            isShadow: "true", stroke: a.color ||
              "#000000", "stroke-opacity": d * p, "stroke-width": e, transform: "translate" + r, fill: "none"
          }), b && (l(c, "height", Math.max(l(c, "height") - e, 0)), c.cutHeight = e), h ? h.element.appendChild(c) : g.parentNode && g.parentNode.insertBefore(c, g), w.push(c); this.shadows = w
        } return this
      }, destroyShadows: function () { e(this.shadows || [], function (a) { this.safeRemoveChild(a) }, this); this.shadows = void 0 }, xGetter: function (a) { "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy")); return this._defaultGetter(a) }, _defaultGetter: function (a) {
        a =
        F(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0); /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a)); return a
      }, dSetter: function (a, h, b) { a && a.join && (a = a.join(" ")); /(NaN| {2}|^$)/.test(a) && (a = "M 0 0"); this[h] !== a && (b.setAttribute(h, a), this[h] = a) }, dashstyleSetter: function (a) {
        var w, b = this["stroke-width"]; "inherit" === b && (b = 1); if (a = a && a.toLowerCase()) {
          a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash",
            "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); for (w = a.length; w--;)a[w] = h(a[w]) * b; a = a.join(",").replace(/NaN/g, "none"); this.element.setAttribute("stroke-dasharray", a)
        }
      }, alignSetter: function (a) { this.alignValue = a; this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[a]) }, opacitySetter: function (a, h, b) { this[h] = a; b.setAttribute(h, a) }, titleSetter: function (a) {
        var h = this.element.getElementsByTagName("title")[0]; h || (h = k.createElementNS(this.SVG_NS,
          "title"), this.element.appendChild(h)); h.firstChild && h.removeChild(h.firstChild); h.appendChild(k.createTextNode(String(F(a), "").replace(/<[^>]*>/g, "").replace(/&lt;/g, "\x3c").replace(/&gt;/g, "\x3e")))
      }, textSetter: function (a) { a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this)) }, fillSetter: function (a, h, b) { "string" === typeof a ? b.setAttribute(h, a) : a && this.colorGradient(a, h, b) }, visibilitySetter: function (a, h, b) {
        "inherit" === a ? b.removeAttribute(h) : this[h] !== a && b.setAttribute(h,
          a); this[h] = a
      }, zIndexSetter: function (a, b) { var p = this.renderer, w = this.parentGroup, c = (w || p).element || p.box, g, e = this.element, m, d, p = c === p.box; g = this.added; var r; u(a) && (e.zIndex = a, a = +a, this[b] === a && (g = !1), this[b] = a); if (g) { (a = this.zIndex) && w && (w.handleZ = !0); b = c.childNodes; for (r = b.length - 1; 0 <= r && !m; r--)if (w = b[r], g = w.zIndex, d = !u(g), w !== e) if (0 > a && d && !p && !r) c.insertBefore(e, b[r]), m = !0; else if (h(g) <= a || d && (!u(a) || 0 <= a)) c.insertBefore(e, b[r + 1] || null), m = !0; m || (c.insertBefore(e, b[p ? 3 : 0] || null), m = !0) } return m }, _defaultSetter: function (a,
        h, b) { b.setAttribute(h, a) }
    }); B.prototype.yGetter = B.prototype.xGetter; B.prototype.translateXSetter = B.prototype.translateYSetter = B.prototype.rotationSetter = B.prototype.verticalAlignSetter = B.prototype.rotationOriginXSetter = B.prototype.rotationOriginYSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = B.prototype.matrixSetter = function (a, h) { this[h] = a; this.doTransform = !0 }; B.prototype["stroke-widthSetter"] = B.prototype.strokeSetter = function (a, h, b) {
      this[h] = a; this.stroke && this["stroke-width"] ? (B.prototype.fillSetter.call(this,
        this.stroke, "stroke", b), b.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === h && 0 === a && this.hasStroke && (b.removeAttribute("stroke"), this.hasStroke = !1)
    }; H = a.SVGRenderer = function () { this.init.apply(this, arguments) }; c(H.prototype, {
      Element: B, SVG_NS: N, init: function (a, h, b, p, c, g) {
        var w; p = this.createElement("svg").attr({ version: "1.1", "class": "highcharts-root" }).css(this.getStyle(p)); w = p.element; a.appendChild(w); l(a, "dir", "ltr"); -1 === a.innerHTML.indexOf("xmlns") && l(w, "xmlns",
          this.SVG_NS); this.isSVG = !0; this.box = w; this.boxWrapper = p; this.alignedObjects = []; this.url = (y || x) && k.getElementsByTagName("base").length ? Q.location.href.replace(/#.*?$/, "").replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : ""; this.createElement("desc").add().element.appendChild(k.createTextNode("Created with Highcharts 6.0.6")); this.defs = this.createElement("defs").add(); this.allowHTML = g; this.forExport = c; this.gradients = {}; this.cache = {}; this.cacheKeys = []; this.imgCount = 0; this.setSize(h,
            b, !1); var e; y && a.getBoundingClientRect && (h = function () { q(a, { left: 0, top: 0 }); e = a.getBoundingClientRect(); q(a, { left: Math.ceil(e.left) - e.left + "px", top: Math.ceil(e.top) - e.top + "px" }) }, h(), this.unSubPixelFix = G(Q, "resize", h))
      }, getStyle: function (a) { return this.style = c({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, a) }, setStyle: function (a) { this.boxWrapper.css(this.getStyle(a)) }, isHidden: function () { return !this.boxWrapper.getBBox().width }, destroy: function () {
        var a =
          this.defs; this.box = null; this.boxWrapper = this.boxWrapper.destroy(); d(this.gradients || {}); this.gradients = null; a && (this.defs = a.destroy()); this.unSubPixelFix && this.unSubPixelFix(); return this.alignedObjects = null
      }, createElement: function (a) { var h = new this.Element; h.init(this, a); return h }, draw: C, getRadialAttr: function (a, h) { return { cx: a[0] - a[2] / 2 + h.cx * a[2], cy: a[1] - a[2] / 2 + h.cy * a[2], r: h.r * a[2] } }, getSpanWidth: function (a) { return a.getBBox(!0).width }, applyEllipsis: function (a, h, b, p) {
        var c = a.rotation, w = b, g, e = 0, m =
          b.length, d = function (a) { h.removeChild(h.firstChild); a && h.appendChild(k.createTextNode(a)) }, r; a.rotation = 0; w = this.getSpanWidth(a, h); if (r = w > p) { for (; e <= m;)g = Math.ceil((e + m) / 2), w = b.substring(0, g) + "\u2026", d(w), w = this.getSpanWidth(a, h), e === m ? e = m + 1 : w > p ? m = g - 1 : e = g; 0 === m && d("") } a.rotation = c; return r
      }, escapes: { "\x26": "\x26amp;", "\x3c": "\x26lt;", "\x3e": "\x26gt;", "'": "\x26#39;", '"': "\x26quot;" }, buildText: function (a) {
        var b = a.element, p = this, c = p.forExport, w = F(a.textStr, "").toString(), m = -1 !== w.indexOf("\x3c"), d = b.childNodes,
        r, x, C, E, y = l(b, "x"), M = a.styles, f = a.textWidth, P = M && M.lineHeight, A = M && M.textOutline, u = M && "ellipsis" === M.textOverflow, D = M && "nowrap" === M.whiteSpace, v = M && M.fontSize, I, t, K = d.length, M = f && !a.added && this.box, Q = function (a) { var c; c = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : v || p.style.fontSize || 12; return P ? h(P) : p.fontMetrics(c, a.getAttribute("style") ? a : b).h }, n = function (a, h) { J(p.escapes, function (b, p) { h && -1 !== z(b, h) || (a = a.toString().replace(new RegExp(b, "g"), p)) }); return a }; I = [w, u, D, P, A, v, f].join();
        if (I !== a.textCache) {
          for (a.textCache = I; K--;)b.removeChild(d[K]); m || A || u || f || -1 !== w.indexOf(" ") ? (r = /<.*class="([^"]+)".*>/, x = /<.*style="([^"]+)".*>/, C = /<.*href="([^"]+)".*>/, M && M.appendChild(b), w = m ? w.replace(/<(b|strong)>/g, '\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g, '\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g, "\x3cspan").replace(/<\/(b|strong|i|em|a)>/g, "\x3c/span\x3e").split(/<br.*?>/g) : [w], w = g(w, function (a) { return "" !== a }), e(w, function (h, w) {
            var g, m = 0; h = h.replace(/^\s+|\s+$/g,
              "").replace(/<span/g, "|||\x3cspan").replace(/<\/span>/g, "\x3c/span\x3e|||"); g = h.split("|||"); e(g, function (h) {
                if ("" !== h || 1 === g.length) {
                  var e = {}, d = k.createElementNS(p.SVG_NS, "tspan"), z, M; r.test(h) && (z = h.match(r)[1], l(d, "class", z)); x.test(h) && (M = h.match(x)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), l(d, "style", M)); C.test(h) && !c && (l(d, "onclick", 'location.href\x3d"' + h.match(C)[1] + '"'), l(d, "class", "highcharts-anchor"), q(d, { cursor: "pointer" })); h = n(h.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " "); if (" " !== h) {
                    d.appendChild(k.createTextNode(h));
                    m ? e.dx = 0 : w && null !== y && (e.x = y); l(d, e); b.appendChild(d); !m && t && (!O && c && q(d, { display: "block" }), l(d, "dy", Q(d))); if (f) {
                      e = h.replace(/([^\^])-/g, "$1- ").split(" "); z = 1 < g.length || w || 1 < e.length && !D; var P = [], A, J = Q(d), F = a.rotation; for (u && (E = p.applyEllipsis(a, d, h, f)); !u && z && (e.length || P.length);)a.rotation = 0, A = p.getSpanWidth(a, d), h = A > f, void 0 === E && (E = h), h && 1 !== e.length ? (d.removeChild(d.firstChild), P.unshift(e.pop())) : (e = P, P = [], e.length && !D && (d = k.createElementNS(N, "tspan"), l(d, { dy: J, x: y }), M && l(d, "style", M), b.appendChild(d)),
                        A > f && (f = A)), e.length && d.appendChild(k.createTextNode(e.join(" ").replace(/- /g, "-"))); a.rotation = F
                    } m++
                  }
                }
              }); t = t || b.childNodes.length
          }), E && a.attr("title", n(a.textStr, ["\x26lt;", "\x26gt;"])), M && M.removeChild(b), A && a.applyTextOutline && a.applyTextOutline(A)) : b.appendChild(k.createTextNode(n(w)))
        }
      }, getContrast: function (a) { a = t(a).rgba; return 510 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF" }, button: function (a, h, b, p, e, g, d, m, r) {
        var w = this.label(a, h, b, r, null, null, null, null, "button"), x = 0; w.attr(E({ padding: 8, r: 2 }, e)); var N,
          k, C, z; e = E({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1, style: { color: "#333333", cursor: "pointer", fontWeight: "normal" } }, e); N = e.style; delete e.style; g = E(e, { fill: "#e6e6e6" }, g); k = g.style; delete g.style; d = E(e, { fill: "#e6ebf5", style: { color: "#000000", fontWeight: "bold" } }, d); C = d.style; delete d.style; m = E(e, { style: { color: "#cccccc" } }, m); z = m.style; delete m.style; G(w.element, I ? "mouseover" : "mouseenter", function () { 3 !== x && w.setState(1) }); G(w.element, I ? "mouseout" : "mouseleave", function () { 3 !== x && w.setState(x) }); w.setState =
            function (a) { 1 !== a && (w.state = x = a); w.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]); w.attr([e, g, d, m][a || 0]).css([N, k, C, z][a || 0]) }; w.attr(e).css(c({ cursor: "default" }, N)); return w.on("click", function (a) { 3 !== x && p.call(w, a) })
      }, crispLine: function (a, h) { a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - h % 2 / 2); a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + h % 2 / 2); return a }, path: function (a) {
        var h = { fill: "none" }; K(a) ? h.d = a : A(a) && c(h,
          a); return this.createElement("path").attr(h)
      }, circle: function (a, h, b) { a = A(a) ? a : { x: a, y: h, r: b }; h = this.createElement("circle"); h.xSetter = h.ySetter = function (a, h, b) { b.setAttribute("c" + h, a) }; return h.attr(a) }, arc: function (a, h, b, p, c, e) { A(a) ? (p = a, h = p.y, b = p.r, a = p.x) : p = { innerR: p, start: c, end: e }; a = this.symbol("arc", a, h, b, b, p); a.r = b; return a }, rect: function (a, h, b, p, c, e) {
        c = A(a) ? a.r : c; var g = this.createElement("rect"); a = A(a) ? a : void 0 === a ? {} : { x: a, y: h, width: Math.max(b, 0), height: Math.max(p, 0) }; void 0 !== e && (a.strokeWidth =
          e, a = g.crisp(a)); a.fill = "none"; c && (a.r = c); g.rSetter = function (a, h, b) { l(b, { rx: a, ry: a }) }; return g.attr(a)
      }, setSize: function (a, h, b) { var p = this.alignedObjects, c = p.length; this.width = a; this.height = h; for (this.boxWrapper.animate({ width: a, height: h }, { step: function () { this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") }) }, duration: F(b, !0) ? void 0 : 0 }); c--;)p[c].align() }, g: function (a) { var h = this.createElement("g"); return a ? h.attr({ "class": "highcharts-" + a }) : h }, image: function (a, h, b, p, e) {
        var g = { preserveAspectRatio: "none" };
        1 < arguments.length && c(g, { x: h, y: b, width: p, height: e }); g = this.createElement("image").attr(g); g.element.setAttributeNS ? g.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : g.element.setAttribute("hc-svg-href", a); return g
      }, symbol: function (a, h, b, p, g, d) {
        var m = this, w, r = /^url\((.*?)\)$/, x = r.test(a), N = !x && (this.symbols[a] ? a : "circle"), C = N && this.symbols[N], E = u(h) && C && C.call(this.symbols, Math.round(h), Math.round(b), p, g, d), z, O; C ? (w = this.path(E), w.attr("fill", "none"), c(w, {
          symbolName: N, x: h, y: b, width: p,
          height: g
        }), d && c(w, d)) : x && (z = a.match(r)[1], w = this.image(z), w.imgwidth = F(P[z] && P[z].width, d && d.width), w.imgheight = F(P[z] && P[z].height, d && d.height), O = function () { w.attr({ width: w.width, height: w.height }) }, e(["width", "height"], function (a) { w[a + "Setter"] = function (a, h) { var b = {}, p = this["img" + h], c = "width" === h ? "translateX" : "translateY"; this[h] = a; u(p) && (this.element && this.element.setAttribute(h, p), this.alignByTranslate || (b[c] = ((this[h] || 0) - p) / 2, this.attr(b))) } }), u(h) && w.attr({ x: h, y: b }), w.isImg = !0, u(w.imgwidth) &&
          u(w.imgheight) ? O() : (w.attr({ width: 0, height: 0 }), v("img", { onload: function () { var a = f[m.chartIndex]; 0 === this.width && (q(this, { position: "absolute", top: "-999em" }), k.body.appendChild(this)); P[z] = { width: this.width, height: this.height }; w.imgwidth = this.width; w.imgheight = this.height; w.element && O(); this.parentNode && this.parentNode.removeChild(this); m.imgCount--; if (!m.imgCount && a && a.onload) a.onload() }, src: z }), this.imgCount++)); return w
      }, symbols: {
        circle: function (a, h, b, p) {
          return this.arc(a + b / 2, h + p / 2, b / 2, p / 2, {
            start: 0,
            end: 2 * Math.PI, open: !1
          })
        }, square: function (a, h, b, p) { return ["M", a, h, "L", a + b, h, a + b, h + p, a, h + p, "Z"] }, triangle: function (a, h, b, p) { return ["M", a + b / 2, h, "L", a + b, h + p, a, h + p, "Z"] }, "triangle-down": function (a, h, b, p) { return ["M", a, h, "L", a + b, h, a + b / 2, h + p, "Z"] }, diamond: function (a, h, b, p) { return ["M", a + b / 2, h, "L", a + b, h + p / 2, a + b / 2, h + p, a, h + p / 2, "Z"] }, arc: function (a, h, b, p, c) {
          var e = c.start, g = c.r || b, d = c.r || p || b, m = c.end - .001; b = c.innerR; p = F(c.open, .001 > Math.abs(c.end - c.start - 2 * Math.PI)); var r = Math.cos(e), w = Math.sin(e), x = Math.cos(m),
            m = Math.sin(m); c = .001 > c.end - e - Math.PI ? 0 : 1; g = ["M", a + g * r, h + d * w, "A", g, d, 0, c, 1, a + g * x, h + d * m]; u(b) && g.push(p ? "M" : "L", a + b * x, h + b * m, "A", b, b, 0, c, 0, a + b * r, h + b * w); g.push(p ? "" : "Z"); return g
        }, callout: function (a, h, b, p, c) {
          var e = Math.min(c && c.r || 0, b, p), g = e + 6, d = c && c.anchorX; c = c && c.anchorY; var m; m = ["M", a + e, h, "L", a + b - e, h, "C", a + b, h, a + b, h, a + b, h + e, "L", a + b, h + p - e, "C", a + b, h + p, a + b, h + p, a + b - e, h + p, "L", a + e, h + p, "C", a, h + p, a, h + p, a, h + p - e, "L", a, h + e, "C", a, h, a, h, a + e, h]; d && d > b ? c > h + g && c < h + p - g ? m.splice(13, 3, "L", a + b, c - 6, a + b + 6, c, a + b, c + 6, a + b,
            h + p - e) : m.splice(13, 3, "L", a + b, p / 2, d, c, a + b, p / 2, a + b, h + p - e) : d && 0 > d ? c > h + g && c < h + p - g ? m.splice(33, 3, "L", a, c + 6, a - 6, c, a, c - 6, a, h + e) : m.splice(33, 3, "L", a, p / 2, d, c, a, p / 2, a, h + e) : c && c > p && d > a + g && d < a + b - g ? m.splice(23, 3, "L", d + 6, h + p, d, h + p + 6, d - 6, h + p, a + e, h + p) : c && 0 > c && d > a + g && d < a + b - g && m.splice(3, 3, "L", d - 6, h, d, h - 6, d + 6, h, b - e, h); return m
        }
      }, clipRect: function (h, b, p, c) { var e = a.uniqueKey(), g = this.createElement("clipPath").attr({ id: e }).add(this.defs); h = this.rect(h, b, p, c, 0).add(g); h.id = e; h.clipPath = g; h.count = 0; return h }, text: function (a,
        h, b, p) { var c = {}; if (p && (this.allowHTML || !this.forExport)) return this.html(a, h, b); c.x = Math.round(h || 0); b && (c.y = Math.round(b)); if (a || 0 === a) c.text = a; a = this.createElement("text").attr(c); p || (a.xSetter = function (a, h, b) { var p = b.getElementsByTagName("tspan"), c, e = b.getAttribute(h), g; for (g = 0; g < p.length; g++)c = p[g], c.getAttribute(h) === e && c.setAttribute(h, a); b.setAttribute(h, a) }); return a }, fontMetrics: function (a, b) {
          a = a || b && b.style && b.style.fontSize || this.style && this.style.fontSize; a = /px/.test(a) ? h(a) : /em/.test(a) ?
            parseFloat(a) * (b ? this.fontMetrics(null, b.parentNode).f : 16) : 12; b = 24 > a ? a + 3 : Math.round(1.2 * a); return { h: b, b: Math.round(.8 * b), f: a }
        }, rotCorr: function (a, h, p) { var c = a; h && p && (c = Math.max(c * Math.cos(h * b), 4)); return { x: -a / 3 * Math.sin(h * b), y: c } }, label: function (h, b, g, d, m, r, x, N, C) {
          var w = this, k = w.g("button" !== C && "label"), z = k.text = w.text("", 0, 0, x).attr({ zIndex: 1 }), O, M, y = 0, f = 3, q = 0, P, A, l, J, F, D = {}, v, I, t = /^url\((.*?)\)$/.test(d), K = t, Q, n, R, T; C && k.addClass("highcharts-" + C); K = t; Q = function () { return (v || 0) % 2 / 2 }; n = function () {
            var a =
              z.element.style, h = {}; M = (void 0 === P || void 0 === A || F) && u(z.textStr) && z.getBBox(); k.width = (P || M.width || 0) + 2 * f + q; k.height = (A || M.height || 0) + 2 * f; I = f + w.fontMetrics(a && a.fontSize, z).b; K && (O || (k.box = O = w.symbols[d] || t ? w.symbol(d) : w.rect(), O.addClass(("button" === C ? "" : "highcharts-label-box") + (C ? " highcharts-" + C + "-box" : "")), O.add(k), a = Q(), h.x = a, h.y = (N ? -I : 0) + a), h.width = Math.round(k.width), h.height = Math.round(k.height), O.attr(c(h, D)), D = {})
          }; R = function () {
            var a = q + f, h; h = N ? 0 : I; u(P) && M && ("center" === F || "right" === F) && (a +=
              { center: .5, right: 1 }[F] * (P - M.width)); if (a !== z.x || h !== z.y) z.attr("x", a), void 0 !== h && z.attr("y", h); z.x = a; z.y = h
          }; T = function (a, h) { O ? O.attr(a, h) : D[a] = h }; k.onAdd = function () { z.add(k); k.attr({ text: h || 0 === h ? h : "", x: b, y: g }); O && u(m) && k.attr({ anchorX: m, anchorY: r }) }; k.widthSetter = function (h) { P = a.isNumber(h) ? h : null }; k.heightSetter = function (a) { A = a }; k["text-alignSetter"] = function (a) { F = a }; k.paddingSetter = function (a) { u(a) && a !== f && (f = k.padding = a, R()) }; k.paddingLeftSetter = function (a) { u(a) && a !== q && (q = a, R()) }; k.alignSetter =
            function (a) { a = { left: 0, center: .5, right: 1 }[a]; a !== y && (y = a, M && k.attr({ x: l })) }; k.textSetter = function (a) { void 0 !== a && z.textSetter(a); n(); R() }; k["stroke-widthSetter"] = function (a, h) { a && (K = !0); v = this["stroke-width"] = a; T(h, a) }; k.strokeSetter = k.fillSetter = k.rSetter = function (a, h) { "r" !== h && ("fill" === h && a && (K = !0), k[h] = a); T(h, a) }; k.anchorXSetter = function (a, h) { m = k.anchorX = a; T(h, Math.round(a) - Q() - l) }; k.anchorYSetter = function (a, h) { r = k.anchorY = a; T(h, a - J) }; k.xSetter = function (a) {
              k.x = a; y && (a -= y * ((P || M.width) + 2 * f)); l =
                Math.round(a); k.attr("translateX", l)
            }; k.ySetter = function (a) { J = k.y = Math.round(a); k.attr("translateY", J) }; var U = k.css; return c(k, {
              css: function (a) { if (a) { var h = {}; a = E(a); e(k.textProps, function (b) { void 0 !== a[b] && (h[b] = a[b], delete a[b]) }); z.css(h) } return U.call(k, a) }, getBBox: function () { return { width: M.width + 2 * f, height: M.height + 2 * f, x: M.x - f, y: M.y - f } }, shadow: function (a) { a && (n(), O && O.shadow(a)); return k }, destroy: function () {
                p(k.element, "mouseenter"); p(k.element, "mouseleave"); z && (z = z.destroy()); O && (O = O.destroy());
                B.prototype.destroy.call(k); k = w = n = R = T = null
              }
            })
        }
    }); a.Renderer = H
  })(L); (function (a) {
    var B = a.attr, H = a.createElement, G = a.css, n = a.defined, l = a.each, f = a.extend, t = a.isFirefox, q = a.isMS, v = a.isWebKit, u = a.pick, b = a.pInt, d = a.SVGRenderer, k = a.win, e = a.wrap; f(a.SVGElement.prototype, {
      htmlCss: function (a) {
        var b = this.element; if (b = a && "SPAN" === b.tagName && a.width) delete a.width, this.textWidth = b, this.updateTransform(); a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden"); this.styles = f(this.styles, a); G(this.element,
          a); return this
      }, htmlGetBBox: function () { var a = this.element; return { x: a.offsetLeft, y: a.offsetTop, width: a.offsetWidth, height: a.offsetHeight } }, htmlUpdateTransform: function () {
        if (this.added) {
          var a = this.renderer, e = this.element, g = this.translateX || 0, d = this.translateY || 0, k = this.x || 0, f = this.y || 0, y = this.textAlign || "left", q = { left: 0, center: .5, right: 1 }[y], A = this.styles, D = A && A.whiteSpace; G(e, { marginLeft: g, marginTop: d }); this.shadows && l(this.shadows, function (a) { G(a, { marginLeft: g + 1, marginTop: d + 1 }) }); this.inverted && l(e.childNodes,
            function (b) { a.invertChild(b, e) }); if ("SPAN" === e.tagName) {
              var A = this.rotation, x = this.textWidth && b(this.textWidth), E = [A, y, e.innerHTML, this.textAlign].join(), C; (C = x !== this.oldTextWidth) && !(C = x > this.oldTextWidth) && ((C = this.textPxLength) || (G(e, { width: "", whiteSpace: D || "nowrap" }), C = e.offsetWidth), C = C > x); C && /[ \-]/.test(e.textContent || e.innerText) && (G(e, { width: x + "px", display: "block", whiteSpace: D || "normal" }), this.oldTextWidth = x); E !== this.cTT && (D = a.fontMetrics(e.style.fontSize).b, n(A) && A !== (this.oldRotation ||
                0) && this.setSpanRotation(A, q, D), this.getSpanCorrection(this.textPxLength || e.offsetWidth, D, q, A, y)); G(e, { left: k + (this.xCorr || 0) + "px", top: f + (this.yCorr || 0) + "px" }); this.cTT = E; this.oldRotation = A
            }
        } else this.alignOnAdd = !0
      }, setSpanRotation: function (a, b, e) { var c = {}, g = this.renderer.getTransformKey(); c[g] = c.transform = "rotate(" + a + "deg)"; c[g + (t ? "Origin" : "-origin")] = c.transformOrigin = 100 * b + "% " + e + "px"; G(this.element, c) }, getSpanCorrection: function (a, b, e) { this.xCorr = -a * e; this.yCorr = -b }
    }); f(d.prototype, {
      getTransformKey: function () {
        return q &&
          !/Edge/.test(k.navigator.userAgent) ? "-ms-transform" : v ? "-webkit-transform" : t ? "MozTransform" : k.opera ? "-o-transform" : ""
      }, html: function (a, b, g) {
        var c = this.createElement("span"), d = c.element, m = c.renderer, k = m.isSVG, q = function (a, b) { l(["opacity", "visibility"], function (c) { e(a, c + "Setter", function (a, c, e, g) { a.call(this, c, e, g); b[e] = c }) }) }; c.textSetter = function (a) { a !== d.innerHTML && delete this.bBox; this.textStr = a; d.innerHTML = u(a, ""); c.doTransform = !0 }; k && q(c, c.element.style); c.xSetter = c.ySetter = c.alignSetter = c.rotationSetter =
          function (a, b) { "align" === b && (b = "textAlign"); c[b] = a; c.doTransform = !0 }; c.attr({ text: a, x: Math.round(b), y: Math.round(g) }).css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize, position: "absolute" }); d.style.whiteSpace = "nowrap"; c.css = c.htmlCss; c.afterSetters = function () { this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1) }; k && (c.add = function (a) {
            var b, e = m.box.parentNode, g = []; if (this.parentGroup = a) {
              if (b = a.div, !b) {
                for (; a;)g.push(a), a = a.parentGroup; l(g.reverse(), function (a) {
                  function d(h,
                    b) { a[b] = h; "translateX" === b ? m.left = h + "px" : m.top = h + "px"; a.doTransform = !0 } var m, h = B(a.element, "class"); h && (h = { className: h }); b = a.div = a.div || H("div", h, { position: "absolute", left: (a.translateX || 0) + "px", top: (a.translateY || 0) + "px", display: a.display, opacity: a.opacity, pointerEvents: a.styles && a.styles.pointerEvents }, b || e); m = b.style; f(a, {
                      classSetter: function (a) { return function (h) { this.element.setAttribute("class", h); a.className = h } }(b), on: function () { g[0].div && c.on.apply({ element: g[0].div }, arguments); return a },
                      translateXSetter: d, translateYSetter: d
                    }); q(a, m)
                })
              }
            } else b = e; b.appendChild(d); c.added = !0; c.alignOnAdd && c.htmlUpdateTransform(); return c
          }); return c
      }
    })
  })(L); (function (a) {
    var B = a.defined, H = a.each, G = a.extend, n = a.merge, l = a.pick, f = a.timeUnits, t = a.win; a.Time = function (a) { this.update(a, !1) }; a.Time.prototype = {
      defaultOptions: {}, update: function (f) {
        var q = l(f && f.useUTC, !0), u = this; this.options = f = n(!0, this.options || {}, f); this.Date = f.Date || t.Date; this.timezoneOffset = (this.useUTC = q) && f.timezoneOffset; this.getTimezoneOffset =
          this.timezoneOffsetFunction(); (this.variableTimezone = !(q && !f.getTimezoneOffset && !f.timezone)) || this.timezoneOffset ? (this.get = function (a, d) { var b = d.getTime(), e = b - u.getTimezoneOffset(d); d.setTime(e); a = d["getUTC" + a](); d.setTime(b); return a }, this.set = function (b, d, k) { var e; if (-1 !== a.inArray(b, ["Milliseconds", "Seconds", "Minutes"])) d["set" + b](k); else e = u.getTimezoneOffset(d), e = d.getTime() - e, d.setTime(e), d["setUTC" + b](k), b = u.getTimezoneOffset(d), e = d.getTime() + b, d.setTime(e) }) : q ? (this.get = function (a, d) {
            return d["getUTC" +
              a]()
          }, this.set = function (a, d, k) { return d["setUTC" + a](k) }) : (this.get = function (a, d) { return d["get" + a]() }, this.set = function (a, d, k) { return d["set" + a](k) })
      }, makeTime: function (f, v, u, b, d, k) { var e, c, m; this.useUTC ? (e = this.Date.UTC.apply(0, arguments), c = this.getTimezoneOffset(e), e += c, m = this.getTimezoneOffset(e), c !== m ? e += m - c : c - 36E5 !== this.getTimezoneOffset(e - 36E5) || a.isSafari || (e -= 36E5)) : e = (new this.Date(f, v, l(u, 1), l(b, 0), l(d, 0), l(k, 0))).getTime(); return e }, timezoneOffsetFunction: function () {
        var f = this, l = this.options,
        u = t.moment; if (!this.useUTC) return function (a) { return 6E4 * (new Date(a)).getTimezoneOffset() }; if (l.timezone) { if (u) return function (a) { return 6E4 * -u.tz(a, l.timezone).utcOffset() }; a.error(25) } return this.useUTC && l.getTimezoneOffset ? function (a) { return 6E4 * l.getTimezoneOffset(a) } : function () { return 6E4 * (f.timezoneOffset || 0) }
      }, dateFormat: function (f, l, u) {
        if (!a.defined(l) || isNaN(l)) return a.defaultOptions.lang.invalidDate || ""; f = a.pick(f, "%Y-%m-%d %H:%M:%S"); var b = this, d = new this.Date(l), k = this.get("Hours", d),
          e = this.get("Day", d), c = this.get("Date", d), m = this.get("Month", d), g = this.get("FullYear", d), r = a.defaultOptions.lang, z = r.weekdays, q = r.shortWeekdays, y = a.pad, d = a.extend({ a: q ? q[e] : z[e].substr(0, 3), A: z[e], d: y(c), e: y(c, 2, " "), w: e, b: r.shortMonths[m], B: r.months[m], m: y(m + 1), y: g.toString().substr(2, 2), Y: g, H: y(k), k: k, I: y(k % 12 || 12), l: k % 12 || 12, M: y(b.get("Minutes", d)), p: 12 > k ? "AM" : "PM", P: 12 > k ? "am" : "pm", S: y(d.getSeconds()), L: y(Math.round(l % 1E3), 3) }, a.dateFormats); a.objectEach(d, function (a, c) {
            for (; -1 !== f.indexOf("%" +
              c);)f = f.replace("%" + c, "function" === typeof a ? a.call(b, l) : a)
          }); return u ? f.substr(0, 1).toUpperCase() + f.substr(1) : f
      }, getTimeTicks: function (a, v, u, b) {
        var d = this, k = [], e = {}, c, m = new d.Date(v), g = a.unitRange, r = a.count || 1, z; if (B(v)) {
          d.set("Milliseconds", m, g >= f.second ? 0 : r * Math.floor(d.get("Milliseconds", m) / r)); g >= f.second && d.set("Seconds", m, g >= f.minute ? 0 : r * Math.floor(d.get("Seconds", m) / r)); g >= f.minute && d.set("Minutes", m, g >= f.hour ? 0 : r * Math.floor(d.get("Minutes", m) / r)); g >= f.hour && d.set("Hours", m, g >= f.day ? 0 : r * Math.floor(d.get("Hours",
            m) / r)); g >= f.day && d.set("Date", m, g >= f.month ? 1 : r * Math.floor(d.get("Date", m) / r)); g >= f.month && (d.set("Month", m, g >= f.year ? 0 : r * Math.floor(d.get("Month", m) / r)), c = d.get("FullYear", m)); g >= f.year && d.set("FullYear", m, c - c % r); g === f.week && d.set("Date", m, d.get("Date", m) - d.get("Day", m) + l(b, 1)); c = d.get("FullYear", m); b = d.get("Month", m); var q = d.get("Date", m), y = d.get("Hours", m); v = m.getTime(); d.variableTimezone && (z = u - v > 4 * f.month || d.getTimezoneOffset(v) !== d.getTimezoneOffset(u)); m = m.getTime(); for (v = 1; m < u;)k.push(m), m =
              g === f.year ? d.makeTime(c + v * r, 0) : g === f.month ? d.makeTime(c, b + v * r) : !z || g !== f.day && g !== f.week ? z && g === f.hour && 1 < r ? d.makeTime(c, b, q, y + v * r) : m + g * r : d.makeTime(c, b, q + v * r * (g === f.day ? 1 : 7)), v++; k.push(m); g <= f.hour && 1E4 > k.length && H(k, function (a) { 0 === a % 18E5 && "000000000" === d.dateFormat("%H%M%S%L", a) && (e[a] = "day") })
        } k.info = G(a, { higherRanks: e, totalRange: g * r }); return k
      }
    }
  })(L); (function (a) {
    var B = a.color, H = a.merge; a.defaultOptions = {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: {}, time: a.Time.prototype.defaultOptions,
      chart: { borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } }, width: null, height: null, borderColor: "#335cad", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" }, title: { text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { text: "", align: "center", widthAdjust: -44 }, plotOptions: {}, labels: { style: { position: "absolute", color: "#333333" } }, legend: {
        enabled: !0, align: "center", layout: "horizontal", labelFormatter: function () { return this.name },
        borderColor: "#999999", borderRadius: 0, navigation: { activeColor: "#003399", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#cccccc" }, shadow: !1, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: !0, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } }
      }, loading: {
        labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: {
          position: "absolute",
          backgroundColor: "#ffffff", opacity: .5, textAlign: "center"
        }
      }, tooltip: {
        enabled: !0, animation: a.svg, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", padding: 8, snap: a.isTouchDevice ? 25 : 10, backgroundColor: B("#f7f7f7").setOpacity(.85).get(), borderWidth: 1, headerFormat: '\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',
        pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e', shadow: !0, style: { color: "#333333", cursor: "default", fontSize: "12px", pointerEvents: "none", whiteSpace: "nowrap" }
      }, credits: { enabled: !0, href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "9px" }, text: "Highcharts.com" }
    }; a.setOptions = function (B) {
      a.defaultOptions = H(!0, a.defaultOptions, B); a.time.update(H(a.defaultOptions.global,
        a.defaultOptions.time), !1); return a.defaultOptions
    }; a.getOptions = function () { return a.defaultOptions }; a.defaultPlotOptions = a.defaultOptions.plotOptions; a.time = new a.Time(H(a.defaultOptions.global, a.defaultOptions.time)); a.dateFormat = function (B, n, l) { return a.time.dateFormat(B, n, l) }
  })(L); (function (a) {
    var B = a.correctFloat, H = a.defined, G = a.destroyObjectProperties, n = a.isNumber, l = a.merge, f = a.pick, t = a.deg2rad; a.Tick = function (a, f, l, b) {
      this.axis = a; this.pos = f; this.type = l || ""; this.isNewLabel = this.isNew = !0; l ||
        b || this.addLabel()
    }; a.Tick.prototype = {
      addLabel: function () {
        var a = this.axis, v = a.options, u = a.chart, b = a.categories, d = a.names, k = this.pos, e = v.labels, c = a.tickPositions, m = k === c[0], g = k === c[c.length - 1], d = b ? f(b[k], d[k], k) : k, b = this.label, c = c.info, r; a.isDatetimeAxis && c && (r = v.dateTimeLabelFormats[c.higherRanks[k] || c.unitName]); this.isFirst = m; this.isLast = g; v = a.labelFormatter.call({ axis: a, chart: u, isFirst: m, isLast: g, dateTimeLabelFormat: r, value: a.isLog ? B(a.lin2log(d)) : d, pos: k }); if (H(b)) b && b.attr({ text: v }); else {
          if (this.label =
            b = H(v) && e.enabled ? u.renderer.text(v, 0, 0, e.useHTML).css(l(e.style)).add(a.labelGroup) : null) b.textPxLength = b.getBBox().width; this.rotation = 0
        }
      }, getLabelSize: function () { return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0 }, handleOverflow: function (a) {
        var l = this.axis, q = l.options.labels, b = a.x, d = l.chart.chartWidth, k = l.chart.spacing, e = f(l.labelLeft, Math.min(l.pos, k[3])), k = f(l.labelRight, Math.max(l.isRadial ? 0 : l.pos + l.len, d - k[1])), c = this.label, m = this.rotation, g = { left: 0, center: .5, right: 1 }[l.labelAlign ||
          c.attr("align")], r = c.getBBox().width, z = l.getSlotWidth(), K = z, y = 1, I, A = {}; if (m || !1 === q.overflow) 0 > m && b - g * r < e ? I = Math.round(b / Math.cos(m * t) - e) : 0 < m && b + g * r > k && (I = Math.round((d - b) / Math.cos(m * t))); else if (d = b + (1 - g) * r, b - g * r < e ? K = a.x + K * (1 - g) - e : d > k && (K = k - a.x + K * g, y = -1), K = Math.min(z, K), K < z && "center" === l.labelAlign && (a.x += y * (z - K - g * (z - Math.min(r, K)))), r > K || l.autoRotation && (c.styles || {}).width) I = K; I && (A.width = I, (q.style || {}).textOverflow || (A.textOverflow = "ellipsis"), c.css(A))
      }, getPosition: function (a, f, l, b) {
        var d = this.axis,
        k = d.chart, e = b && k.oldChartHeight || k.chartHeight; return { x: a ? d.translate(f + l, null, null, b) + d.transB : d.left + d.offset + (d.opposite ? (b && k.oldChartWidth || k.chartWidth) - d.right - d.left : 0), y: a ? e - d.bottom + d.offset - (d.opposite ? d.height : 0) : e - d.translate(f + l, null, null, b) - d.transB }
      }, getLabelPosition: function (a, f, l, b, d, k, e, c) {
        var m = this.axis, g = m.transA, r = m.reversed, z = m.staggerLines, q = m.tickRotCorr || { x: 0, y: 0 }, y = d.y, u = b || m.reserveSpaceDefault ? 0 : -m.labelOffset * ("center" === m.labelAlign ? .5 : 1); H(y) || (y = 0 === m.side ? l.rotation ?
          -8 : -l.getBBox().height : 2 === m.side ? q.y + 8 : Math.cos(l.rotation * t) * (q.y - l.getBBox(!1, 0).height / 2)); a = a + d.x + u + q.x - (k && b ? k * g * (r ? -1 : 1) : 0); f = f + y - (k && !b ? k * g * (r ? 1 : -1) : 0); z && (l = e / (c || 1) % z, m.opposite && (l = z - l - 1), f += m.labelOffset / z * l); return { x: a, y: Math.round(f) }
      }, getMarkPath: function (a, f, l, b, d, k) { return k.crispLine(["M", a, f, "L", a + (d ? 0 : -l), f + (d ? l : 0)], b) }, renderGridLine: function (a, f, l) {
        var b = this.axis, d = b.options, k = this.gridLine, e = {}, c = this.pos, m = this.type, g = b.tickmarkOffset, r = b.chart.renderer, z = m ? m + "Grid" : "grid",
        q = d[z + "LineWidth"], y = d[z + "LineColor"], d = d[z + "LineDashStyle"]; k || (e.stroke = y, e["stroke-width"] = q, d && (e.dashstyle = d), m || (e.zIndex = 1), a && (e.opacity = 0), this.gridLine = k = r.path().attr(e).addClass("highcharts-" + (m ? m + "-" : "") + "grid-line").add(b.gridGroup)); if (!a && k && (a = b.getPlotLinePath(c + g, k.strokeWidth() * l, a, !0))) k[this.isNew ? "attr" : "animate"]({ d: a, opacity: f })
      }, renderMark: function (a, l, u) {
        var b = this.axis, d = b.options, k = b.chart.renderer, e = this.type, c = e ? e + "Tick" : "tick", m = b.tickSize(c), g = this.mark, r = !g, z = a.x;
        a = a.y; var q = f(d[c + "Width"], !e && b.isXAxis ? 1 : 0), d = d[c + "Color"]; m && (b.opposite && (m[0] = -m[0]), r && (this.mark = g = k.path().addClass("highcharts-" + (e ? e + "-" : "") + "tick").add(b.axisGroup), g.attr({ stroke: d, "stroke-width": q })), g[r ? "attr" : "animate"]({ d: this.getMarkPath(z, a, m[0], g.strokeWidth() * u, b.horiz, k), opacity: l }))
      }, renderLabel: function (a, l, u, b) {
        var d = this.axis, k = d.horiz, e = d.options, c = this.label, m = e.labels, g = m.step, d = d.tickmarkOffset, r = !0, z = a.x; a = a.y; c && n(z) && (c.xy = a = this.getLabelPosition(z, a, c, k, m, d, b, g), this.isFirst &&
          !this.isLast && !f(e.showFirstLabel, 1) || this.isLast && !this.isFirst && !f(e.showLastLabel, 1) ? r = !1 : !k || m.step || m.rotation || l || 0 === u || this.handleOverflow(a), g && b % g && (r = !1), r && n(a.y) ? (a.opacity = u, c[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (c.attr("y", -9999), this.isNewLabel = !0))
      }, render: function (a, l, u) {
        var b = this.axis, d = b.horiz, k = this.getPosition(d, this.pos, b.tickmarkOffset, l), e = k.x, c = k.y, b = d && e === b.pos + b.len || !d && c === b.pos ? -1 : 1; u = f(u, 1); this.isActive = !0; this.renderGridLine(l, u, b); this.renderMark(k,
          u, b); this.renderLabel(k, l, u, a); this.isNew = !1
      }, destroy: function () { G(this, this.axis) }
    }
  })(L); var V = function (a) {
    var B = a.addEvent, H = a.animObject, G = a.arrayMax, n = a.arrayMin, l = a.color, f = a.correctFloat, t = a.defaultOptions, q = a.defined, v = a.deg2rad, u = a.destroyObjectProperties, b = a.each, d = a.extend, k = a.fireEvent, e = a.format, c = a.getMagnitude, m = a.grep, g = a.inArray, r = a.isArray, z = a.isNumber, K = a.isString, y = a.merge, I = a.normalizeTickInterval, A = a.objectEach, D = a.pick, x = a.removeEvent, E = a.splat, C = a.syncTimeout, J = a.Tick, F = function () {
      this.init.apply(this,
        arguments)
    }; a.extend(F.prototype, {
      defaultOptions: {
        dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, labels: { enabled: !0, style: { color: "#666666", cursor: "default", fontSize: "11px" }, x: 0 }, maxPadding: .01, minorTickLength: 2, minorTickPosition: "outside", minPadding: .01, startOfWeek: 1, startOnTick: !1, tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", title: {
          align: "middle",
          style: { color: "#666666" }
        }, type: "linear", minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999", lineColor: "#ccd6eb", lineWidth: 1, gridLineColor: "#e6e6e6", tickColor: "#ccd6eb"
      }, defaultYAxisOptions: {
        endOnTick: !0, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8 }, maxPadding: .05, minPadding: .05, startOnTick: !0, title: { rotation: 270, text: "Values" }, stackLabels: {
          allowOverlap: !1, enabled: !1, formatter: function () { return a.numberFormat(this.total, -1) }, style: {
            fontSize: "11px", fontWeight: "bold", color: "#000000",
            textOutline: "1px contrast"
          }
        }, gridLineWidth: 1, lineWidth: 0
      }, defaultLeftAxisOptions: { labels: { x: -15 }, title: { rotation: 270 } }, defaultRightAxisOptions: { labels: { x: 15 }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, init: function (a, b) {
        var h = b.isX, p = this; p.chart = a; p.horiz = a.inverted && !p.isZAxis ? !h : h; p.isXAxis = h; p.coll = p.coll || (h ? "xAxis" : "yAxis"); p.opposite = b.opposite; p.side = b.side || (p.horiz ?
          p.opposite ? 0 : 2 : p.opposite ? 1 : 3); p.setOptions(b); var c = this.options, e = c.type; p.labelFormatter = c.labels.formatter || p.defaultLabelFormatter; p.userOptions = b; p.minPixelPadding = 0; p.reversed = c.reversed; p.visible = !1 !== c.visible; p.zoomEnabled = !1 !== c.zoomEnabled; p.hasNames = "category" === e || !0 === c.categories; p.categories = c.categories || p.hasNames; p.names = p.names || []; p.plotLinesAndBandsGroups = {}; p.isLog = "logarithmic" === e; p.isDatetimeAxis = "datetime" === e; p.positiveValuesOnly = p.isLog && !p.allowNegativeLog; p.isLinked =
            q(c.linkedTo); p.ticks = {}; p.labelEdge = []; p.minorTicks = {}; p.plotLinesAndBands = []; p.alternateBands = {}; p.len = 0; p.minRange = p.userMinRange = c.minRange || c.maxZoom; p.range = c.range; p.offset = c.offset || 0; p.stacks = {}; p.oldStacks = {}; p.stacksTouched = 0; p.max = null; p.min = null; p.crosshair = D(c.crosshair, E(a.options.tooltip.crosshairs)[h ? 0 : 1], !1); b = p.options.events; -1 === g(p, a.axes) && (h ? a.axes.splice(a.xAxis.length, 0, p) : a.axes.push(p), a[p.coll].push(p)); p.series = p.series || []; a.inverted && !p.isZAxis && h && void 0 === p.reversed &&
              (p.reversed = !0); A(b, function (a, h) { B(p, h, a) }); p.lin2log = c.linearToLogConverter || p.lin2log; p.isLog && (p.val2lin = p.log2lin, p.lin2val = p.lin2log)
      }, setOptions: function (a) { this.options = y(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], y(t[this.coll], a)) }, defaultLabelFormatter: function () {
        var h = this.axis, b = this.value, c = h.chart.time, g = h.categories, d = this.dateTimeLabelFormat,
        m = t.lang, r = m.numericSymbols, m = m.numericSymbolMagnitude || 1E3, x = r && r.length, k, f = h.options.labels.format, h = h.isLog ? Math.abs(b) : h.tickInterval; if (f) k = e(f, this, c); else if (g) k = b; else if (d) k = c.dateFormat(d, b); else if (x && 1E3 <= h) for (; x-- && void 0 === k;)c = Math.pow(m, x + 1), h >= c && 0 === 10 * b % c && null !== r[x] && 0 !== b && (k = a.numberFormat(b / c, -1) + r[x]); void 0 === k && (k = 1E4 <= Math.abs(b) ? a.numberFormat(b, -1) : a.numberFormat(b, -1, void 0, "")); return k
      }, getSeriesExtremes: function () {
        var a = this, p = a.chart; a.hasVisibleSeries = !1; a.dataMin =
          a.dataMax = a.threshold = null; a.softThreshold = !a.isXAxis; a.buildStacks && a.buildStacks(); b(a.series, function (h) {
            if (h.visible || !p.options.chart.ignoreHiddenSeries) {
              var b = h.options, c = b.threshold, e; a.hasVisibleSeries = !0; a.positiveValuesOnly && 0 >= c && (c = null); if (a.isXAxis) b = h.xData, b.length && (h = n(b), e = G(b), z(h) || h instanceof Date || (b = m(b, z), h = n(b), e = G(b)), b.length && (a.dataMin = Math.min(D(a.dataMin, b[0], h), h), a.dataMax = Math.max(D(a.dataMax, b[0], e), e))); else if (h.getExtremes(), e = h.dataMax, h = h.dataMin, q(h) && q(e) &&
                (a.dataMin = Math.min(D(a.dataMin, h), h), a.dataMax = Math.max(D(a.dataMax, e), e)), q(c) && (a.threshold = c), !b.softThreshold || a.positiveValuesOnly) a.softThreshold = !1
            }
          })
      }, translate: function (a, b, c, e, g, d) {
        var h = this.linkedParent || this, p = 1, m = 0, r = e ? h.oldTransA : h.transA; e = e ? h.oldMin : h.min; var x = h.minPixelPadding; g = (h.isOrdinal || h.isBroken || h.isLog && g) && h.lin2val; r || (r = h.transA); c && (p *= -1, m = h.len); h.reversed && (p *= -1, m -= p * (h.sector || h.len)); b ? (a = (a * p + m - x) / r + e, g && (a = h.lin2val(a))) : (g && (a = h.val2lin(a)), a = z(e) ? p * (a - e) *
          r + m + p * x + (z(d) ? r * d : 0) : void 0); return a
      }, toPixels: function (a, b) { return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos) }, toValue: function (a, b) { return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0) }, getPlotLinePath: function (a, b, c, e, g) {
        var h = this.chart, p = this.left, d = this.top, m, r, x = c && h.oldChartHeight || h.chartHeight, k = c && h.oldChartWidth || h.chartWidth, N; m = this.transB; var f = function (a, h, b) { if (a < h || a > b) e ? a = Math.min(Math.max(h, a), b) : N = !0; return a }; g = D(g, this.translate(a, null, null, c)); g = Math.min(Math.max(-1E5,
          g), 1E5); a = c = Math.round(g + m); m = r = Math.round(x - g - m); z(g) ? this.horiz ? (m = d, r = x - this.bottom, a = c = f(a, p, p + this.width)) : (a = p, c = k - this.right, m = r = f(m, d, d + this.height)) : (N = !0, e = !1); return N && !e ? null : h.renderer.crispLine(["M", a, m, "L", c, r], b || 1)
      }, getLinearTickPositions: function (a, b, c) { var h, p = f(Math.floor(b / a) * a); c = f(Math.ceil(c / a) * a); var e = [], g; f(p + a) === p && (g = 20); if (this.single) return [b]; for (b = p; b <= c;) { e.push(b); b = f(b + a, g); if (b === h) break; h = b } return e }, getMinorTickInterval: function () {
        var a = this.options; return !0 ===
          a.minorTicks ? D(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval
      }, getMinorTickPositions: function () {
        var a = this, p = a.options, c = a.tickPositions, e = a.minorTickInterval, g = [], d = a.pointRangePadding || 0, m = a.min - d, d = a.max + d, r = d - m; if (r && r / e < a.len / 3) if (a.isLog) b(this.paddedTicks, function (h, b, p) { b && g.push.apply(g, a.getLogTickPositions(e, p[b - 1], p[b], !0)) }); else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) g = g.concat(a.getTimeTicks(a.normalizeTimeTickInterval(e), m, d, p.startOfWeek));
        else for (p = m + (c[0] - m) % e; p <= d && p !== g[0]; p += e)g.push(p); 0 !== g.length && a.trimTicks(g); return g
      }, adjustForMinRange: function () {
        var a = this.options, p = this.min, c = this.max, e, g, d, m, r, x, k, f; this.isXAxis && void 0 === this.minRange && !this.isLog && (q(a.min) || q(a.max) ? this.minRange = null : (b(this.series, function (a) { x = a.xData; for (m = k = a.xIncrement ? 1 : x.length - 1; 0 < m; m--)if (r = x[m] - x[m - 1], void 0 === d || r < d) d = r }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin))); c - p < this.minRange && (g = this.dataMax - this.dataMin >= this.minRange,
          f = this.minRange, e = (f - c + p) / 2, e = [p - e, D(a.min, p - e)], g && (e[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), p = G(e), c = [p + f, D(a.max, p + f)], g && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), c = n(c), c - p < f && (e[0] = c - f, e[1] = D(a.min, c - f), p = G(e))); this.min = p; this.max = c
      }, getClosest: function () { var a; this.categories ? a = 1 : b(this.series, function (h) { var b = h.closestPointRange, p = h.visible || !h.chart.options.chart.ignoreHiddenSeries; !h.noSharedTooltip && q(b) && p && (a = q(a) ? Math.min(a, b) : b) }); return a }, nameToX: function (a) {
        var h =
          r(this.categories), b = h ? this.categories : this.names, c = a.options.x, e; a.series.requireSorting = !1; q(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : h ? g(a.name, b) : D(b["s" + a.name], -1)); -1 === c ? h || (e = b.length) : e = c; void 0 !== e && (this.names[e] = a.name, this.names["s" + a.name] = e); return e
      }, updateNames: function () {
        var a = this, p = this.names, c = p.length; if (0 < c) {
          for (; c--;)delete p["s" + p[c]]; p.length = 0; this.minRange = this.userMinRange; b(this.series || [], function (h) {
            h.xIncrement = null; if (!h.points || h.isDirtyData) h.processData(),
              h.generatePoints(); b(h.points, function (b, p) { var c; b.options && (c = a.nameToX(b), void 0 !== c && c !== b.x && (b.x = c, h.xData[p] = c)) })
          })
        }
      }, setAxisTranslation: function (a) {
        var h = this, c = h.max - h.min, e = h.axisPointRange || 0, g, d = 0, m = 0, r = h.linkedParent, x = !!h.categories, k = h.transA, f = h.isXAxis; if (f || x || e) g = h.getClosest(), r ? (d = r.minPointOffset, m = r.pointRangePadding) : b(h.series, function (a) {
          var b = x ? 1 : f ? D(a.options.pointRange, g, 0) : h.axisPointRange || 0; a = a.options.pointPlacement; e = Math.max(e, b); h.single || (d = Math.max(d, K(a) ? 0 :
            b / 2), m = Math.max(m, "on" === a ? 0 : b))
        }), r = h.ordinalSlope && g ? h.ordinalSlope / g : 1, h.minPointOffset = d *= r, h.pointRangePadding = m *= r, h.pointRange = Math.min(e, c), f && (h.closestPointRange = g); a && (h.oldTransA = k); h.translationSlope = h.transA = k = h.options.staticScale || h.len / (c + m || 1); h.transB = h.horiz ? h.left : h.bottom; h.minPixelPadding = k * d
      }, minFromRange: function () { return this.max - this.range }, setTickInterval: function (h) {
        var p = this, e = p.chart, g = p.options, d = p.isLog, m = p.log2lin, r = p.isDatetimeAxis, x = p.isXAxis, C = p.isLinked, E = g.maxPadding,
        l = g.minPadding, y = g.tickInterval, A = g.tickPixelInterval, J = p.categories, F = p.threshold, u = p.softThreshold, t, v, n, K; r || J || C || this.getTickAmount(); n = D(p.userMin, g.min); K = D(p.userMax, g.max); C ? (p.linkedParent = e[p.coll][g.linkedTo], e = p.linkedParent.getExtremes(), p.min = D(e.min, e.dataMin), p.max = D(e.max, e.dataMax), g.type !== p.linkedParent.options.type && a.error(11, 1)) : (!u && q(F) && (p.dataMin >= F ? (t = F, l = 0) : p.dataMax <= F && (v = F, E = 0)), p.min = D(n, t, p.dataMin), p.max = D(K, v, p.dataMax)); d && (p.positiveValuesOnly && !h && 0 >= Math.min(p.min,
          D(p.dataMin, p.min)) && a.error(10, 1), p.min = f(m(p.min), 15), p.max = f(m(p.max), 15)); p.range && q(p.max) && (p.userMin = p.min = n = Math.max(p.dataMin, p.minFromRange()), p.userMax = K = p.max, p.range = null); k(p, "foundExtremes"); p.beforePadding && p.beforePadding(); p.adjustForMinRange(); !(J || p.axisPointRange || p.usePercentage || C) && q(p.min) && q(p.max) && (m = p.max - p.min) && (!q(n) && l && (p.min -= m * l), !q(K) && E && (p.max += m * E)); z(g.softMin) && !z(p.userMin) && (p.min = Math.min(p.min, g.softMin)); z(g.softMax) && !z(p.userMax) && (p.max = Math.max(p.max,
            g.softMax)); z(g.floor) && (p.min = Math.max(p.min, g.floor)); z(g.ceiling) && (p.max = Math.min(p.max, g.ceiling)); u && q(p.dataMin) && (F = F || 0, !q(n) && p.min < F && p.dataMin >= F ? p.min = F : !q(K) && p.max > F && p.dataMax <= F && (p.max = F)); p.tickInterval = p.min === p.max || void 0 === p.min || void 0 === p.max ? 1 : C && !y && A === p.linkedParent.options.tickPixelInterval ? y = p.linkedParent.tickInterval : D(y, this.tickAmount ? (p.max - p.min) / Math.max(this.tickAmount - 1, 1) : void 0, J ? 1 : (p.max - p.min) * A / Math.max(p.len, A)); x && !h && b(p.series, function (a) {
              a.processData(p.min !==
                p.oldMin || p.max !== p.oldMax)
            }); p.setAxisTranslation(!0); p.beforeSetTickPositions && p.beforeSetTickPositions(); p.postProcessTickInterval && (p.tickInterval = p.postProcessTickInterval(p.tickInterval)); p.pointRange && !y && (p.tickInterval = Math.max(p.pointRange, p.tickInterval)); h = D(g.minTickInterval, p.isDatetimeAxis && p.closestPointRange); !y && p.tickInterval < h && (p.tickInterval = h); r || d || y || (p.tickInterval = I(p.tickInterval, null, c(p.tickInterval), D(g.allowDecimals, !(.5 < p.tickInterval && 5 > p.tickInterval && 1E3 < p.max &&
              9999 > p.max)), !!this.tickAmount)); this.tickAmount || (p.tickInterval = p.unsquish()); this.setTickPositions()
      }, setTickPositions: function () {
        var a = this.options, b, c = a.tickPositions; b = this.getMinorTickInterval(); var e = a.tickPositioner, g = a.startOnTick, d = a.endOnTick; this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0; this.minorTickInterval = "auto" === b && this.tickInterval ? this.tickInterval / 5 : b; this.single = this.min === this.max && q(this.min) && !this.tickAmount && (parseInt(this.min,
          10) === this.min || !1 !== a.allowDecimals); this.tickPositions = b = c && c.slice(); !b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, e && (e = e.apply(this, [this.min,
          this.max]))) && (this.tickPositions = b = e); this.paddedTicks = b.slice(0); this.trimTicks(b, g, d); this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), c || e || this.adjustTickAmount())
      }, trimTicks: function (a, b, c) { var h = a[0], e = a[a.length - 1], p = this.minPointOffset || 0; if (!this.isLinked) { if (b && -Infinity !== h) this.min = h; else for (; this.min - p > a[0];)a.shift(); if (c) this.max = e; else for (; this.max + p < a[a.length - 1];)a.pop(); 0 === a.length && q(h) && !this.options.tickPositions && a.push((e + h) / 2) } }, alignToOthers: function () {
        var a =
          {}, c, e = this.options; !1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || this.isLog || b(this.chart[this.coll], function (h) { var b = h.options, b = [h.horiz ? b.left : b.top, b.width, b.height, b.pane].join(); h.series.length && (a[b] ? c = !0 : a[b] = 1) }); return c
      }, getTickAmount: function () {
        var a = this.options, b = a.tickAmount, c = a.tickPixelInterval; !q(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2); !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1); 4 > b && (this.finalTickAmt =
          b, b = 5); this.tickAmount = b
      }, adjustTickAmount: function () {
        var a = this.tickInterval, b = this.tickPositions, c = this.tickAmount, e = this.finalTickAmt, g = b && b.length, d = D(this.threshold, this.softThreshold ? 0 : null); if (this.hasData()) {
          if (g < c) { for (; b.length < c;)b.length % 2 || this.min === d ? b.push(f(b[b.length - 1] + a)) : b.unshift(f(b[0] - a)); this.transA *= (g - 1) / (c - 1); this.min = b[0]; this.max = b[b.length - 1] } else g > c && (this.tickInterval *= 2, this.setTickPositions()); if (q(e)) {
            for (a = c = b.length; a--;)(3 === e && 1 === a % 2 || 2 >= e && 0 < a && a < c - 1) && b.splice(a,
              1); this.finalTickAmt = void 0
          }
        }
      }, setScale: function () {
        var a, c; this.oldMin = this.min; this.oldMax = this.max; this.oldAxisLength = this.len; this.setAxisSize(); c = this.len !== this.oldAxisLength; b(this.series, function (b) { if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0 }); c || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin =
          this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = c || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks()
      }, setExtremes: function (a, c, e, g, m) { var h = this, p = h.chart; e = D(e, !0); b(h.series, function (a) { delete a.kdTree }); m = d(m, { min: a, max: c }); k(h, "setExtremes", m, function () { h.userMin = a; h.userMax = c; h.eventArgs = m; e && p.redraw(g) }) }, zoom: function (a, b) {
        var h = this.dataMin, c = this.dataMax, e = this.options, g = Math.min(h, D(e.min, h)), e = Math.max(c, D(e.max, c)); if (a !== this.min ||
          b !== this.max) this.allowZoomOutside || (q(h) && (a < g && (a = g), a > e && (a = e)), q(c) && (b < g && (b = g), b > e && (b = e))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, { trigger: "zoom" }); return !0
      }, setAxisSize: function () {
        var b = this.chart, c = this.options, e = c.offsets || [0, 0, 0, 0], g = this.horiz, d = this.width = Math.round(a.relativeLength(D(c.width, b.plotWidth - e[3] + e[1]), b.plotWidth)), m = this.height = Math.round(a.relativeLength(D(c.height, b.plotHeight - e[0] + e[2]), b.plotHeight)), r = this.top = Math.round(a.relativeLength(D(c.top,
          b.plotTop + e[0]), b.plotHeight, b.plotTop)), c = this.left = Math.round(a.relativeLength(D(c.left, b.plotLeft + e[3]), b.plotWidth, b.plotLeft)); this.bottom = b.chartHeight - m - r; this.right = b.chartWidth - d - c; this.len = Math.max(g ? d : m, 0); this.pos = g ? c : r
      }, getExtremes: function () { var a = this.isLog, b = this.lin2log; return { min: a ? f(b(this.min)) : this.min, max: a ? f(b(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax } }, getThreshold: function (a) {
        var b = this.isLog, h = this.lin2log, c = b ?
          h(this.min) : this.min, b = b ? h(this.max) : this.max; null === a ? a = c : c > a ? a = c : b < a && (a = b); return this.translate(a, 0, 1, 0, 1)
      }, autoLabelAlign: function (a) { a = (D(a, 0) - 90 * this.side + 720) % 360; return 15 < a && 165 > a ? "right" : 195 < a && 345 > a ? "left" : "center" }, tickSize: function (a) { var b = this.options, h = b[a + "Length"], c = D(b[a + "Width"], "tick" === a && this.isXAxis ? 1 : 0); if (c && h) return "inside" === b[a + "Position"] && (h = -h), [h, c] }, labelMetrics: function () {
        var a = this.tickPositions && this.tickPositions[0] || 0; return this.chart.renderer.fontMetrics(this.options.labels.style &&
          this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label)
      }, unsquish: function () {
        var a = this.options.labels, c = this.horiz, e = this.tickInterval, g = e, d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e), m, r = a.rotation, x = this.labelMetrics(), k, f = Number.MAX_VALUE, C, E = function (a) { a /= d || 1; a = 1 < a ? Math.ceil(a) : 1; return a * e }; c ? (C = !a.staggerLines && !a.step && (q(r) ? [r] : d < D(a.autoRotationLimit, 80) && a.autoRotation)) && b(C, function (a) {
          var b; if (a === r || a && -90 <= a && 90 >= a) k = E(Math.abs(x.h / Math.sin(v * a))), b = k +
            Math.abs(a / 360), b < f && (f = b, m = a, g = k)
        }) : a.step || (g = E(x.h)); this.autoRotation = C; this.labelRotation = D(m, r); return g
      }, getSlotWidth: function () { var a = this.chart, b = this.horiz, c = this.options.labels, e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), g = a.margin[3]; return b && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / e || !b && (c.style && parseInt(c.style.width, 10) || g && g - a.spacing[3] || .33 * a.chartWidth) }, renderUnsquish: function () {
        var a = this.chart, c = a.renderer, e = this.tickPositions, g = this.ticks,
        d = this.options.labels, m = this.horiz, r = this.getSlotWidth(), x = Math.max(1, Math.round(r - 2 * (d.padding || 5))), k = {}, f = this.labelMetrics(), C = d.style && d.style.textOverflow, E, z, l = 0, y; K(d.rotation) || (k.rotation = d.rotation || 0); b(e, function (a) { (a = g[a]) && a.label && a.label.textPxLength > l && (l = a.label.textPxLength) }); this.maxLabelLength = l; if (this.autoRotation) l > x && l > f.h ? k.rotation = this.labelRotation : this.labelRotation = 0; else if (r && (E = x, !C)) for (z = "clip", x = e.length; !m && x--;)if (y = e[x], y = g[y].label) y.styles && "ellipsis" ===
          y.styles.textOverflow ? y.css({ textOverflow: "clip" }) : y.textPxLength > r && y.css({ width: r + "px" }), y.getBBox().height > this.len / e.length - (f.h - f.f) && (y.specificTextOverflow = "ellipsis"); k.rotation && (E = l > .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight, C || (z = "ellipsis")); if (this.labelAlign = d.align || this.autoLabelAlign(this.labelRotation)) k.align = this.labelAlign; b(e, function (a) {
            var b = (a = g[a]) && a.label; b && (b.attr(k), !E || d.style && d.style.width || !(E < b.textPxLength || "SPAN" === b.element.tagName) || b.css({
              width: E, textOverflow: b.specificTextOverflow ||
                z
            }), delete b.specificTextOverflow, a.rotation = k.rotation)
          }); this.tickRotCorr = c.rotCorr(f.b, this.labelRotation || 0, 0 !== this.side)
      }, hasData: function () { return this.hasVisibleSeries || q(this.min) && q(this.max) && this.tickPositions && 0 < this.tickPositions.length }, addTitle: function (a) {
        var b = this.chart.renderer, h = this.horiz, c = this.opposite, e = this.options.title, g; this.axisTitle || ((g = e.textAlign) || (g = (h ? { low: "left", middle: "center", high: "right" } : { low: c ? "right" : "left", middle: "center", high: c ? "left" : "right" })[e.align]),
          this.axisTitle = b.text(e.text, 0, 0, e.useHTML).attr({ zIndex: 7, rotation: e.rotation || 0, align: g }).addClass("highcharts-axis-title").css(e.style).add(this.axisGroup), this.axisTitle.isNew = !0); e.style.width || this.isRadial || this.axisTitle.css({ width: this.len }); this.axisTitle[a ? "show" : "hide"](!0)
      }, generateTick: function (a) { var b = this.ticks; b[a] ? b[a].addLabel() : b[a] = new J(this, a) }, getOffset: function () {
        var a = this, c = a.chart, e = c.renderer, g = a.options, d = a.tickPositions, m = a.ticks, r = a.horiz, x = a.side, k = c.inverted && !a.isZAxis ?
          [1, 0, 3, 2][x] : x, f, E, C = 0, z, l = 0, y = g.title, F = g.labels, J = 0, u = c.axisOffset, c = c.clipOffset, t = [-1, 1, 1, -1][x], I = g.className, n = a.axisParent, v = this.tickSize("tick"); f = a.hasData(); a.showAxis = E = f || D(g.showEmpty, !0); a.staggerLines = a.horiz && F.staggerLines; a.axisGroup || (a.gridGroup = e.g("grid").attr({ zIndex: g.gridZIndex || 1 }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (I || "")).add(n), a.axisGroup = e.g("axis").attr({ zIndex: g.zIndex || 2 }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (I || "")).add(n), a.labelGroup =
            e.g("axis-labels").attr({ zIndex: F.zIndex || 7 }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (I || "")).add(n)); f || a.isLinked ? (b(d, function (b, c) { a.generateTick(b, c) }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === x || 2 === x || { 1: "left", 3: "right" }[x] === a.labelAlign, D(F.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && b(d, function (a) { J = Math.max(m[a].getLabelSize(), J) }), a.staggerLines && (J *= a.staggerLines), a.labelOffset = J * (a.opposite ? -1 : 1)) : A(m, function (a, b) { a.destroy(); delete m[b] });
        y && y.text && !1 !== y.enabled && (a.addTitle(E), E && !1 !== y.reserveSpace && (a.titleOffset = C = a.axisTitle.getBBox()[r ? "height" : "width"], z = y.offset, l = q(z) ? 0 : D(y.margin, r ? 5 : 10))); a.renderLine(); a.offset = t * D(g.offset, u[x]); a.tickRotCorr = a.tickRotCorr || { x: 0, y: 0 }; e = 0 === x ? -a.labelMetrics().h : 2 === x ? a.tickRotCorr.y : 0; l = Math.abs(J) + l; J && (l = l - e + t * (r ? D(F.y, a.tickRotCorr.y + 8 * t) : F.x)); a.axisTitleMargin = D(z, l); u[x] = Math.max(u[x], a.axisTitleMargin + C + t * a.offset, l, f && d.length && v ? v[0] + t * a.offset : 0); g = g.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() /
          2); c[k] = Math.max(c[k], g)
      }, getLinePath: function (a) { var b = this.chart, c = this.opposite, h = this.offset, e = this.horiz, g = this.left + (c ? this.width : 0) + h, h = b.chartHeight - this.bottom - (c ? this.height : 0) + h; c && (a *= -1); return b.renderer.crispLine(["M", e ? this.left : g, e ? h : this.top, "L", e ? b.chartWidth - this.right : g, e ? h : b.chartHeight - this.bottom], a) }, renderLine: function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth, zIndex: 7
        }))
      }, getTitlePosition: function () {
        var a = this.horiz, b = this.left, c = this.top, e = this.len, g = this.options.title, d = a ? b : c, m = this.opposite, r = this.offset, x = g.x || 0, k = g.y || 0, f = this.axisTitle, E = this.chart.renderer.fontMetrics(g.style && g.style.fontSize, f), f = Math.max(f.getBBox(null, 0).height - E.h - 1, 0), e = { low: d + (a ? 0 : e), middle: d + e / 2, high: d + (a ? e : 0) }[g.align], b = (a ? c + this.height : b) + (a ? 1 : -1) * (m ? -1 : 1) * this.axisTitleMargin + [-f, f, E.f, -f][this.side]; return {
          x: a ? e + x : b + (m ? this.width :
            0) + r + x, y: a ? b + k - (m ? this.height : 0) + r : e + k
        }
      }, renderMinorTick: function (a) { var b = this.chart.hasRendered && z(this.oldMin), c = this.minorTicks; c[a] || (c[a] = new J(this, a, "minor")); b && c[a].isNew && c[a].render(null, !0); c[a].render(null, !1, 1) }, renderTick: function (a, b) { var c = this.isLinked, e = this.ticks, h = this.chart.hasRendered && z(this.oldMin); if (!c || a >= this.min && a <= this.max) e[a] || (e[a] = new J(this, a)), h && e[a].isNew && e[a].render(b, !0, .1), e[a].render(b) }, render: function () {
        var c = this, e = c.chart, g = c.options, d = c.isLog, m = c.lin2log,
        r = c.isLinked, x = c.tickPositions, k = c.axisTitle, f = c.ticks, E = c.minorTicks, l = c.alternateBands, y = g.stackLabels, F = g.alternateGridColor, q = c.tickmarkOffset, D = c.axisLine, u = c.showAxis, t = H(e.renderer.globalAnimation), I, n; c.labelEdge.length = 0; c.overlap = !1; b([f, E, l], function (a) { A(a, function (a) { a.isActive = !1 }) }); if (c.hasData() || r) c.minorTickInterval && !c.categories && b(c.getMinorTickPositions(), function (a) { c.renderMinorTick(a) }), x.length && (b(x, function (a, b) { c.renderTick(a, b) }), q && (0 === c.min || c.single) && (f[-1] || (f[-1] =
          new J(c, -1, null, !0)), f[-1].render(-1))), F && b(x, function (b, h) { n = void 0 !== x[h + 1] ? x[h + 1] + q : c.max - q; 0 === h % 2 && b < c.max && n <= c.max + (e.polar ? -q : q) && (l[b] || (l[b] = new a.PlotLineOrBand(c)), I = b + q, l[b].options = { from: d ? m(I) : I, to: d ? m(n) : n, color: F }, l[b].render(), l[b].isActive = !0) }), c._addedPlotLB || (b((g.plotLines || []).concat(g.plotBands || []), function (a) { c.addPlotBandOrLine(a) }), c._addedPlotLB = !0); b([f, E, l], function (a) {
            var b, c = [], h = t.duration; A(a, function (a, b) { a.isActive || (a.render(b, !1, 0), a.isActive = !1, c.push(b)) });
            C(function () { for (b = c.length; b--;)a[c[b]] && !a[c[b]].isActive && (a[c[b]].destroy(), delete a[c[b]]) }, a !== l && e.hasRendered && h ? h : 0)
          }); D && (D[D.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(D.strokeWidth()) }), D.isPlaced = !0, D[u ? "show" : "hide"](!0)); k && u && (g = c.getTitlePosition(), z(g.y) ? (k[k.isNew ? "attr" : "animate"](g), k.isNew = !1) : (k.attr("y", -9999), k.isNew = !0)); y && y.enabled && c.renderStackTotals(); c.isDirty = !1
      }, redraw: function () {
        this.visible && (this.render(), b(this.plotLinesAndBands, function (a) { a.render() }));
        b(this.series, function (a) { a.isDirty = !0 })
      }, keepProps: "extKey hcEvents names series userMax userMin".split(" "), destroy: function (a) {
        var c = this, e = c.stacks, h = c.plotLinesAndBands, d; a || x(c); A(e, function (a, b) { u(a); e[b] = null }); b([c.ticks, c.minorTicks, c.alternateBands], function (a) { u(a) }); if (h) for (a = h.length; a--;)h[a].destroy(); b("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "), function (a) { c[a] && (c[a] = c[a].destroy()) }); for (d in c.plotLinesAndBandsGroups) c.plotLinesAndBandsGroups[d] =
          c.plotLinesAndBandsGroups[d].destroy(); A(c, function (a, b) { -1 === g(b, c.keepProps) && delete c[b] })
      }, drawCrosshair: function (a, b) {
        var c, e = this.crosshair, g = D(e.snap, !0), h, d = this.cross; a || (a = this.cross && this.cross.e); this.crosshair && !1 !== (q(b) || !g) ? (g ? q(b) && (h = this.isXAxis ? b.plotX : this.len - b.plotY) : h = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos), q(h) && (c = this.getPlotLinePath(b && (this.isXAxis ? b.x : D(b.stackY, b.y)), null, null, null, h) || null), q(c) ? (b = this.categories && !this.isRadial, d || (this.cross =
          d = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (b ? "category " : "thin ") + e.className).attr({ zIndex: D(e.zIndex, 2) }).add(), d.attr({ stroke: e.color || (b ? l("#ccd6eb").setOpacity(.25).get() : "#cccccc"), "stroke-width": D(e.width, 1) }).css({ "pointer-events": "none" }), e.dashStyle && d.attr({ dashstyle: e.dashStyle })), d.show().attr({ d: c }), b && !e.width && d.attr({ "stroke-width": this.transA }), this.cross.e = a) : this.hideCrosshair()) : this.hideCrosshair()
      }, hideCrosshair: function () {
        this.cross &&
        this.cross.hide()
      }
    }); return a.Axis = F
  }(L); (function (a) {
    var B = a.Axis, H = a.getMagnitude, G = a.normalizeTickInterval, n = a.timeUnits; B.prototype.getTimeTicks = function () { return this.chart.time.getTimeTicks.apply(this.chart.time, arguments) }; B.prototype.normalizeTimeTickInterval = function (a, f) {
      var l = f || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]]; f = l[l.length -
        1]; var q = n[f[0]], v = f[1], u; for (u = 0; u < l.length && !(f = l[u], q = n[f[0]], v = f[1], l[u + 1] && a <= (q * v[v.length - 1] + n[l[u + 1][0]]) / 2); u++); q === n.year && a < 5 * q && (v = [1, 2, 5]); a = G(a / q, v, "year" === f[0] ? Math.max(H(a / q), 1) : 1); return { unitRange: q, count: a, unitName: f[0] }
    }
  })(L); (function (a) {
    var B = a.Axis, H = a.getMagnitude, G = a.map, n = a.normalizeTickInterval, l = a.pick; B.prototype.getLogTickPositions = function (a, t, q, v) {
      var f = this.options, b = this.len, d = this.lin2log, k = this.log2lin, e = []; v || (this._minorAutoInterval = null); if (.5 <= a) a = Math.round(a),
        e = this.getLinearTickPositions(a, t, q); else if (.08 <= a) for (var b = Math.floor(t), c, m, g, r, z, f = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; b < q + 1 && !z; b++)for (m = f.length, c = 0; c < m && !z; c++)g = k(d(b) * f[c]), g > t && (!v || r <= q) && void 0 !== r && e.push(r), r > q && (z = !0), r = g; else t = d(t), q = d(q), a = v ? this.getMinorTickInterval() : f.tickInterval, a = l("auto" === a ? null : a, this._minorAutoInterval, f.tickPixelInterval / (v ? 5 : 1) * (q - t) / ((v ? b / this.tickPositions.length : b) || 1)), a = n(a, null, H(a)), e = G(this.getLinearTickPositions(a, t, q), k), v ||
          (this._minorAutoInterval = a / 5); v || (this.tickInterval = a); return e
    }; B.prototype.log2lin = function (a) { return Math.log(a) / Math.LN10 }; B.prototype.lin2log = function (a) { return Math.pow(10, a) }
  })(L); (function (a, B) {
    var H = a.arrayMax, G = a.arrayMin, n = a.defined, l = a.destroyObjectProperties, f = a.each, t = a.erase, q = a.merge, v = a.pick; a.PlotLineOrBand = function (a, b) { this.axis = a; b && (this.options = b, this.id = b.id) }; a.PlotLineOrBand.prototype = {
      render: function () {
        var f = this, b = f.axis, d = b.horiz, k = f.options, e = k.label, c = f.label, m = k.to,
        g = k.from, r = k.value, l = n(g) && n(m), t = n(r), y = f.svgElem, I = !y, A = [], D = k.color, x = v(k.zIndex, 0), E = k.events, A = { "class": "highcharts-plot-" + (l ? "band " : "line ") + (k.className || "") }, C = {}, J = b.chart.renderer, F = l ? "bands" : "lines", h = b.log2lin; b.isLog && (g = h(g), m = h(m), r = h(r)); t ? (A = { stroke: D, "stroke-width": k.width }, k.dashStyle && (A.dashstyle = k.dashStyle)) : l && (D && (A.fill = D), k.borderWidth && (A.stroke = k.borderColor, A["stroke-width"] = k.borderWidth)); C.zIndex = x; F += "-" + x; (D = b.plotLinesAndBandsGroups[F]) || (b.plotLinesAndBandsGroups[F] =
          D = J.g("plot-" + F).attr(C).add()); I && (f.svgElem = y = J.path().attr(A).add(D)); if (t) A = b.getPlotLinePath(r, y.strokeWidth()); else if (l) A = b.getPlotBandPath(g, m, k); else return; I && A && A.length ? (y.attr({ d: A }), E && a.objectEach(E, function (a, b) { y.on(b, function (a) { E[b].apply(f, [a]) }) })) : y && (A ? (y.show(), y.animate({ d: A })) : (y.hide(), c && (f.label = c = c.destroy()))); e && n(e.text) && A && A.length && 0 < b.width && 0 < b.height && !A.flat ? (e = q({
            align: d && l && "center", x: d ? !l && 4 : 10, verticalAlign: !d && l && "middle", y: d ? l ? 16 : 10 : l ? 6 : -4, rotation: d &&
              !l && 90
          }, e), this.renderLabel(e, A, l, x)) : c && c.hide(); return f
      }, renderLabel: function (a, b, d, k) { var e = this.label, c = this.axis.chart.renderer; e || (e = { align: a.textAlign || a.align, rotation: a.rotation, "class": "highcharts-plot-" + (d ? "band" : "line") + "-label " + (a.className || "") }, e.zIndex = k, this.label = e = c.text(a.text, 0, 0, a.useHTML).attr(e).add(), e.css(a.style)); k = b.xBounds || [b[1], b[4], d ? b[6] : b[1]]; b = b.yBounds || [b[2], b[5], d ? b[7] : b[2]]; d = G(k); c = G(b); e.align(a, !1, { x: d, y: c, width: H(k) - d, height: H(b) - c }); e.show() }, destroy: function () {
        t(this.axis.plotLinesAndBands,
          this); delete this.axis; l(this)
      }
    }; a.extend(B.prototype, {
      getPlotBandPath: function (a, b) { var d = this.getPlotLinePath(b, null, null, !0), k = this.getPlotLinePath(a, null, null, !0), e = [], c = this.horiz, m = 1, g; a = a < this.min && b < this.min || a > this.max && b > this.max; if (k && d) for (a && (g = k.toString() === d.toString(), m = 0), a = 0; a < k.length; a += 6)c && d[a + 1] === k[a + 1] ? (d[a + 1] += m, d[a + 4] += m) : c || d[a + 2] !== k[a + 2] || (d[a + 2] += m, d[a + 5] += m), e.push("M", k[a + 1], k[a + 2], "L", k[a + 4], k[a + 5], d[a + 4], d[a + 5], d[a + 1], d[a + 2], "z"), e.flat = g; return e }, addPlotBand: function (a) {
        return this.addPlotBandOrLine(a,
          "plotBands")
      }, addPlotLine: function (a) { return this.addPlotBandOrLine(a, "plotLines") }, addPlotBandOrLine: function (f, b) { var d = (new a.PlotLineOrBand(this, f)).render(), k = this.userOptions; d && (b && (k[b] = k[b] || [], k[b].push(f)), this.plotLinesAndBands.push(d)); return d }, removePlotBandOrLine: function (a) {
        for (var b = this.plotLinesAndBands, d = this.options, k = this.userOptions, e = b.length; e--;)b[e].id === a && b[e].destroy(); f([d.plotLines || [], k.plotLines || [], d.plotBands || [], k.plotBands || []], function (b) {
          for (e = b.length; e--;)b[e].id ===
            a && t(b, b[e])
        })
      }, removePlotBand: function (a) { this.removePlotBandOrLine(a) }, removePlotLine: function (a) { this.removePlotBandOrLine(a) }
    })
  })(L, V); (function (a) {
    var B = a.each, H = a.extend, G = a.format, n = a.isNumber, l = a.map, f = a.merge, t = a.pick, q = a.splat, v = a.syncTimeout, u = a.timeUnits; a.Tooltip = function () { this.init.apply(this, arguments) }; a.Tooltip.prototype = {
      init: function (a, d) { this.chart = a; this.options = d; this.crosshairs = []; this.now = { x: 0, y: 0 }; this.isHidden = !0; this.split = d.split && !a.inverted; this.shared = d.shared || this.split },
      cleanSplit: function (a) { B(this.chart.series, function (b) { var d = b && b.tt; d && (!d.isActive || a ? b.tt = d.destroy() : d.isActive = !1) }) }, getLabel: function () { var a = this.chart.renderer, d = this.options; this.label || (this.split ? this.label = a.g("tooltip") : (this.label = a.label("", 0, 0, d.shape || "callout", null, null, d.useHTML, null, "tooltip").attr({ padding: d.padding, r: d.borderRadius }), this.label.attr({ fill: d.backgroundColor, "stroke-width": d.borderWidth }).css(d.style).shadow(d.shadow)), this.label.attr({ zIndex: 8 }).add()); return this.label },
      update: function (a) { this.destroy(); f(!0, this.chart.options.tooltip.userOptions, a); this.init(this.chart, f(!0, this.options, a)) }, destroy: function () { this.label && (this.label = this.label.destroy()); this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy()); clearTimeout(this.hideTimer); clearTimeout(this.tooltipTimeout) }, move: function (a, d, k, e) {
        var b = this, m = b.now, g = !1 !== b.options.animation && !b.isHidden && (1 < Math.abs(a - m.x) || 1 < Math.abs(d - m.y)), r = b.followPointer || 1 < b.len; H(m, {
          x: g ? (2 * m.x + a) /
            3 : a, y: g ? (m.y + d) / 2 : d, anchorX: r ? void 0 : g ? (2 * m.anchorX + k) / 3 : k, anchorY: r ? void 0 : g ? (m.anchorY + e) / 2 : e
        }); b.getLabel().attr(m); g && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () { b && b.move(a, d, k, e) }, 32))
      }, hide: function (a) { var b = this; clearTimeout(this.hideTimer); a = t(a, this.options.hideDelay, 500); this.isHidden || (this.hideTimer = v(function () { b.getLabel()[a ? "fadeOut" : "hide"](); b.isHidden = !0 }, a)) }, getAnchor: function (a, d) {
        var b, e = this.chart, c = e.inverted, m = e.plotTop, g = e.plotLeft, r = 0, f =
          0, t, y; a = q(a); b = a[0].tooltipPos; this.followPointer && d && (void 0 === d.chartX && (d = e.pointer.normalize(d)), b = [d.chartX - e.plotLeft, d.chartY - m]); b || (B(a, function (a) { t = a.series.yAxis; y = a.series.xAxis; r += a.plotX + (!c && y ? y.left - g : 0); f += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!c && t ? t.top - m : 0) }), r /= a.length, f /= a.length, b = [c ? e.plotWidth - f : r, this.shared && !c && 1 < a.length && d ? d.chartY - m : c ? e.plotHeight - r : f]); return l(b, Math.round)
      }, getPosition: function (a, d, k) {
        var b = this.chart, c = this.distance, m = {}, g = b.inverted &&
          k.h || 0, r, f = ["y", b.chartHeight, d, k.plotY + b.plotTop, b.plotTop, b.plotTop + b.plotHeight], l = ["x", b.chartWidth, a, k.plotX + b.plotLeft, b.plotLeft, b.plotLeft + b.plotWidth], y = !this.followPointer && t(k.ttBelow, !b.inverted === !!k.negative), q = function (a, b, e, d, h, p) { var r = e < d - c, x = d + c + e < b, k = d - c - e; d += c; if (y && x) m[a] = d; else if (!y && r) m[a] = k; else if (r) m[a] = Math.min(p - e, 0 > k - g ? k : k - g); else if (x) m[a] = Math.max(h, d + g + e > b ? d : d + g); else return !1 }, A = function (a, b, e, g) { var h; g < c || g > b - c ? h = !1 : m[a] = g < e / 2 ? 1 : g > b - e / 2 ? b - e - 2 : g - e / 2; return h }, D =
          function (a) { var b = f; f = l; l = b; r = a }, x = function () { !1 !== q.apply(0, f) ? !1 !== A.apply(0, l) || r || (D(!0), x()) : r ? m.x = m.y = 0 : (D(!0), x()) }; (b.inverted || 1 < this.len) && D(); x(); return m
      }, defaultFormatter: function (a) { var b = this.points || q(this), k; k = [a.tooltipFooterHeaderFormatter(b[0])]; k = k.concat(a.bodyFormatter(b)); k.push(a.tooltipFooterHeaderFormatter(b[0], !0)); return k }, refresh: function (a, d) {
        var b, e = this.options, c, m = a, g, r = {}, f = []; b = e.formatter || this.defaultFormatter; var r = this.shared, l; e.enabled && (clearTimeout(this.hideTimer),
          this.followPointer = q(m)[0].series.tooltipOptions.followPointer, g = this.getAnchor(m, d), d = g[0], c = g[1], !r || m.series && m.series.noSharedTooltip ? r = m.getLabelConfig() : (B(m, function (a) { a.setState("hover"); f.push(a.getLabelConfig()) }), r = { x: m[0].category, y: m[0].y }, r.points = f, m = m[0]), this.len = f.length, r = b.call(r, this), l = m.series, this.distance = t(l.tooltipOptions.distance, 16), !1 === r ? this.hide() : (b = this.getLabel(), this.isHidden && b.attr({ opacity: 1 }).show(), this.split ? this.renderSplit(r, q(a)) : (e.style.width || b.css({ width: this.chart.spacingBox.width }),
            b.attr({ text: r && r.join ? r.join("") : r }), b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + t(m.colorIndex, l.colorIndex)), b.attr({ stroke: e.borderColor || m.color || l.color || "#666666" }), this.updatePosition({ plotX: d, plotY: c, negative: m.negative, ttBelow: m.ttBelow, h: g[2] || 0 })), this.isHidden = !1))
      }, renderSplit: function (b, d) {
        var k = this, e = [], c = this.chart, m = c.renderer, g = !0, r = this.options, f = 0, l = this.getLabel(); a.isString(b) && (b = [!1, b]); B(b.slice(0, d.length + 1), function (a, b) {
          if (!1 !== a) {
            b = d[b - 1] ||
            { isHeader: !0, plotX: d[0].plotX }; var z = b.series || k, y = z.tt, x = b.series || {}, E = "highcharts-color-" + t(b.colorIndex, x.colorIndex, "none"); y || (z.tt = y = m.label(null, null, null, "callout", null, null, r.useHTML).addClass("highcharts-tooltip-box " + E).attr({ padding: r.padding, r: r.borderRadius, fill: r.backgroundColor, stroke: r.borderColor || b.color || x.color || "#333333", "stroke-width": r.borderWidth }).add(l)); y.isActive = !0; y.attr({ text: a }); y.css(r.style).shadow(r.shadow); a = y.getBBox(); x = a.width + y.strokeWidth(); b.isHeader ? (f =
              a.height, x = Math.max(0, Math.min(b.plotX + c.plotLeft - x / 2, c.chartWidth - x))) : x = b.plotX + c.plotLeft - t(r.distance, 16) - x; 0 > x && (g = !1); a = (b.series && b.series.yAxis && b.series.yAxis.pos) + (b.plotY || 0); a -= c.plotTop; e.push({ target: b.isHeader ? c.plotHeight + f : a, rank: b.isHeader ? 1 : 0, size: z.tt.getBBox().height + 1, point: b, x: x, tt: y })
          }
        }); this.cleanSplit(); a.distribute(e, c.plotHeight + f); B(e, function (a) {
          var b = a.point, e = b.series; a.tt.attr({
            visibility: void 0 === a.pos ? "hidden" : "inherit", x: g || b.isHeader ? a.x : b.plotX + c.plotLeft + t(r.distance,
              16), y: a.pos + c.plotTop, anchorX: b.isHeader ? b.plotX + c.plotLeft : b.plotX + e.xAxis.pos, anchorY: b.isHeader ? a.pos + c.plotTop - 15 : b.plotY + e.yAxis.pos
          })
        })
      }, updatePosition: function (a) { var b = this.chart, k = this.getLabel(), k = (this.options.positioner || this.getPosition).call(this, k.width, k.height, a); this.move(Math.round(k.x), Math.round(k.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop) }, getDateFormat: function (a, d, k, e) {
        var b = this.chart.time, m = b.dateFormat("%m-%d %H:%M:%S.%L", d), g, r, f = {
          millisecond: 15, second: 12, minute: 9, hour: 6,
          day: 3
        }, l = "millisecond"; for (r in u) { if (a === u.week && +b.dateFormat("%w", d) === k && "00:00:00.000" === m.substr(6)) { r = "week"; break } if (u[r] > a) { r = l; break } if (f[r] && m.substr(f[r]) !== "01-01 00:00:00.000".substr(f[r])) break; "week" !== r && (l = r) } r && (g = e[r]); return g
      }, getXDateFormat: function (a, d, k) { d = d.dateTimeLabelFormats; var b = k && k.closestPointRange; return (b ? this.getDateFormat(b, a.x, k.options.startOfWeek, d) : d.day) || d.year }, tooltipFooterHeaderFormatter: function (a, d) {
        d = d ? "footer" : "header"; var b = a.series, e = b.tooltipOptions,
          c = e.xDateFormat, m = b.xAxis, g = m && "datetime" === m.options.type && n(a.key), r = e[d + "Format"]; g && !c && (c = this.getXDateFormat(a, e, m)); g && c && B(a.point && a.point.tooltipDateKeys || ["key"], function (a) { r = r.replace("{point." + a + "}", "{point." + a + ":" + c + "}") }); return G(r, { point: a, series: b }, this.chart.time)
      }, bodyFormatter: function (a) { return l(a, function (a) { var b = a.series.tooltipOptions; return (b[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, b[(a.point.formatPrefix || "point") + "Format"]) }) }
    }
  })(L);
  (function (a) {
    var B = a.addEvent, H = a.attr, G = a.charts, n = a.color, l = a.css, f = a.defined, t = a.each, q = a.extend, v = a.find, u = a.fireEvent, b = a.isNumber, d = a.isObject, k = a.offset, e = a.pick, c = a.splat, m = a.Tooltip; a.Pointer = function (a, b) { this.init(a, b) }; a.Pointer.prototype = {
      init: function (a, b) { this.options = b; this.chart = a; this.runChartClick = b.chart.events && !!b.chart.events.click; this.pinchDown = []; this.lastValidTouch = {}; m && (a.tooltip = new m(a, b.tooltip), this.followTouchMove = e(b.tooltip.followTouchMove, !0)); this.setDOMEvents() },
      zoomOption: function (a) { var b = this.chart, c = b.options.chart, g = c.zoomType || "", b = b.inverted; /touch/.test(a.type) && (g = e(c.pinchType, g)); this.zoomX = a = /x/.test(g); this.zoomY = g = /y/.test(g); this.zoomHor = a && !b || g && b; this.zoomVert = g && !b || a && b; this.hasZoom = a || g }, normalize: function (a, b) { var c; c = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a; b || (this.chartPosition = b = k(this.chart.container)); return q(a, { chartX: Math.round(c.pageX - b.left), chartY: Math.round(c.pageY - b.top) }) }, getCoordinates: function (a) {
        var b =
          { xAxis: [], yAxis: [] }; t(this.chart.axes, function (c) { b[c.isXAxis ? "xAxis" : "yAxis"].push({ axis: c, value: c.toValue(a[c.horiz ? "chartX" : "chartY"]) }) }); return b
      }, findNearestKDPoint: function (a, b, c) {
        var e; t(a, function (a) {
          var g = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf("y"); a = a.searchPoint(c, g); if ((g = d(a, !0)) && !(g = !d(e, !0))) var g = e.distX - a.distX, m = e.dist - a.dist, r = (a.series.group && a.series.group.zIndex) - (e.series.group && e.series.group.zIndex), g = 0 < (0 !== g && b ? g : 0 !== m ? m : 0 !== r ? r : e.series.index >
            a.series.index ? -1 : 1); g && (e = a)
        }); return e
      }, getPointFromEvent: function (a) { a = a.target; for (var b; a && !b;)b = a.point, a = a.parentNode; return b }, getChartCoordinatesFromPoint: function (a, b) { var c = a.series, g = c.xAxis, c = c.yAxis, d = e(a.clientX, a.plotX); if (g && c) return b ? { chartX: g.len + g.pos - d, chartY: c.len + c.pos - a.plotY } : { chartX: d + g.pos, chartY: a.plotY + c.pos } }, getHoverData: function (b, c, m, k, f, l, A) {
        var g, x = [], r = A && A.isBoosting; k = !(!k || !b); A = c && !c.stickyTracking ? [c] : a.grep(m, function (a) {
          return a.visible && !(!f && a.directTouch) &&
            e(a.options.enableMouseTracking, !0) && a.stickyTracking
        }); c = (g = k ? b : this.findNearestKDPoint(A, f, l)) && g.series; g && (f && !c.noSharedTooltip ? (A = a.grep(m, function (a) { return a.visible && !(!f && a.directTouch) && e(a.options.enableMouseTracking, !0) && !a.noSharedTooltip }), t(A, function (a) { var b = v(a.points, function (a) { return a.x === g.x && !a.isNull }); d(b) && (r && (b = a.getPoint(b)), x.push(b)) })) : x.push(g)); return { hoverPoint: g, hoverSeries: c, hoverPoints: x }
      }, runPointActions: function (b, c) {
        var g = this.chart, d = g.tooltip && g.tooltip.options.enabled ?
          g.tooltip : void 0, m = d ? d.shared : !1, r = c || g.hoverPoint, k = r && r.series || g.hoverSeries, k = this.getHoverData(r, k, g.series, !!c || k && k.directTouch && this.isDirectTouch, m, b, { isBoosting: g.isBoosting }), f, r = k.hoverPoint; f = k.hoverPoints; c = (k = k.hoverSeries) && k.tooltipOptions.followPointer; m = m && k && !k.noSharedTooltip; if (r && (r !== g.hoverPoint || d && d.isHidden)) {
            t(g.hoverPoints || [], function (b) { -1 === a.inArray(b, f) && b.setState() }); t(f || [], function (a) { a.setState("hover") }); if (g.hoverSeries !== k) k.onMouseOver(); g.hoverPoint && g.hoverPoint.firePointEvent("mouseOut");
            if (!r.series) return; r.firePointEvent("mouseOver"); g.hoverPoints = f; g.hoverPoint = r; d && d.refresh(m ? f : r, b)
          } else c && d && !d.isHidden && (r = d.getAnchor([{}], b), d.updatePosition({ plotX: r[0], plotY: r[1] })); this.unDocMouseMove || (this.unDocMouseMove = B(g.container.ownerDocument, "mousemove", function (b) { var c = G[a.hoverChartIndex]; if (c) c.pointer.onDocumentMouseMove(b) })); t(g.axes, function (c) { var g = e(c.crosshair.snap, !0), d = g ? a.find(f, function (a) { return a.series[c.coll] === c }) : void 0; d || !g ? c.drawCrosshair(b, d) : c.hideCrosshair() })
      },
      reset: function (a, b) {
        var e = this.chart, g = e.hoverSeries, d = e.hoverPoint, m = e.hoverPoints, k = e.tooltip, r = k && k.shared ? m : d; a && r && t(c(r), function (b) { b.series.isCartesian && void 0 === b.plotX && (a = !1) }); if (a) k && r && (k.refresh(r), d && (d.setState(d.state, !0), t(e.axes, function (a) { a.crosshair && a.drawCrosshair(null, d) }))); else {
          if (d) d.onMouseOut(); m && t(m, function (a) { a.setState() }); if (g) g.onMouseOut(); k && k.hide(b); this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()); t(e.axes, function (a) { a.hideCrosshair() }); this.hoverX =
            e.hoverPoints = e.hoverPoint = null
        }
      }, scaleGroups: function (a, b) { var c = this.chart, e; t(c.series, function (g) { e = a || g.getPlotBox(); g.xAxis && g.xAxis.zoomEnabled && g.group && (g.group.attr(e), g.markerGroup && (g.markerGroup.attr(e), g.markerGroup.clip(b ? c.clipRect : null)), g.dataLabelsGroup && g.dataLabelsGroup.attr(e)) }); c.clipRect.attr(b || c.clipBox) }, dragStart: function (a) { var b = this.chart; b.mouseIsDown = a.type; b.cancelClick = !1; b.mouseDownX = this.mouseDownX = a.chartX; b.mouseDownY = this.mouseDownY = a.chartY }, drag: function (a) {
        var b =
          this.chart, c = b.options.chart, e = a.chartX, g = a.chartY, d = this.zoomHor, m = this.zoomVert, k = b.plotLeft, x = b.plotTop, f = b.plotWidth, l = b.plotHeight, q, F = this.selectionMarker, h = this.mouseDownX, p = this.mouseDownY, t = c.panKey && a[c.panKey + "Key"]; F && F.touch || (e < k ? e = k : e > k + f && (e = k + f), g < x ? g = x : g > x + l && (g = x + l), this.hasDragged = Math.sqrt(Math.pow(h - e, 2) + Math.pow(p - g, 2)), 10 < this.hasDragged && (q = b.isInsidePlot(h - k, p - x), b.hasCartesianSeries && (this.zoomX || this.zoomY) && q && !t && !F && (this.selectionMarker = F = b.renderer.rect(k, x, d ? 1 : f,
            m ? 1 : l, 0).attr({ fill: c.selectionMarkerFill || n("#335cad").setOpacity(.25).get(), "class": "highcharts-selection-marker", zIndex: 7 }).add()), F && d && (e -= h, F.attr({ width: Math.abs(e), x: (0 < e ? 0 : e) + h })), F && m && (e = g - p, F.attr({ height: Math.abs(e), y: (0 < e ? 0 : e) + p })), q && !F && c.panning && b.pan(a, c.panning)))
      }, drop: function (a) {
        var c = this, e = this.chart, g = this.hasPinched; if (this.selectionMarker) {
          var d = { originalEvent: a, xAxis: [], yAxis: [] }, m = this.selectionMarker, k = m.attr ? m.attr("x") : m.x, D = m.attr ? m.attr("y") : m.y, x = m.attr ? m.attr("width") :
            m.width, E = m.attr ? m.attr("height") : m.height, C; if (this.hasDragged || g) t(e.axes, function (b) { if (b.zoomEnabled && f(b.min) && (g || c[{ xAxis: "zoomX", yAxis: "zoomY" }[b.coll]])) { var e = b.horiz, h = "touchend" === a.type ? b.minPixelPadding : 0, m = b.toValue((e ? k : D) + h), e = b.toValue((e ? k + x : D + E) - h); d[b.coll].push({ axis: b, min: Math.min(m, e), max: Math.max(m, e) }); C = !0 } }), C && u(e, "selection", d, function (a) { e.zoom(q(a, g ? { animation: !1 } : null)) }); b(e.index) && (this.selectionMarker = this.selectionMarker.destroy()); g && this.scaleGroups()
        } e && b(e.index) &&
          (l(e.container, { cursor: e._cursor }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])
      }, onContainerMouseDown: function (a) { 2 !== a.button && (a = this.normalize(a), this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a)) }, onDocumentMouseUp: function (b) { G[a.hoverChartIndex] && G[a.hoverChartIndex].pointer.drop(b) }, onDocumentMouseMove: function (a) {
        var b = this.chart, c = this.chartPosition; a = this.normalize(a, c); !c || this.inClass(a.target, "highcharts-tracker") ||
          b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset()
      }, onContainerMouseLeave: function (b) { var c = G[a.hoverChartIndex]; c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null) }, onContainerMouseMove: function (b) {
        var c = this.chart; f(a.hoverChartIndex) && G[a.hoverChartIndex] && G[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index); b = this.normalize(b); b.returnValue = !1; "mousedown" === c.mouseIsDown && this.drag(b); !this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX -
          c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b)
      }, inClass: function (a, b) { for (var c; a;) { if (c = H(a, "class")) { if (-1 !== c.indexOf(b)) return !0; if (-1 !== c.indexOf("highcharts-container")) return !1 } a = a.parentNode } }, onTrackerMouseOut: function (a) { var b = this.chart.hoverSeries; a = a.relatedTarget || a.toElement; this.isDirectTouch = !1; if (!(!b || !a || b.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + b.index) && this.inClass(a, "highcharts-tracker"))) b.onMouseOut() },
      onContainerClick: function (a) { var b = this.chart, c = b.hoverPoint, e = b.plotLeft, g = b.plotTop; a = this.normalize(a); b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (u(c.series, "click", q(a, { point: c })), b.hoverPoint && c.firePointEvent("click", a)) : (q(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - e, a.chartY - g) && u(b, "click", a))) }, setDOMEvents: function () {
        var b = this, c = b.chart.container, e = c.ownerDocument; c.onmousedown = function (a) { b.onContainerMouseDown(a) }; c.onmousemove = function (a) { b.onContainerMouseMove(a) };
        c.onclick = function (a) { b.onContainerClick(a) }; this.unbindContainerMouseLeave = B(c, "mouseleave", b.onContainerMouseLeave); a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = B(e, "mouseup", b.onDocumentMouseUp)); a.hasTouch && (c.ontouchstart = function (a) { b.onContainerTouchStart(a) }, c.ontouchmove = function (a) { b.onContainerTouchMove(a) }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = B(e, "touchend", b.onDocumentTouchEnd)))
      }, destroy: function () {
        var b = this; b.unDocMouseMove && b.unDocMouseMove(); this.unbindContainerMouseLeave();
        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd())); clearInterval(b.tooltipTimeout); a.objectEach(b, function (a, c) { b[c] = null })
      }
    }
  })(L); (function (a) {
    var B = a.charts, H = a.each, G = a.extend, n = a.map, l = a.noop, f = a.pick; G(a.Pointer.prototype, {
      pinchTranslate: function (a, f, l, n, b, d) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, f, l, n, b, d); this.zoomVert && this.pinchTranslateDirection(!1, a, f, l, n,
          b, d)
      }, pinchTranslateDirection: function (a, f, l, n, b, d, k, e) {
        var c = this.chart, m = a ? "x" : "y", g = a ? "X" : "Y", r = "chart" + g, q = a ? "width" : "height", t = c["plot" + (a ? "Left" : "Top")], y, v, A = e || 1, D = c.inverted, x = c.bounds[a ? "h" : "v"], E = 1 === f.length, C = f[0][r], J = l[0][r], F = !E && f[1][r], h = !E && l[1][r], p; l = function () { !E && 20 < Math.abs(C - F) && (A = e || Math.abs(J - h) / Math.abs(C - F)); v = (t - J) / A + C; y = c["plot" + (a ? "Width" : "Height")] / A }; l(); f = v; f < x.min ? (f = x.min, p = !0) : f + y > x.max && (f = x.max - y, p = !0); p ? (J -= .8 * (J - k[m][0]), E || (h -= .8 * (h - k[m][1])), l()) : k[m] =
          [J, h]; D || (d[m] = v - t, d[q] = y); d = D ? 1 / A : A; b[q] = y; b[m] = f; n[D ? a ? "scaleY" : "scaleX" : "scale" + g] = A; n["translate" + g] = d * t + (J - d * C)
      }, pinch: function (a) {
        var q = this, t = q.chart, u = q.pinchDown, b = a.touches, d = b.length, k = q.lastValidTouch, e = q.hasZoom, c = q.selectionMarker, m = {}, g = 1 === d && (q.inClass(a.target, "highcharts-tracker") && t.runTrackerClick || q.runChartClick), r = {}; 1 < d && (q.initiated = !0); e && q.initiated && !g && a.preventDefault(); n(b, function (a) { return q.normalize(a) }); "touchstart" === a.type ? (H(b, function (a, b) {
          u[b] = {
            chartX: a.chartX,
            chartY: a.chartY
          }
        }), k.x = [u[0].chartX, u[1] && u[1].chartX], k.y = [u[0].chartY, u[1] && u[1].chartY], H(t.axes, function (a) { if (a.zoomEnabled) { var b = t.bounds[a.horiz ? "h" : "v"], c = a.minPixelPadding, e = a.toPixels(f(a.options.min, a.dataMin)), d = a.toPixels(f(a.options.max, a.dataMax)), g = Math.max(e, d); b.min = Math.min(a.pos, Math.min(e, d) - c); b.max = Math.max(a.pos + a.len, g + c) } }), q.res = !0) : q.followTouchMove && 1 === d ? this.runPointActions(q.normalize(a)) : u.length && (c || (q.selectionMarker = c = G({ destroy: l, touch: !0 }, t.plotBox)), q.pinchTranslate(u,
          b, m, c, r, k), q.hasPinched = e, q.scaleGroups(m, r), q.res && (q.res = !1, this.reset(!1, 0)))
      }, touch: function (l, q) {
        var n = this.chart, t, b; if (n.index !== a.hoverChartIndex) this.onContainerMouseLeave({ relatedTarget: !0 }); a.hoverChartIndex = n.index; 1 === l.touches.length ? (l = this.normalize(l), (b = n.isInsidePlot(l.chartX - n.plotLeft, l.chartY - n.plotTop)) && !n.openMenu ? (q && this.runPointActions(l), "touchmove" === l.type && (q = this.pinchDown, t = q[0] ? 4 <= Math.sqrt(Math.pow(q[0].chartX - l.chartX, 2) + Math.pow(q[0].chartY - l.chartY, 2)) : !1), f(t,
          !0) && this.pinch(l)) : q && this.reset()) : 2 === l.touches.length && this.pinch(l)
      }, onContainerTouchStart: function (a) { this.zoomOption(a); this.touch(a, !0) }, onContainerTouchMove: function (a) { this.touch(a) }, onDocumentTouchEnd: function (f) { B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(f) }
    })
  })(L); (function (a) {
    var B = a.addEvent, H = a.charts, G = a.css, n = a.doc, l = a.extend, f = a.noop, t = a.Pointer, q = a.removeEvent, v = a.win, u = a.wrap; if (!a.hasTouch && (v.PointerEvent || v.MSPointerEvent)) {
      var b = {}, d = !!v.PointerEvent, k = function () {
        var c =
          []; c.item = function (a) { return this[a] }; a.objectEach(b, function (a) { c.push({ pageX: a.pageX, pageY: a.pageY, target: a.target }) }); return c
      }, e = function (b, e, d, l) { "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !H[a.hoverChartIndex] || (l(b), l = H[a.hoverChartIndex].pointer, l[e]({ type: d, target: b.currentTarget, preventDefault: f, touches: k() })) }; l(t.prototype, {
        onContainerPointerDown: function (a) { e(a, "onContainerTouchStart", "touchstart", function (a) { b[a.pointerId] = { pageX: a.pageX, pageY: a.pageY, target: a.currentTarget } }) },
        onContainerPointerMove: function (a) { e(a, "onContainerTouchMove", "touchmove", function (a) { b[a.pointerId] = { pageX: a.pageX, pageY: a.pageY }; b[a.pointerId].target || (b[a.pointerId].target = a.currentTarget) }) }, onDocumentPointerUp: function (a) { e(a, "onDocumentTouchEnd", "touchend", function (a) { delete b[a.pointerId] }) }, batchMSEvents: function (a) {
          a(this.chart.container, d ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown); a(this.chart.container, d ? "pointermove" : "MSPointerMove", this.onContainerPointerMove); a(n, d ?
            "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
        }
      }); u(t.prototype, "init", function (a, b, e) { a.call(this, b, e); this.hasZoom && G(b.container, { "-ms-touch-action": "none", "touch-action": "none" }) }); u(t.prototype, "setDOMEvents", function (a) { a.apply(this); (this.hasZoom || this.followTouchMove) && this.batchMSEvents(B) }); u(t.prototype, "destroy", function (a) { this.batchMSEvents(q); a.call(this) })
    }
  })(L); (function (a) {
    var B = a.addEvent, H = a.css, G = a.discardElement, n = a.defined, l = a.each, f = a.isFirefox, t = a.marginNames, q = a.merge,
    v = a.pick, u = a.setAnimation, b = a.stableSort, d = a.win, k = a.wrap; a.Legend = function (a, b) { this.init(a, b) }; a.Legend.prototype = {
      init: function (a, b) { this.chart = a; this.setOptions(b); b.enabled && (this.render(), B(this.chart, "endResize", function () { this.legend.positionCheckboxes() })) }, setOptions: function (a) {
        var b = v(a.padding, 8); this.options = a; this.itemStyle = a.itemStyle; this.itemHiddenStyle = q(this.itemStyle, a.itemHiddenStyle); this.itemMarginTop = a.itemMarginTop || 0; this.padding = b; this.initialItemY = b - 5; this.itemHeight =
          this.maxItemWidth = 0; this.symbolWidth = v(a.symbolWidth, 16); this.pages = []
      }, update: function (a, b) { var c = this.chart; this.setOptions(q(!0, this.options, a)); this.destroy(); c.isDirtyLegend = c.isDirtyBox = !0; v(b, !0) && c.redraw() }, colorizeItem: function (a, b) {
        a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"); var c = this.options, e = a.legendItem, d = a.legendLine, k = a.legendSymbol, f = this.itemHiddenStyle.color, c = b ? c.itemStyle.color : f, l = b ? a.color || f : f, q = a.options && a.options.marker, A = { fill: l }; e && e.css({
          fill: c,
          color: c
        }); d && d.attr({ stroke: l }); k && (q && k.isMarker && (A = a.pointAttribs(), b || (A.stroke = A.fill = f)), k.attr(A))
      }, positionItem: function (a) { var b = this.options, e = b.symbolPadding, b = !b.rtl, d = a._legendItemPos, k = d[0], d = d[1], f = a.checkbox; (a = a.legendGroup) && a.element && a.translate(b ? k : this.legendWidth - k - 2 * e - 4, d); f && (f.x = k, f.y = d) }, destroyItem: function (a) { var b = a.checkbox; l(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (b) { a[b] && (a[b] = a[b].destroy()) }); b && G(a.checkbox) }, destroy: function () {
        function a(a) {
          this[a] &&
          (this[a] = this[a].destroy())
        } l(this.getAllItems(), function (b) { l(["legendItem", "legendGroup"], a, b) }); l("clipRect up down pager nav box title group".split(" "), a, this); this.display = null
      }, positionCheckboxes: function () {
        var a = this.group && this.group.alignAttr, b, d = this.clipHeight || this.legendHeight, g = this.titleHeight; a && (b = a.translateY, l(this.allItems, function (c) {
          var e = c.checkbox, m; e && (m = b + g + e.y + (this.scrollOffset || 0) + 3, H(e, {
            left: a.translateX + c.checkboxOffset + e.x - 20 + "px", top: m + "px", display: m > b - 6 && m < b + d - 6 ?
              "" : "none"
          }))
        }, this))
      }, renderTitle: function () { var a = this.options, b = this.padding, d = a.title, g = 0; d.text && (this.title || (this.title = this.chart.renderer.label(d.text, b - 3, b - 4, null, null, null, a.useHTML, null, "legend-title").attr({ zIndex: 1 }).css(d.style).add(this.group)), a = this.title.getBBox(), g = a.height, this.offsetWidth = a.width, this.contentGroup.attr({ translateY: g })); this.titleHeight = g }, setText: function (b) { var c = this.options; b.legendItem.attr({ text: c.labelFormat ? a.format(c.labelFormat, b, this.chart.time) : c.labelFormatter.call(b) }) },
      renderItem: function (a) {
        var b = this.chart, e = b.renderer, d = this.options, k = "horizontal" === d.layout, f = this.symbolWidth, l = d.symbolPadding, y = this.itemStyle, n = this.itemHiddenStyle, A = this.padding, D = k ? v(d.itemDistance, 20) : 0, x = !d.rtl, E = d.width, C = d.itemMarginBottom || 0, J = this.itemMarginTop, F = a.legendItem, h = !a.series, p = !h && a.series.drawLegendSymbol ? a.series : a, t = p.options, u = this.createCheckboxForItem && t && t.showCheckbox, t = f + l + D + (u ? 20 : 0), N = d.useHTML, P = a.options.className; F || (a.legendGroup = e.g("legend-item").addClass("highcharts-" +
          p.type + "-series highcharts-color-" + a.colorIndex + (P ? " " + P : "") + (h ? " highcharts-series-" + a.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), a.legendItem = F = e.text("", x ? f + l : -l, this.baseline || 0, N).css(q(a.visible ? y : n)).attr({ align: x ? "left" : "right", zIndex: 2 }).add(a.legendGroup), this.baseline || (f = y.fontSize, this.fontMetrics = e.fontMetrics(f, F), this.baseline = this.fontMetrics.f + 3 + J, F.attr("y", this.baseline)), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, p.drawLegendSymbol(this, a), this.setItemEvents &&
          this.setItemEvents(a, F, N), u && this.createCheckboxForItem(a)); this.colorizeItem(a, a.visible); y.width || F.css({ width: (d.itemWidth || d.width || b.spacingBox.width) - t }); this.setText(a); e = F.getBBox(); y = a.checkboxOffset = d.itemWidth || a.legendItemWidth || e.width + t; this.itemHeight = e = Math.round(a.legendItemHeight || e.height || this.symbolHeight); k && this.itemX - A + y > (E || b.spacingBox.width - 2 * A - d.x) && (this.itemX = A, this.itemY += J + this.lastLineHeight + C, this.lastLineHeight = 0); this.maxItemWidth = Math.max(this.maxItemWidth, y);
        this.lastItemY = J + this.itemY + C; this.lastLineHeight = Math.max(e, this.lastLineHeight); a._legendItemPos = [this.itemX, this.itemY]; k ? this.itemX += y : (this.itemY += J + e + C, this.lastLineHeight = e); this.offsetWidth = E || Math.max((k ? this.itemX - A - (a.checkbox ? 0 : D) : y) + A, this.offsetWidth)
      }, getAllItems: function () { var a = []; l(this.chart.series, function (b) { var c = b && b.options; b && v(c.showInLegend, n(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b))) }); return a }, getAlignment: function () {
        var a =
          this.options; return a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0)
      }, adjustMargins: function (a, b) { var c = this.chart, e = this.options, d = this.getAlignment(); d && l([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (g, m) { g.test(d) && !n(a[m]) && (c[t[m]] = Math.max(c[t[m]], c.legend[(m + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][m] * e[m % 2 ? "x" : "y"] + v(e.margin, 12) + b[m] + (0 === m ? c.titleOffset + c.options.title.margin : 0))) }) }, render: function () {
        var a = this, c = a.chart, d = c.renderer,
        g = a.group, k, f, n, y, t = a.box, A = a.options, D = a.padding; a.itemX = D; a.itemY = a.initialItemY; a.offsetWidth = 0; a.lastItemY = 0; g || (a.group = g = d.g("legend").attr({ zIndex: 7 }).add(), a.contentGroup = d.g().attr({ zIndex: 1 }).add(g), a.scrollGroup = d.g().add(a.contentGroup)); a.renderTitle(); k = a.getAllItems(); b(k, function (a, b) { return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0) }); A.reversed && k.reverse(); a.allItems = k; a.display = f = !!k.length; a.lastLineHeight = 0; l(k, function (b) { a.renderItem(b) }); n =
          (A.width || a.offsetWidth) + D; y = a.lastItemY + a.lastLineHeight + a.titleHeight; y = a.handleOverflow(y); y += D; t || (a.box = t = d.rect().addClass("highcharts-legend-box").attr({ r: A.borderRadius }).add(g), t.isNew = !0); t.attr({ stroke: A.borderColor, "stroke-width": A.borderWidth || 0, fill: A.backgroundColor || "none" }).shadow(A.shadow); 0 < n && 0 < y && (t[t.isNew ? "attr" : "animate"](t.crisp.call({}, { x: 0, y: 0, width: n, height: y }, t.strokeWidth())), t.isNew = !1); t[f ? "show" : "hide"](); a.legendWidth = n; a.legendHeight = y; l(k, function (b) { a.positionItem(b) });
        f && (d = c.spacingBox, /(lth|ct|rth)/.test(a.getAlignment()) && (d = q(d, { y: d.y + c.titleOffset + c.options.title.margin })), g.align(q(A, { width: n, height: y }), !0, d)); c.isResizing || this.positionCheckboxes()
      }, handleOverflow: function (a) {
        var b = this, e = this.chart, d = e.renderer, k = this.options, f = k.y, q = this.padding, e = e.spacingBox.height + ("top" === k.verticalAlign ? -f : f) - q, f = k.maxHeight, y, n = this.clipRect, A = k.navigation, t = v(A.animation, !0), x = A.arrowSize || 12, E = this.nav, C = this.pages, J, F = this.allItems, h = function (a) {
          "number" === typeof a ?
          n.attr({ height: a }) : n && (b.clipRect = n.destroy(), b.contentGroup.clip()); b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + q + "px,9999px," + (q + a) + "px,0)" : "auto")
        }; "horizontal" !== k.layout || "middle" === k.verticalAlign || k.floating || (e /= 2); f && (e = Math.min(e, f)); C.length = 0; a > e && !1 !== A.enabled ? (this.clipHeight = y = Math.max(e - 20 - this.titleHeight - q, 0), this.currentPage = v(this.currentPage, 1), this.fullHeight = a, l(F, function (a, b) {
          var c = a._legendItemPos[1], e = Math.round(a.legendItem.getBBox().height), d = C.length;
          if (!d || c - C[d - 1] > y && (J || c) !== C[d - 1]) C.push(J || c), d++; a.pageIx = d - 1; J && (F[b - 1].pageIx = d - 1); b === F.length - 1 && c + e - C[d - 1] > y && (C.push(c), a.pageIx = d); c !== J && (J = c)
        }), n || (n = b.clipRect = d.clipRect(0, q, 9999, 0), b.contentGroup.clip(n)), h(y), E || (this.nav = E = d.g().attr({ zIndex: 1 }).add(this.group), this.up = d.symbol("triangle", 0, 0, x, x).on("click", function () { b.scroll(-1, t) }).add(E), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation").css(A.style).add(E), this.down = d.symbol("triangle-down", 0, 0, x, x).on("click",
          function () { b.scroll(1, t) }).add(E)), b.scroll(0), a = e) : E && (h(), this.nav = E.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0); return a
      }, scroll: function (a, b) {
        var c = this.pages, d = c.length; a = this.currentPage + a; var e = this.clipHeight, k = this.options.navigation, f = this.pager, l = this.padding; a > d && (a = d); 0 < a && (void 0 !== b && u(b, this.chart), this.nav.attr({ translateX: l, translateY: e + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ "class": 1 === a ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }),
          f.attr({ text: a + "/" + d }), this.down.attr({ x: 18 + this.pager.getBBox().width, "class": a === d ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }), this.up.attr({ fill: 1 === a ? k.inactiveColor : k.activeColor }).css({ cursor: 1 === a ? "default" : "pointer" }), this.down.attr({ fill: a === d ? k.inactiveColor : k.activeColor }).css({ cursor: a === d ? "default" : "pointer" }), this.scrollOffset = -c[a - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = a, this.positionCheckboxes())
      }
    }; a.LegendSymbolMixin =
    {
      drawRectangle: function (a, b) { var c = a.symbolHeight, d = a.options.squareSymbol; b.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - c) / 2 : 0, a.baseline - c + 1, d ? c : a.symbolWidth, c, v(a.options.symbolRadius, c / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(b.legendGroup) }, drawLineMarker: function (a) {
        var b = this.options, d = b.marker, e = a.symbolWidth, k = a.symbolHeight, f = k / 2, l = this.chart.renderer, y = this.legendGroup; a = a.baseline - Math.round(.3 * a.fontMetrics.b); var n; n = { "stroke-width": b.lineWidth || 0 }; b.dashStyle &&
          (n.dashstyle = b.dashStyle); this.legendLine = l.path(["M", 0, a, "L", e, a]).addClass("highcharts-graph").attr(n).add(y); d && !1 !== d.enabled && (b = Math.min(v(d.radius, f), f), 0 === this.symbol.indexOf("url") && (d = q(d, { width: k, height: k }), b = 0), this.legendSymbol = d = l.symbol(this.symbol, e / 2 - b, a - b, 2 * b, 2 * b, d).addClass("highcharts-point").add(y), d.isMarker = !0)
      }
    }; (/Trident\/7\.0/.test(d.navigator.userAgent) || f) && k(a.Legend.prototype, "positionItem", function (a, b) { var c = this, d = function () { b._legendItemPos && a.call(c, b) }; d(); setTimeout(d) })
  })(L);
  (function (a) {
    var B = a.addEvent, H = a.animate, G = a.animObject, n = a.attr, l = a.doc, f = a.Axis, t = a.createElement, q = a.defaultOptions, v = a.discardElement, u = a.charts, b = a.css, d = a.defined, k = a.each, e = a.extend, c = a.find, m = a.fireEvent, g = a.grep, r = a.isNumber, z = a.isObject, K = a.isString, y = a.Legend, I = a.marginNames, A = a.merge, D = a.objectEach, x = a.Pointer, E = a.pick, C = a.pInt, J = a.removeEvent, F = a.seriesTypes, h = a.splat, p = a.syncTimeout, M = a.win, O = a.Chart = function () { this.getArgs.apply(this, arguments) }; a.chart = function (a, b, c) {
      return new O(a,
        b, c)
    }; e(O.prototype, {
      callbacks: [], getArgs: function () { var a = [].slice.call(arguments); if (K(a[0]) || a[0].nodeName) this.renderTo = a.shift(); this.init(a[0], a[1]) }, init: function (b, c) {
        var d, e, h = b.series, g = b.plotOptions || {}; b.series = null; d = A(q, b); for (e in d.plotOptions) d.plotOptions[e].tooltip = g[e] && A(g[e].tooltip) || void 0; d.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip; d.series = b.series = h; this.userOptions = b; e = d.chart; h = e.events; this.margin = []; this.spacing = []; this.bounds =
          { h: {}, v: {} }; this.labelCollectors = []; this.callback = c; this.isResizing = 0; this.options = d; this.axes = []; this.series = []; this.time = b.time && a.keys(b.time).length ? new a.Time(b.time) : a.time; this.hasCartesianSeries = e.showAxes; var k = this; k.index = u.length; u.push(k); a.chartCount++; h && D(h, function (a, b) { B(k, b, a) }); k.xAxis = []; k.yAxis = []; k.pointCount = k.colorCounter = k.symbolCounter = 0; k.firstRender()
      }, initSeries: function (b) {
        var c = this.options.chart; (c = F[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0); c = new c; c.init(this,
          b); return c
      }, orderSeries: function (a) { var b = this.series; for (a = a || 0; a < b.length; a++)b[a] && (b[a].index = a, b[a].name = b[a].getName()) }, isInsidePlot: function (a, b, c) { var d = c ? b : a; a = c ? a : b; return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight }, redraw: function (b) {
        var c = this.axes, d = this.series, h = this.pointer, g = this.legend, f = this.isDirtyLegend, p, x, l = this.hasCartesianSeries, E = this.isDirtyBox, r, C = this.renderer, q = C.isHidden(), y = []; this.setResponsive && this.setResponsive(!1); a.setAnimation(b, this); q && this.temporaryDisplay();
        this.layOutTitles(); for (b = d.length; b--;)if (r = d[b], r.options.stacking && (p = !0, r.isDirty)) { x = !0; break } if (x) for (b = d.length; b--;)r = d[b], r.options.stacking && (r.isDirty = !0); k(d, function (a) { a.isDirty && "point" === a.options.legendType && (a.updateTotals && a.updateTotals(), f = !0); a.isDirtyData && m(a, "updatedData") }); f && g.options.enabled && (g.render(), this.isDirtyLegend = !1); p && this.getStacks(); l && k(c, function (a) { a.updateNames(); a.setScale() }); this.getMargins(); l && (k(c, function (a) { a.isDirty && (E = !0) }), k(c, function (a) {
          var b =
            a.min + "," + a.max; a.extKey !== b && (a.extKey = b, y.push(function () { m(a, "afterSetExtremes", e(a.eventArgs, a.getExtremes())); delete a.eventArgs })); (E || p) && a.redraw()
        })); E && this.drawChartBox(); m(this, "predraw"); k(d, function (a) { (E || a.isDirty) && a.visible && a.redraw(); a.isDirtyData = !1 }); h && h.reset(!0); C.draw(); m(this, "redraw"); m(this, "render"); q && this.temporaryDisplay(!0); k(y, function (a) { a.call() })
      }, get: function (a) {
        function b(b) { return b.id === a || b.options && b.options.id === a } var d, e = this.series, h; d = c(this.axes, b) ||
          c(this.series, b); for (h = 0; !d && h < e.length; h++)d = c(e[h].points || [], b); return d
      }, getAxes: function () { var a = this, b = this.options, c = b.xAxis = h(b.xAxis || {}), b = b.yAxis = h(b.yAxis || {}); k(c, function (a, b) { a.index = b; a.isX = !0 }); k(b, function (a, b) { a.index = b }); c = c.concat(b); k(c, function (b) { new f(a, b) }) }, getSelectedPoints: function () { var a = []; k(this.series, function (b) { a = a.concat(g(b.data || [], function (a) { return a.selected })) }); return a }, getSelectedSeries: function () { return g(this.series, function (a) { return a.selected }) },
      setTitle: function (a, b, c) { var d = this, e = d.options, h; h = e.title = A({ style: { color: "#333333", fontSize: e.isStock ? "16px" : "18px" } }, e.title, a); e = e.subtitle = A({ style: { color: "#666666" } }, e.subtitle, b); k([["title", a, h], ["subtitle", b, e]], function (a, b) { var c = a[0], e = d[c], h = a[1]; a = a[2]; e && h && (d[c] = e = e.destroy()); a && !e && (d[c] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({ align: a.align, "class": "highcharts-" + c, zIndex: a.zIndex || 4 }).add(), d[c].update = function (a) { d.setTitle(!b && a, b && a) }, d[c].css(a.style)) }); d.layOutTitles(c) },
      layOutTitles: function (a) {
        var b = 0, c, d = this.renderer, h = this.spacingBox; k(["title", "subtitle"], function (a) { var c = this[a], g = this.options[a]; a = "title" === a ? -3 : g.verticalAlign ? 0 : b + 2; var k; c && (k = g.style.fontSize, k = d.fontMetrics(k, c).b, c.css({ width: (g.width || h.width + g.widthAdjust) + "px" }).align(e({ y: a + k }, g), !1, "spacingBox"), g.floating || g.verticalAlign || (b = Math.ceil(b + c.getBBox(g.useHTML).height))) }, this); c = this.titleOffset !== b; this.titleOffset = b; !this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && E(a,
          !0) && this.isDirtyBox && this.redraw())
      }, getChartSize: function () { var b = this.options.chart, c = b.width, b = b.height, e = this.renderTo; d(c) || (this.containerWidth = a.getStyle(e, "width")); d(b) || (this.containerHeight = a.getStyle(e, "height")); this.chartWidth = Math.max(0, c || this.containerWidth || 600); this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400)) }, temporaryDisplay: function (b) {
        var c = this.renderTo; if (b) for (; c && c.style;)c.hcOrigStyle && (a.css(c, c.hcOrigStyle),
          delete c.hcOrigStyle), c.hcOrigDetached && (l.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode; else for (; c && c.style;) {
            l.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, l.body.appendChild(c)); if ("none" === a.getStyle(c, "display", !1) || c.hcOricDetached) c.hcOrigStyle = { display: c.style.display, height: c.style.height, overflow: c.style.overflow }, b = { display: "block", overflow: "hidden" }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty("display", "block", "important"); c = c.parentNode;
            if (c === l.body) break
          }
      }, setClassName: function (a) { this.container.className = "highcharts-container " + (a || "") }, getContainer: function () {
        var b, c = this.options, d = c.chart, h, g; b = this.renderTo; var k = a.uniqueKey(), m; b || (this.renderTo = b = d.renderTo); K(b) && (this.renderTo = b = l.getElementById(b)); b || a.error(13, !0); h = C(n(b, "data-highcharts-chart")); r(h) && u[h] && u[h].hasRendered && u[h].destroy(); n(b, "data-highcharts-chart", this.index); b.innerHTML = ""; d.skipClone || b.offsetWidth || this.temporaryDisplay(); this.getChartSize();
        h = this.chartWidth; g = this.chartHeight; m = e({ position: "relative", overflow: "hidden", width: h + "px", height: g + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, d.style); this.container = b = t("div", { id: k }, m, b); this._cursor = b.style.cursor; this.renderer = new (a[d.renderer] || a.Renderer)(b, h, g, null, d.forExport, c.exporting && c.exporting.allowHTML); this.setClassName(d.className); this.renderer.setStyle(d.style); this.renderer.chartIndex = this.index
      }, getMargins: function (a) {
        var b =
          this.spacing, c = this.margin, e = this.titleOffset; this.resetMargins(); e && !d(c[0]) && (this.plotTop = Math.max(this.plotTop, e + this.options.title.margin + b[0])); this.legend && this.legend.display && this.legend.adjustMargins(c, b); this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value); this.adjustPlotArea && this.adjustPlotArea(); a || this.getAxisMargins()
      }, getAxisMargins: function () {
        var a = this, b = a.axisOffset = [0, 0, 0, 0], c = a.margin; a.hasCartesianSeries && k(a.axes, function (a) {
          a.visible &&
          a.getOffset()
        }); k(I, function (e, h) { d(c[h]) || (a[e] += b[h]) }); a.setChartSize()
      }, reflow: function (b) { var c = this, e = c.options.chart, h = c.renderTo, g = d(e.width) && d(e.height), k = e.width || a.getStyle(h, "width"), e = e.height || a.getStyle(h, "height"), h = b ? b.target : M; if (!g && !c.isPrinting && k && e && (h === M || h === l)) { if (k !== c.containerWidth || e !== c.containerHeight) clearTimeout(c.reflowTimeout), c.reflowTimeout = p(function () { c.container && c.setSize(void 0, void 0, !1) }, b ? 100 : 0); c.containerWidth = k; c.containerHeight = e } }, initReflow: function () {
        var a =
          this, b; b = B(M, "resize", function (b) { a.reflow(b) }); B(a, "destroy", b)
      }, setSize: function (c, d, e) {
        var h = this, g = h.renderer; h.isResizing += 1; a.setAnimation(e, h); h.oldChartHeight = h.chartHeight; h.oldChartWidth = h.chartWidth; void 0 !== c && (h.options.chart.width = c); void 0 !== d && (h.options.chart.height = d); h.getChartSize(); c = g.globalAnimation; (c ? H : b)(h.container, { width: h.chartWidth + "px", height: h.chartHeight + "px" }, c); h.setChartSize(!0); g.setSize(h.chartWidth, h.chartHeight, e); k(h.axes, function (a) { a.isDirty = !0; a.setScale() });
        h.isDirtyLegend = !0; h.isDirtyBox = !0; h.layOutTitles(); h.getMargins(); h.redraw(e); h.oldChartHeight = null; m(h, "resize"); p(function () { h && m(h, "endResize", null, function () { --h.isResizing }) }, G(c).duration)
      }, setChartSize: function (a) {
        var b = this.inverted, c = this.renderer, d = this.chartWidth, h = this.chartHeight, e = this.options.chart, g = this.spacing, m = this.clipOffset, p, f, x, l; this.plotLeft = p = Math.round(this.plotLeft); this.plotTop = f = Math.round(this.plotTop); this.plotWidth = x = Math.max(0, Math.round(d - p - this.marginRight));
        this.plotHeight = l = Math.max(0, Math.round(h - f - this.marginBottom)); this.plotSizeX = b ? l : x; this.plotSizeY = b ? x : l; this.plotBorderWidth = e.plotBorderWidth || 0; this.spacingBox = c.spacingBox = { x: g[3], y: g[0], width: d - g[3] - g[1], height: h - g[0] - g[2] }; this.plotBox = c.plotBox = { x: p, y: f, width: x, height: l }; d = 2 * Math.floor(this.plotBorderWidth / 2); b = Math.ceil(Math.max(d, m[3]) / 2); c = Math.ceil(Math.max(d, m[0]) / 2); this.clipBox = {
          x: b, y: c, width: Math.floor(this.plotSizeX - Math.max(d, m[1]) / 2 - b), height: Math.max(0, Math.floor(this.plotSizeY -
            Math.max(d, m[2]) / 2 - c))
        }; a || k(this.axes, function (a) { a.setAxisSize(); a.setAxisTranslation() })
      }, resetMargins: function () { var a = this, b = a.options.chart; k(["margin", "spacing"], function (c) { var d = b[c], h = z(d) ? d : [d, d, d, d]; k(["Top", "Right", "Bottom", "Left"], function (d, e) { a[c][e] = E(b[c + d], h[e]) }) }); k(I, function (b, c) { a[b] = E(a.margin[c], a.spacing[c]) }); a.axisOffset = [0, 0, 0, 0]; a.clipOffset = [0, 0, 0, 0] }, drawChartBox: function () {
        var a = this.options.chart, b = this.renderer, c = this.chartWidth, d = this.chartHeight, h = this.chartBackground,
        e = this.plotBackground, g = this.plotBorder, k, m = this.plotBGImage, p = a.backgroundColor, f = a.plotBackgroundColor, x = a.plotBackgroundImage, l, E = this.plotLeft, r = this.plotTop, C = this.plotWidth, q = this.plotHeight, y = this.plotBox, F = this.clipRect, A = this.clipBox, n = "animate"; h || (this.chartBackground = h = b.rect().addClass("highcharts-background").add(), n = "attr"); k = a.borderWidth || 0; l = k + (a.shadow ? 8 : 0); p = { fill: p || "none" }; if (k || h["stroke-width"]) p.stroke = a.borderColor, p["stroke-width"] = k; h.attr(p).shadow(a.shadow); h[n]({
          x: l /
            2, y: l / 2, width: c - l - k % 2, height: d - l - k % 2, r: a.borderRadius
        }); n = "animate"; e || (n = "attr", this.plotBackground = e = b.rect().addClass("highcharts-plot-background").add()); e[n](y); e.attr({ fill: f || "none" }).shadow(a.plotShadow); x && (m ? m.animate(y) : this.plotBGImage = b.image(x, E, r, C, q).add()); F ? F.animate({ width: A.width, height: A.height }) : this.clipRect = b.clipRect(A); n = "animate"; g || (n = "attr", this.plotBorder = g = b.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add()); g.attr({
          stroke: a.plotBorderColor, "stroke-width": a.plotBorderWidth ||
            0, fill: "none"
        }); g[n](g.crisp({ x: E, y: r, width: C, height: q }, -g.strokeWidth())); this.isDirtyBox = !1
      }, propFromSeries: function () { var a = this, b = a.options.chart, c, d = a.options.series, h, e; k(["inverted", "angular", "polar"], function (g) { c = F[b.type || b.defaultSeriesType]; e = b[g] || c && c.prototype[g]; for (h = d && d.length; !e && h--;)(c = F[d[h].type]) && c.prototype[g] && (e = !0); a[g] = e }) }, linkSeries: function () {
        var a = this, b = a.series; k(b, function (a) { a.linkedSeries.length = 0 }); k(b, function (b) {
          var c = b.options.linkedTo; K(c) && (c = ":previous" ===
            c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = E(b.options.visible, c.options.visible, b.visible))
        })
      }, renderSeries: function () { k(this.series, function (a) { a.translate(); a.render() }) }, renderLabels: function () { var a = this, b = a.options.labels; b.items && k(b.items, function (c) { var d = e(b.style, c.style), h = C(d.left) + a.plotLeft, g = C(d.top) + a.plotTop + 12; delete d.left; delete d.top; a.renderer.text(c.html, h, g).attr({ zIndex: 2 }).css(d).add() }) }, render: function () {
        var a =
          this.axes, b = this.renderer, c = this.options, d, h, e; this.setTitle(); this.legend = new y(this, c.legend); this.getStacks && this.getStacks(); this.getMargins(!0); this.setChartSize(); c = this.plotWidth; d = this.plotHeight = Math.max(this.plotHeight - 21, 0); k(a, function (a) { a.setScale() }); this.getAxisMargins(); h = 1.1 < c / this.plotWidth; e = 1.05 < d / this.plotHeight; if (h || e) k(a, function (a) { (a.horiz && h || !a.horiz && e) && a.setTickInterval(!0) }), this.getMargins(); this.drawChartBox(); this.hasCartesianSeries && k(a, function (a) {
            a.visible &&
            a.render()
          }); this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({ zIndex: 3 }).add()); this.renderSeries(); this.renderLabels(); this.addCredits(); this.setResponsive && this.setResponsive(); this.hasRendered = !0
      }, addCredits: function (a) {
        var b = this; a = A(!0, this.options.credits, a); a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () { a.href && (M.location.href = a.href) }).attr({ align: a.position.align, zIndex: 8 }).css(a.style).add().align(a.position),
          this.credits.update = function (a) { b.credits = b.credits.destroy(); b.addCredits(a) })
      }, destroy: function () {
        var b = this, c = b.axes, d = b.series, h = b.container, e, g = h && h.parentNode; m(b, "destroy"); b.renderer.forExport ? a.erase(u, b) : u[b.index] = void 0; a.chartCount--; b.renderTo.removeAttribute("data-highcharts-chart"); J(b); for (e = c.length; e--;)c[e] = c[e].destroy(); this.scroller && this.scroller.destroy && this.scroller.destroy(); for (e = d.length; e--;)d[e] = d[e].destroy(); k("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "),
          function (a) { var c = b[a]; c && c.destroy && (b[a] = c.destroy()) }); h && (h.innerHTML = "", J(h), g && v(h)); D(b, function (a, c) { delete b[c] })
      }, firstRender: function () { var a = this, b = a.options; if (!a.isReadyToRender || a.isReadyToRender()) { a.getContainer(); m(a, "init"); a.resetMargins(); a.setChartSize(); a.propFromSeries(); a.getAxes(); k(b.series || [], function (b) { a.initSeries(b) }); a.linkSeries(); m(a, "beforeRender"); x && (a.pointer = new x(a, b)); a.render(); if (!a.renderer.imgCount && a.onload) a.onload(); a.temporaryDisplay(!0) } }, onload: function () {
        k([this.callback].concat(this.callbacks),
          function (a) { a && void 0 !== this.index && a.apply(this, [this]) }, this); m(this, "load"); m(this, "render"); d(this.index) && !1 !== this.options.chart.reflow && this.initReflow(); this.onload = null
      }
    })
  })(L); (function (a) {
    var B, H = a.each, G = a.extend, n = a.erase, l = a.fireEvent, f = a.format, t = a.isArray, q = a.isNumber, v = a.pick, u = a.removeEvent; a.Point = B = function () { }; a.Point.prototype = {
      init: function (a, d, k) {
        this.series = a; this.color = a.color; this.applyOptions(d, k); a.options.colorByPoint ? (d = a.options.colors || a.chart.options.colors, this.color =
          this.color || d[a.colorCounter], d = d.length, k = a.colorCounter, a.colorCounter++, a.colorCounter === d && (a.colorCounter = 0)) : k = a.colorIndex; this.colorIndex = v(this.colorIndex, k); a.chart.pointCount++; return this
      }, applyOptions: function (a, d) {
        var b = this.series, e = b.options.pointValKey || b.pointValKey; a = B.prototype.optionsToObject.call(this, a); G(this, a); this.options = this.options ? G(this.options, a) : a; a.group && delete this.group; e && (this.y = this[e]); this.isNull = v(this.isValid && !this.isValid(), null === this.x || !q(this.y, !0));
        this.selected && (this.state = "select"); "name" in this && void 0 === d && b.xAxis && b.xAxis.hasNames && (this.x = b.xAxis.nameToX(this)); void 0 === this.x && b && (this.x = void 0 === d ? b.autoIncrement(this) : d); return this
      }, optionsToObject: function (a) {
        var b = {}, k = this.series, e = k.options.keys, c = e || k.pointArrayMap || ["y"], m = c.length, g = 0, f = 0; if (q(a) || null === a) b[c[0]] = a; else if (t(a)) for (!e && a.length > m && (k = typeof a[0], "string" === k ? b.name = a[0] : "number" === k && (b.x = a[0]), g++); f < m;)e && void 0 === a[g] || (b[c[f]] = a[g]), g++, f++; else "object" ===
          typeof a && (b = a, a.dataLabels && (k._hasPointLabels = !0), a.marker && (k._hasPointMarkers = !0)); return b
      }, getClassName: function () { return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "") }, getZone: function () {
        var a =
          this.series, d = a.zones, a = a.zoneAxis || "y", k = 0, e; for (e = d[k]; this[a] >= e.value;)e = d[++k]; e && e.color && !this.options.color && (this.color = e.color); return e
      }, destroy: function () { var a = this.series.chart, d = a.hoverPoints, k; a.pointCount--; d && (this.setState(), n(d, this), d.length || (a.hoverPoints = null)); if (this === a.hoverPoint) this.onMouseOut(); if (this.graphic || this.dataLabel) u(this), this.destroyElements(); this.legendItem && a.legend.destroyItem(this); for (k in this) this[k] = null }, destroyElements: function () {
        for (var a = ["graphic",
          "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], d, k = 6; k--;)d = a[k], this[d] && (this[d] = this[d].destroy())
      }, getLabelConfig: function () { return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal } }, tooltipFormatter: function (a) {
        var b = this.series, k = b.tooltipOptions, e = v(k.valueDecimals, ""), c = k.valuePrefix || "", m = k.valueSuffix || ""; H(b.pointArrayMap || ["y"], function (b) {
          b =
          "{point." + b; if (c || m) a = a.replace(b + "}", c + b + "}" + m); a = a.replace(b + "}", b + ":,." + e + "f}")
        }); return f(a, { point: this, series: this.series }, b.chart.time)
      }, firePointEvent: function (a, d, k) { var b = this, c = this.series.options; (c.point.events[a] || b.options && b.options.events && b.options.events[a]) && this.importEvents(); "click" === a && c.allowPointSelect && (k = function (a) { b.select && b.select(null, a.ctrlKey || a.metaKey || a.shiftKey) }); l(this, a, d, k) }, visible: !0
    }
  })(L); (function (a) {
    var B = a.addEvent, H = a.animObject, G = a.arrayMax, n = a.arrayMin,
    l = a.correctFloat, f = a.defaultOptions, t = a.defaultPlotOptions, q = a.defined, v = a.each, u = a.erase, b = a.extend, d = a.fireEvent, k = a.grep, e = a.isArray, c = a.isNumber, m = a.isString, g = a.merge, r = a.objectEach, z = a.pick, K = a.removeEvent, y = a.splat, I = a.SVGElement, A = a.syncTimeout, D = a.win; a.Series = a.seriesType("line", null, {
      lineWidth: 2, allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1E3 }, events: {}, marker: {
        lineWidth: 0, lineColor: "#ffffff", enabledThreshold: 2, radius: 4, states: {
          normal: { animation: !0 }, hover: {
            animation: { duration: 50 },
            enabled: !0, radiusPlus: 2, lineWidthPlus: 1
          }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 }
        }
      }, point: { events: {} }, dataLabels: { align: "center", formatter: function () { return null === this.y ? "" : a.numberFormat(this.y, -1) }, style: { fontSize: "11px", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0, padding: 5 }, cropThreshold: 300, pointRange: 0, softThreshold: !0, states: {
        normal: { animation: !0 }, hover: { animation: { duration: 50 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: .25 } },
        select: { marker: {} }
      }, stickyTracking: !0, turboThreshold: 1E3, findNearestPointBy: "x"
    }, {
      isCartesian: !0, pointClass: a.Point, sorted: !0, requireSorting: !0, directTouch: !1, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], coll: "series", init: function (a, c) {
        var d = this, e, g = a.series, h; d.chart = a; d.options = c = d.setOptions(c); d.linkedSeries = []; d.bindAxes(); b(d, { name: c.name, state: "", visible: !1 !== c.visible, selected: !0 === c.selected }); e = c.events; r(e, function (a, b) { B(d, b, a) }); if (e && e.click || c.point && c.point.events &&
          c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0; d.getColor(); d.getSymbol(); v(d.parallelArrays, function (a) { d[a + "Data"] = [] }); d.setData(c.data, !1); d.isCartesian && (a.hasCartesianSeries = !0); g.length && (h = g[g.length - 1]); d._i = z(h && h._i, -1) + 1; a.orderSeries(this.insert(g))
      }, insert: function (a) { var b = this.options.index, d; if (c(b)) { for (d = a.length; d--;)if (b >= z(a[d].options.index, a[d]._i)) { a.splice(d + 1, 0, this); break } -1 === d && a.unshift(this); d += 1 } else a.push(this); return z(d, a.length - 1) }, bindAxes: function () {
        var b =
          this, c = b.options, d = b.chart, e; v(b.axisTypes || [], function (g) { v(d[g], function (a) { e = a.options; if (c[g] === e.index || void 0 !== c[g] && c[g] === e.id || void 0 === c[g] && 0 === e.index) b.insert(a.series), b[g] = a, a.isDirty = !0 }); b[g] || b.optionalAxis === g || a.error(18, !0) })
      }, updateParallelArrays: function (a, b) { var d = a.series, e = arguments, g = c(b) ? function (c) { var e = "y" === c && d.toYData ? d.toYData(a) : a[c]; d[c + "Data"][b] = e } : function (a) { Array.prototype[b].apply(d[a + "Data"], Array.prototype.slice.call(e, 2)) }; v(d.parallelArrays, g) }, autoIncrement: function () {
        var a =
          this.options, b = this.xIncrement, c, d = a.pointIntervalUnit, e = this.chart.time, b = z(b, a.pointStart, 0); this.pointInterval = c = z(this.pointInterval, a.pointInterval, 1); d && (a = new e.Date(b), "day" === d ? e.set("Date", a, e.get("Date", a) + c) : "month" === d ? e.set("Month", a, e.get("Month", a) + c) : "year" === d && e.set("FullYear", a, e.get("FullYear", a) + c), c = a.getTime() - b); this.xIncrement = b + c; return b
      }, setOptions: function (a) {
        var b = this.chart, c = b.options, d = c.plotOptions, e = (b.userOptions || {}).plotOptions || {}, h = d[this.type]; this.userOptions =
          a; b = g(h, d.series, a); this.tooltipOptions = g(f.tooltip, f.plotOptions.series && f.plotOptions.series.tooltip, f.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip); this.stickyTracking = z(a.stickyTracking, e[this.type] && e[this.type].stickyTracking, e.series && e.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : b.stickyTracking); null === h.marker && delete b.marker; this.zoneAxis = b.zoneAxis; a = this.zones = (b.zones || []).slice(); !b.negativeColor &&
            !b.negativeFillColor || b.zones || a.push({ value: b[this.zoneAxis + "Threshold"] || b.threshold || 0, className: "highcharts-negative", color: b.negativeColor, fillColor: b.negativeFillColor }); a.length && q(a[a.length - 1].value) && a.push({ color: this.color, fillColor: this.fillColor }); return b
      }, getName: function () { return this.name || "Series " + (this.index + 1) }, getCyclic: function (a, b, c) {
        var d, e = this.chart, h = this.userOptions, g = a + "Index", k = a + "Counter", m = c ? c.length : z(e.options.chart[a + "Count"], e[a + "Count"]); b || (d = z(h[g], h["_" + g]),
          q(d) || (e.series.length || (e[k] = 0), h["_" + g] = d = e[k] % m, e[k] += 1), c && (b = c[d])); void 0 !== d && (this[g] = d); this[a] = b
      }, getColor: function () { this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || t[this.type].color, this.chart.options.colors) }, getSymbol: function () { this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols) }, drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker, setData: function (b, d, g, k) {
        var f = this, h = f.points, p = h && h.length || 0, l, x = f.options, r =
          f.chart, E = null, q = f.xAxis, y = x.turboThreshold, C = this.xData, n = this.yData, A = (l = f.pointArrayMap) && l.length; b = b || []; l = b.length; d = z(d, !0); if (!1 !== k && l && p === l && !f.cropped && !f.hasGroupedData && f.visible) v(b, function (a, b) { h[b].update && a !== x.data[b] && h[b].update(a, !1, null, !1) }); else {
            f.xIncrement = null; f.colorCounter = 0; v(this.parallelArrays, function (a) { f[a + "Data"].length = 0 }); if (y && l > y) {
              for (g = 0; null === E && g < l;)E = b[g], g++; if (c(E)) for (g = 0; g < l; g++)C[g] = this.autoIncrement(), n[g] = b[g]; else if (e(E)) if (A) for (g = 0; g < l; g++)E =
                b[g], C[g] = E[0], n[g] = E.slice(1, A + 1); else for (g = 0; g < l; g++)E = b[g], C[g] = E[0], n[g] = E[1]; else a.error(12)
            } else for (g = 0; g < l; g++)void 0 !== b[g] && (E = { series: f }, f.pointClass.prototype.applyOptions.apply(E, [b[g]]), f.updateParallelArrays(E, g)); n && m(n[0]) && a.error(14, !0); f.data = []; f.options.data = f.userOptions.data = b; for (g = p; g--;)h[g] && h[g].destroy && h[g].destroy(); q && (q.minRange = q.userMinRange); f.isDirty = r.isDirtyBox = !0; f.isDirtyData = !!h; g = !1
          } "point" === x.legendType && (this.processData(), this.generatePoints()); d &&
            r.redraw(g)
      }, processData: function (b) {
        var c = this.xData, d = this.yData, e = c.length, g; g = 0; var h, k, f = this.xAxis, m, l = this.options; m = l.cropThreshold; var x = this.getExtremesFromAll || l.getExtremesFromAll, r = this.isCartesian, l = f && f.val2lin, q = f && f.isLog, y = this.requireSorting, n, A; if (r && !this.isDirty && !f.isDirty && !this.yAxis.isDirty && !b) return !1; f && (b = f.getExtremes(), n = b.min, A = b.max); if (r && this.sorted && !x && (!m || e > m || this.forceCrop)) if (c[e - 1] < n || c[0] > A) c = [], d = []; else if (c[0] < n || c[e - 1] > A) g = this.cropData(this.xData,
          this.yData, n, A), c = g.xData, d = g.yData, g = g.start, h = !0; for (m = c.length || 1; --m;)e = q ? l(c[m]) - l(c[m - 1]) : c[m] - c[m - 1], 0 < e && (void 0 === k || e < k) ? k = e : 0 > e && y && (a.error(15), y = !1); this.cropped = h; this.cropStart = g; this.processedXData = c; this.processedYData = d; this.closestPointRange = k
      }, cropData: function (a, b, c, d) { var e = a.length, h = 0, g = e, k = z(this.cropShoulder, 1), f; for (f = 0; f < e; f++)if (a[f] >= c) { h = Math.max(0, f - k); break } for (c = f; c < e; c++)if (a[c] > d) { g = c + k; break } return { xData: a.slice(h, g), yData: b.slice(h, g), start: h, end: g } }, generatePoints: function () {
        var a =
          this.options, b = a.data, c = this.data, d, e = this.processedXData, h = this.processedYData, g = this.pointClass, k = e.length, f = this.cropStart || 0, m, l = this.hasGroupedData, a = a.keys, r, q = [], n; c || l || (c = [], c.length = b.length, c = this.data = c); a && l && (this.options.keys = !1); for (n = 0; n < k; n++)m = f + n, l ? (r = (new g).init(this, [e[n]].concat(y(h[n]))), r.dataGroup = this.groupMap[n]) : (r = c[m]) || void 0 === b[m] || (c[m] = r = (new g).init(this, b[m], e[n])), r && (r.index = m, q[n] = r); this.options.keys = a; if (c && (k !== (d = c.length) || l)) for (n = 0; n < d; n++)n !== f || l ||
            (n += k), c[n] && (c[n].destroyElements(), c[n].plotX = void 0); this.data = c; this.points = q
      }, getExtremes: function (a) {
        var b = this.yAxis, d = this.processedXData, g, k = [], h = 0; g = this.xAxis.getExtremes(); var f = g.min, m = g.max, l, x, r, q; a = a || this.stackedYData || this.processedYData || []; g = a.length; for (q = 0; q < g; q++)if (x = d[q], r = a[q], l = (c(r, !0) || e(r)) && (!b.positiveValuesOnly || r.length || 0 < r), x = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (d[q + 1] || x) >= f && (d[q - 1] || x) <= m, l && x) if (l = r.length) for (; l--;)"number" ===
          typeof r[l] && (k[h++] = r[l]); else k[h++] = r; this.dataMin = n(k); this.dataMax = G(k)
      }, translate: function () {
        this.processedXData || this.processData(); this.generatePoints(); var a = this.options, b = a.stacking, d = this.xAxis, e = d.categories, g = this.yAxis, h = this.points, k = h.length, f = !!this.modifyValue, m = a.pointPlacement, r = "between" === m || c(m), n = a.threshold, y = a.startFromThreshold ? n : 0, A, t, D, v, u = Number.MAX_VALUE; "between" === m && (m = .5); c(m) && (m *= z(a.pointRange || d.pointRange)); for (a = 0; a < k; a++) {
          var I = h[a], K = I.x, B = I.y; t = I.low; var G =
            b && g.stacks[(this.negStacks && B < (y ? 0 : n) ? "-" : "") + this.stackKey], H; g.positiveValuesOnly && null !== B && 0 >= B && (I.isNull = !0); I.plotX = A = l(Math.min(Math.max(-1E5, d.translate(K, 0, 0, 0, 1, m, "flags" === this.type)), 1E5)); b && this.visible && !I.isNull && G && G[K] && (v = this.getStackIndicator(v, K, this.index), H = G[K], B = H.points[v.key], t = B[0], B = B[1], t === y && v.key === G[K].base && (t = z(n, g.min)), g.positiveValuesOnly && 0 >= t && (t = null), I.total = I.stackTotal = H.total, I.percentage = H.total && I.y / H.total * 100, I.stackY = B, H.setOffset(this.pointXOffset ||
              0, this.barW || 0)); I.yBottom = q(t) ? Math.min(Math.max(-1E5, g.translate(t, 0, 1, 0, 1)), 1E5) : null; f && (B = this.modifyValue(B, I)); I.plotY = t = "number" === typeof B && Infinity !== B ? Math.min(Math.max(-1E5, g.translate(B, 0, 1, 0, 1)), 1E5) : void 0; I.isInside = void 0 !== t && 0 <= t && t <= g.len && 0 <= A && A <= d.len; I.clientX = r ? l(d.translate(K, 0, 0, 0, 1, m)) : A; I.negative = I.y < (n || 0); I.category = e && void 0 !== e[I.x] ? e[I.x] : I.x; I.isNull || (void 0 !== D && (u = Math.min(u, Math.abs(A - D))), D = A); I.zone = this.zones.length && I.getZone()
        } this.closestPointRangePx =
          u
      }, getValidPoints: function (a, b) { var c = this.chart; return k(a || this.points || [], function (a) { return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull }) }, setClip: function (a) {
        var b = this.chart, c = this.options, d = b.renderer, e = b.inverted, h = this.clipBox, g = h || b.clipBox, k = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(), m = b[k], f = b[k + "m"]; m || (a && (g.width = 0, e && (g.x = b.plotSizeX), b[k + "m"] = f = d.clipRect(e ? b.plotSizeX + 99 : -99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth :
          b.chartHeight)), b[k] = m = d.clipRect(g), m.count = { length: 0 }); a && !m.count[this.index] && (m.count[this.index] = !0, m.count.length += 1); !1 !== c.clip && (this.group.clip(a || h ? m : b.clipRect), this.markerGroup.clip(f), this.sharedClipKey = k); a || (m.count[this.index] && (delete m.count[this.index], --m.count.length), 0 === m.count.length && k && b[k] && (h || (b[k] = b[k].destroy()), b[k + "m"] && (b[k + "m"] = b[k + "m"].destroy())))
      }, animate: function (a) {
        var b = this.chart, c = H(this.options.animation), d; a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) &&
          a.animate({ width: b.plotSizeX, x: 0 }, c), b[d + "m"] && b[d + "m"].animate({ width: b.plotSizeX + 99, x: 0 }, c), this.animate = null)
      }, afterAnimate: function () { this.setClip(); d(this, "afterAnimate"); this.finishedAnimating = !0 }, drawPoints: function () {
        var a = this.points, b = this.chart, c, d, e, h, g = this.options.marker, k, m, f, l = this[this.specialGroup] || this.markerGroup, r, q = z(g.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= g.enabledThreshold * g.radius); if (!1 !== g.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++)d =
          a[c], h = d.graphic, k = d.marker || {}, m = !!d.marker, e = q && void 0 === k.enabled || k.enabled, f = d.isInside, e && !d.isNull ? (e = z(k.symbol, this.symbol), r = this.markerAttribs(d, d.selected && "select"), h ? h[f ? "show" : "hide"](!0).animate(r) : f && (0 < r.width || d.hasImage) && (d.graphic = h = b.renderer.symbol(e, r.x, r.y, r.width, r.height, m ? k : g).add(l)), h && h.attr(this.pointAttribs(d, d.selected && "select")), h && h.addClass(d.getClassName(), !0)) : h && (d.graphic = h.destroy())
      }, markerAttribs: function (a, b) {
        var c = this.options.marker, d = a.marker || {},
        e = d.symbol || c.symbol, h = z(d.radius, c.radius); b && (c = c.states[b], b = d.states && d.states[b], h = z(b && b.radius, c && c.radius, h + (c && c.radiusPlus || 0))); a.hasImage = e && 0 === e.indexOf("url"); a.hasImage && (h = 0); a = { x: Math.floor(a.plotX) - h, y: a.plotY - h }; h && (a.width = a.height = 2 * h); return a
      }, pointAttribs: function (a, b) {
        var c = this.options.marker, d = a && a.options, e = d && d.marker || {}, h = this.color, g = d && d.color, k = a && a.color, d = z(e.lineWidth, c.lineWidth); a = a && a.zone && a.zone.color; h = g || a || k || h; a = e.fillColor || c.fillColor || h; h = e.lineColor ||
          c.lineColor || h; b && (c = c.states[b], b = e.states && e.states[b] || {}, d = z(b.lineWidth, c.lineWidth, d + z(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, h = b.lineColor || c.lineColor || h); return { stroke: h, "stroke-width": d, fill: a }
      }, destroy: function () {
        var a = this, b = a.chart, c = /AppleWebKit\/533/.test(D.navigator.userAgent), e, g, h = a.data || [], k, m; d(a, "destroy"); K(a); v(a.axisTypes || [], function (b) { (m = a[b]) && m.series && (u(m.series, a), m.isDirty = m.forceRedraw = !0) }); a.legendItem && a.chart.legend.destroyItem(a);
        for (g = h.length; g--;)(k = h[g]) && k.destroy && k.destroy(); a.points = null; clearTimeout(a.animationTimeout); r(a, function (a, b) { a instanceof I && !a.survive && (e = c && "group" === b ? "hide" : "destroy", a[e]()) }); b.hoverSeries === a && (b.hoverSeries = null); u(b.series, a); b.orderSeries(); r(a, function (b, c) { delete a[c] })
      }, getGraphPath: function (a, b, c) {
        var d = this, e = d.options, h = e.step, g, k = [], m = [], f; a = a || d.points; (g = a.reversed) && a.reverse(); (h = { right: 1, center: 2 }[h] || h && 3) && g && (h = 4 - h); !e.connectNulls || b || c || (a = this.getValidPoints(a));
        v(a, function (g, l) { var p = g.plotX, r = g.plotY, x = a[l - 1]; (g.leftCliff || x && x.rightCliff) && !c && (f = !0); g.isNull && !q(b) && 0 < l ? f = !e.connectNulls : g.isNull && !b ? f = !0 : (0 === l || f ? l = ["M", g.plotX, g.plotY] : d.getPointSpline ? l = d.getPointSpline(a, g, l) : h ? (l = 1 === h ? ["L", x.plotX, r] : 2 === h ? ["L", (x.plotX + p) / 2, x.plotY, "L", (x.plotX + p) / 2, r] : ["L", p, x.plotY], l.push("L", p, r)) : l = ["L", p, r], m.push(g.x), h && m.push(g.x), k.push.apply(k, l), f = !1) }); k.xMap = m; return d.graphPath = k
      }, drawGraph: function () {
        var a = this, b = this.options, c = (this.gappedPath ||
          this.getGraphPath).call(this), d = [["graph", "highcharts-graph", b.lineColor || this.color, b.dashStyle]]; v(this.zones, function (c, e) { d.push(["zone-graph-" + e, "highcharts-graph highcharts-zone-graph-" + e + " " + (c.className || ""), c.color || a.color, c.dashStyle || b.dashStyle]) }); v(d, function (d, e) {
            var h = d[0], g = a[h]; g ? (g.endX = a.preventGraphAnimation ? null : c.xMap, g.animate({ d: c })) : c.length && (a[h] = a.chart.renderer.path(c).addClass(d[1]).attr({ zIndex: 1 }).add(a.group), g = {
              stroke: d[2], "stroke-width": b.lineWidth, fill: a.fillGraph &&
                a.color || "none"
            }, d[3] ? g.dashstyle = d[3] : "square" !== b.linecap && (g["stroke-linecap"] = g["stroke-linejoin"] = "round"), g = a[h].attr(g).shadow(2 > e && b.shadow)); g && (g.startX = c.xMap, g.isArea = c.isArea)
          })
      }, applyZones: function () {
        var a = this, b = this.chart, c = b.renderer, d = this.zones, e, h, g = this.clips || [], k, m = this.graph, f = this.area, l = Math.max(b.chartWidth, b.chartHeight), r = this[(this.zoneAxis || "y") + "Axis"], q, n, y = b.inverted, A, t, D, u, I = !1; d.length && (m || f) && r && void 0 !== r.min && (n = r.reversed, A = r.horiz, m && m.hide(), f && f.hide(),
          q = r.getExtremes(), v(d, function (d, p) {
            e = n ? A ? b.plotWidth : 0 : A ? 0 : r.toPixels(q.min); e = Math.min(Math.max(z(h, e), 0), l); h = Math.min(Math.max(Math.round(r.toPixels(z(d.value, q.max), !0)), 0), l); I && (e = h = r.toPixels(q.max)); t = Math.abs(e - h); D = Math.min(e, h); u = Math.max(e, h); r.isXAxis ? (k = { x: y ? u : D, y: 0, width: t, height: l }, A || (k.x = b.plotHeight - k.x)) : (k = { x: 0, y: y ? u : D, width: l, height: t }, A && (k.y = b.plotWidth - k.y)); y && c.isVML && (k = r.isXAxis ? { x: 0, y: n ? D : u, height: k.width, width: b.chartWidth } : {
              x: k.y - b.plotLeft - b.spacingBox.x, y: 0, width: k.height,
              height: b.chartHeight
            }); g[p] ? g[p].animate(k) : (g[p] = c.clipRect(k), m && a["zone-graph-" + p].clip(g[p]), f && a["zone-area-" + p].clip(g[p])); I = d.value > q.max
          }), this.clips = g)
      }, invertGroups: function (a) { function b() { v(["group", "markerGroup"], function (b) { c[b] && (d.renderer.isVML && c[b].attr({ width: c.yAxis.len, height: c.xAxis.len }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a)) }) } var c = this, d = c.chart, e; c.xAxis && (e = B(d, "resize", b), B(c, "destroy", e), b(a), c.invertGroups = b) }, plotGroup: function (a, b, c, d, e) {
        var g =
          this[a], k = !g; k && (this[a] = g = this.chart.renderer.g().attr({ zIndex: d || .1 }).add(e)); g.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (q(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (g.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0); g.attr({ visibility: c })[k ? "attr" : "animate"](this.getPlotBox()); return g
      }, getPlotBox: function () {
        var a = this.chart, b = this.xAxis, c = this.yAxis; a.inverted && (b = c, c = this.xAxis);
        return { translateX: b ? b.left : a.plotLeft, translateY: c ? c.top : a.plotTop, scaleX: 1, scaleY: 1 }
      }, render: function () {
        var a = this, b = a.chart, c, d = a.options, e = !!a.animate && b.renderer.isSVG && H(d.animation).duration, g = a.visible ? "inherit" : "hidden", k = d.zIndex, m = a.hasRendered, f = b.seriesGroup, l = b.inverted; c = a.plotGroup("group", "series", g, k, f); a.markerGroup = a.plotGroup("markerGroup", "markers", g, k, f); e && a.animate(!0); c.inverted = a.isCartesian ? l : !1; a.drawGraph && (a.drawGraph(), a.applyZones()); a.drawDataLabels && a.drawDataLabels();
        a.visible && a.drawPoints(); a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker(); a.invertGroups(l); !1 === d.clip || a.sharedClipKey || m || c.clip(b.clipRect); e && a.animate(); m || (a.animationTimeout = A(function () { a.afterAnimate() }, e)); a.isDirty = !1; a.hasRendered = !0
      }, redraw: function () {
        var a = this.chart, b = this.isDirty || this.isDirtyData, c = this.group, d = this.xAxis, e = this.yAxis; c && (a.inverted && c.attr({ width: a.plotWidth, height: a.plotHeight }), c.animate({
          translateX: z(d && d.left, a.plotLeft), translateY: z(e && e.top,
            a.plotTop)
        })); this.translate(); this.render(); b && delete this.kdTree
      }, kdAxisArray: ["clientX", "plotY"], searchPoint: function (a, b) { var c = this.xAxis, d = this.yAxis, e = this.chart.inverted; return this.searchKDTree({ clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos, plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos }, b) }, buildKDTree: function () {
        function a(c, d, e) {
          var g, h; if (h = c && c.length) return g = b.kdAxisArray[d % e], c.sort(function (a, b) { return a[g] - b[g] }), h = Math.floor(h / 2), {
            point: c[h], left: a(c.slice(0, h), d + 1, e), right: a(c.slice(h +
              1), d + 1, e)
          }
        } this.buildingKdTree = !0; var b = this, c = -1 < b.options.findNearestPointBy.indexOf("y") ? 2 : 1; delete b.kdTree; A(function () { b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c); b.buildingKdTree = !1 }, b.options.kdNow ? 0 : 1)
      }, searchKDTree: function (a, b) {
        function c(a, b, h, m) {
          var f = b.point, l = d.kdAxisArray[h % m], p, r, n = f; r = q(a[e]) && q(f[e]) ? Math.pow(a[e] - f[e], 2) : null; p = q(a[g]) && q(f[g]) ? Math.pow(a[g] - f[g], 2) : null; p = (r || 0) + (p || 0); f.dist = q(p) ? Math.sqrt(p) : Number.MAX_VALUE; f.distX = q(r) ? Math.sqrt(r) : Number.MAX_VALUE;
          l = a[l] - f[l]; p = 0 > l ? "left" : "right"; r = 0 > l ? "right" : "left"; b[p] && (p = c(a, b[p], h + 1, m), n = p[k] < n[k] ? p : f); b[r] && Math.sqrt(l * l) < n[k] && (a = c(a, b[r], h + 1, m), n = a[k] < n[k] ? a : n); return n
        } var d = this, e = this.kdAxisArray[0], g = this.kdAxisArray[1], k = b ? "distX" : "dist"; b = -1 < d.options.findNearestPointBy.indexOf("y") ? 2 : 1; this.kdTree || this.buildingKdTree || this.buildKDTree(); if (this.kdTree) return c(a, this.kdTree, b, b)
      }
    })
  })(L); (function (a) {
    var B = a.Axis, H = a.Chart, G = a.correctFloat, n = a.defined, l = a.destroyObjectProperties, f = a.each, t =
      a.format, q = a.objectEach, v = a.pick, u = a.Series; a.StackItem = function (a, d, k, e, c) { var b = a.chart.inverted; this.axis = a; this.isNegative = k; this.options = d; this.x = e; this.total = null; this.points = {}; this.stack = c; this.rightCliff = this.leftCliff = 0; this.alignOptions = { align: d.align || (b ? k ? "left" : "right" : "center"), verticalAlign: d.verticalAlign || (b ? "middle" : k ? "bottom" : "top"), y: v(d.y, b ? 4 : k ? 14 : -6), x: v(d.x, b ? k ? -6 : 6 : 0) }; this.textAlign = d.textAlign || (b ? k ? "right" : "left" : "center") }; a.StackItem.prototype = {
        destroy: function () {
          l(this,
            this.axis)
        }, render: function (a) { var b = this.axis.chart, k = this.options, e = k.format, e = e ? t(e, this, b.time) : k.formatter.call(this); this.label ? this.label.attr({ text: e, visibility: "hidden" }) : this.label = b.renderer.text(e, null, null, k.useHTML).css(k.style).attr({ align: this.textAlign, rotation: k.rotation, visibility: "hidden" }).add(a) }, setOffset: function (a, d) {
          var b = this.axis, e = b.chart, c = b.translate(b.usePercentage ? 100 : this.total, 0, 0, 0, 1), b = b.translate(0), b = Math.abs(c - b); a = e.xAxis[0].translate(this.x) + a; c = this.getStackBox(e,
            this, a, c, d, b); if (d = this.label) d.align(this.alignOptions, null, c), c = d.alignAttr, d[!1 === this.options.crop || e.isInsidePlot(c.x, c.y) ? "show" : "hide"](!0)
        }, getStackBox: function (a, d, k, e, c, m) { var b = d.axis.reversed, f = a.inverted; a = a.plotHeight; d = d.isNegative && !b || !d.isNegative && b; return { x: f ? d ? e : e - m : k, y: f ? a - k - c : d ? a - e - m : a - e, width: f ? m : c, height: f ? c : m } }
      }; H.prototype.getStacks = function () {
        var a = this; f(a.yAxis, function (a) { a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks) }); f(a.series, function (b) {
          !b.options.stacking ||
          !0 !== b.visible && !1 !== a.options.chart.ignoreHiddenSeries || (b.stackKey = b.type + v(b.options.stack, ""))
        })
      }; B.prototype.buildStacks = function () { var a = this.series, d = v(this.options.reversedStacks, !0), k = a.length, e; if (!this.isXAxis) { this.usePercentage = !1; for (e = k; e--;)a[d ? e : k - e - 1].setStackedPoints(); for (e = 0; e < k; e++)a[e].modifyStacks() } }; B.prototype.renderStackTotals = function () {
        var a = this.chart, d = a.renderer, k = this.stacks, e = this.stackTotalGroup; e || (this.stackTotalGroup = e = d.g("stack-labels").attr({
          visibility: "visible",
          zIndex: 6
        }).add()); e.translate(a.plotLeft, a.plotTop); q(k, function (a) { q(a, function (a) { a.render(e) }) })
      }; B.prototype.resetStacks = function () { var a = this, d = a.stacks; a.isXAxis || q(d, function (b) { q(b, function (d, c) { d.touched < a.stacksTouched ? (d.destroy(), delete b[c]) : (d.total = null, d.cumulative = null) }) }) }; B.prototype.cleanStacks = function () { var a; this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), q(a, function (a) { q(a, function (a) { a.cumulative = a.total }) })) }; u.prototype.setStackedPoints = function () {
        if (this.options.stacking &&
          (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
            var b = this.processedXData, d = this.processedYData, k = [], e = d.length, c = this.options, f = c.threshold, g = v(c.startFromThreshold && f, 0), l = c.stack, c = c.stacking, q = this.stackKey, t = "-" + q, y = this.negStacks, u = this.yAxis, A = u.stacks, D = u.oldStacks, x, E, C, J, F, h, p; u.stacksTouched += 1; for (F = 0; F < e; F++)h = b[F], p = d[F], x = this.getStackIndicator(x, h, this.index), J = x.key, C = (E = y && p < (g ? 0 : f)) ? t : q, A[C] || (A[C] = {}), A[C][h] || (D[C] && D[C][h] ? (A[C][h] = D[C][h], A[C][h].total =
              null) : A[C][h] = new a.StackItem(u, u.options.stackLabels, E, h, l)), C = A[C][h], null !== p ? (C.points[J] = C.points[this.index] = [v(C.cumulative, g)], n(C.cumulative) || (C.base = J), C.touched = u.stacksTouched, 0 < x.index && !1 === this.singleStacks && (C.points[J][0] = C.points[this.index + "," + h + ",0"][0])) : C.points[J] = C.points[this.index] = null, "percent" === c ? (E = E ? q : t, y && A[E] && A[E][h] ? (E = A[E][h], C.total = E.total = Math.max(E.total, C.total) + Math.abs(p) || 0) : C.total = G(C.total + (Math.abs(p) || 0))) : C.total = G(C.total + (p || 0)), C.cumulative = v(C.cumulative,
                g) + (p || 0), null !== p && (C.points[J].push(C.cumulative), k[F] = C.cumulative); "percent" === c && (u.usePercentage = !0); this.stackedYData = k; u.oldStacks = {}
        }
      }; u.prototype.modifyStacks = function () { var a = this, d = a.stackKey, k = a.yAxis.stacks, e = a.processedXData, c, m = a.options.stacking; a[m + "Stacker"] && f([d, "-" + d], function (b) { for (var d = e.length, g, f; d--;)if (g = e[d], c = a.getStackIndicator(c, g, a.index, b), f = (g = k[b] && k[b][g]) && g.points[c.key]) a[m + "Stacker"](f, g, d) }) }; u.prototype.percentStacker = function (a, d, k) {
        d = d.total ? 100 / d.total :
          0; a[0] = G(a[0] * d); a[1] = G(a[1] * d); this.stackedYData[k] = a[1]
      }; u.prototype.getStackIndicator = function (a, d, k, e) { !n(a) || a.x !== d || e && a.key !== e ? a = { x: d, index: 0, key: e } : a.index++; a.key = [k, d, a.index].join(); return a }
  })(L); (function (a) {
    var B = a.addEvent, H = a.animate, G = a.Axis, n = a.createElement, l = a.css, f = a.defined, t = a.each, q = a.erase, v = a.extend, u = a.fireEvent, b = a.inArray, d = a.isNumber, k = a.isObject, e = a.isArray, c = a.merge, m = a.objectEach, g = a.pick, r = a.Point, z = a.Series, K = a.seriesTypes, y = a.setAnimation, I = a.splat; v(a.Chart.prototype,
      {
        addSeries: function (a, b, c) { var d, e = this; a && (b = g(b, !0), u(e, "addSeries", { options: a }, function () { d = e.initSeries(a); e.isDirtyLegend = !0; e.linkSeries(); b && e.redraw(c) })); return d }, addAxis: function (a, b, d, e) { var k = b ? "xAxis" : "yAxis", f = this.options; a = c(a, { index: this[k].length, isX: b }); b = new G(this, a); f[k] = I(f[k] || {}); f[k].push(a); g(d, !0) && this.redraw(e); return b }, showLoading: function (a) {
          var b = this, c = b.options, d = b.loadingDiv, e = c.loading, g = function () {
            d && l(d, {
              left: b.plotLeft + "px", top: b.plotTop + "px", width: b.plotWidth +
                "px", height: b.plotHeight + "px"
            })
          }; d || (b.loadingDiv = d = n("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, b.container), b.loadingSpan = n("span", { className: "highcharts-loading-inner" }, null, d), B(b, "redraw", g)); d.className = "highcharts-loading"; b.loadingSpan.innerHTML = a || c.lang.loading; l(d, v(e.style, { zIndex: 10 })); l(b.loadingSpan, e.labelStyle); b.loadingShown || (l(d, { opacity: 0, display: "" }), H(d, { opacity: e.style.opacity || .5 }, { duration: e.showDuration || 0 })); b.loadingShown = !0; g()
        }, hideLoading: function () {
          var a =
            this.options, b = this.loadingDiv; b && (b.className = "highcharts-loading highcharts-loading-hidden", H(b, { opacity: 0 }, { duration: a.loading.hideDuration || 100, complete: function () { l(b, { display: "none" }) } })); this.loadingShown = !1
        }, propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
        propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "), update: function (a, e, k) {
          var l = this, r = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle" }, q = a.chart, n, h, p = []; if (q) {
            c(!0, l.options.chart, q); "className" in q && l.setClassName(q.className); if ("inverted" in q || "polar" in q) l.propFromSeries(), n = !0; "alignTicks" in q && (n = !0); m(q, function (a, c) {
              -1 !== b("chart." + c, l.propsRequireUpdateSeries) && (h = !0); -1 !== b(c, l.propsRequireDirtyBox) &&
                (l.isDirtyBox = !0)
            }); "style" in q && l.renderer.setStyle(q.style)
          } a.colors && (this.options.colors = a.colors); a.plotOptions && c(!0, this.options.plotOptions, a.plotOptions); m(a, function (a, c) { if (l[c] && "function" === typeof l[c].update) l[c].update(a, !1); else if ("function" === typeof l[r[c]]) l[r[c]](a); "chart" !== c && -1 !== b(c, l.propsRequireUpdateSeries) && (h = !0) }); t("xAxis yAxis zAxis series colorAxis pane".split(" "), function (b) {
            a[b] && (t(I(a[b]), function (a, c) {
              (c = f(a.id) && l.get(a.id) || l[b][c]) && c.coll === b && (c.update(a,
                !1), k && (c.touched = !0)); if (!c && k) if ("series" === b) l.addSeries(a, !1).touched = !0; else if ("xAxis" === b || "yAxis" === b) l.addAxis(a, "xAxis" === b, !1).touched = !0
            }), k && t(l[b], function (a) { a.touched ? delete a.touched : p.push(a) }))
          }); t(p, function (a) { a.remove(!1) }); n && t(l.axes, function (a) { a.update({}, !1) }); h && t(l.series, function (a) { a.update({}, !1) }); a.loading && c(!0, l.options.loading, a.loading); n = q && q.width; q = q && q.height; d(n) && n !== l.chartWidth || d(q) && q !== l.chartHeight ? l.setSize(n, q) : g(e, !0) && l.redraw()
        }, setSubtitle: function (a) {
          this.setTitle(void 0,
            a)
        }
      }); v(r.prototype, {
        update: function (a, b, c, d) {
          function e() {
            f.applyOptions(a); null === f.y && h && (f.graphic = h.destroy()); k(a, !0) && (h && h.element && a && a.marker && void 0 !== a.marker.symbol && (f.graphic = h.destroy()), a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()), f.connector && (f.connector = f.connector.destroy())); l = f.index; m.updateParallelArrays(f, l); q.data[l] = k(q.data[l], !0) || k(a, !0) ? f.options : a; m.isDirty = m.isDirtyData = !0; !m.fixedBox && m.hasCartesianSeries && (r.isDirtyBox = !0); "point" === q.legendType &&
              (r.isDirtyLegend = !0); b && r.redraw(c)
          } var f = this, m = f.series, h = f.graphic, l, r = m.chart, q = m.options; b = g(b, !0); !1 === d ? e() : f.firePointEvent("update", { options: a }, e)
        }, remove: function (a, c) { this.series.removePoint(b(this, this.series.data), a, c) }
      }); v(z.prototype, {
        addPoint: function (a, b, c, d) {
          var e = this.options, k = this.data, f = this.chart, h = this.xAxis, h = h && h.hasNames && h.names, m = e.data, l, r, q = this.xData, n, y; b = g(b, !0); l = { series: this }; this.pointClass.prototype.applyOptions.apply(l, [a]); y = l.x; n = q.length; if (this.requireSorting &&
            y < q[n - 1]) for (r = !0; n && q[n - 1] > y;)n--; this.updateParallelArrays(l, "splice", n, 0, 0); this.updateParallelArrays(l, n); h && l.name && (h[y] = l.name); m.splice(n, 0, a); r && (this.data.splice(n, 0, null), this.processData()); "point" === e.legendType && this.generatePoints(); c && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(l, "shift"), m.shift())); this.isDirtyData = this.isDirty = !0; b && f.redraw(d)
        }, removePoint: function (a, b, c) {
          var d = this, e = d.data, k = e[a], f = d.points, h = d.chart, m = function () {
            f && f.length === e.length &&
            f.splice(a, 1); e.splice(a, 1); d.options.data.splice(a, 1); d.updateParallelArrays(k || { series: d }, "splice", a, 1); k && k.destroy(); d.isDirty = !0; d.isDirtyData = !0; b && h.redraw()
          }; y(c, h); b = g(b, !0); k ? k.firePointEvent("remove", null, m) : m()
        }, remove: function (a, b, c) { function d() { e.destroy(); k.isDirtyLegend = k.isDirtyBox = !0; k.linkSeries(); g(a, !0) && k.redraw(b) } var e = this, k = e.chart; !1 !== c ? u(e, "remove", null, d) : d() }, update: function (a, b) {
          var d = this, e = d.chart, k = d.userOptions, f = d.oldType || d.type, m = a.type || k.type || e.options.chart.type,
          h = K[f].prototype, l, r = ["group", "markerGroup", "dataLabelsGroup"], q = ["navigatorSeries", "baseSeries"], n = d.finishedAnimating && { animation: !1 }; if (Object.keys && "data" === Object.keys(a).toString()) return this.setData(a.data, b); q = r.concat(q); t(q, function (a) { q[a] = d[a]; delete d[a] }); a = c(k, n, { index: d.index, pointStart: d.xData[0] }, { data: d.options.data }, a); d.remove(!1, null, !1); for (l in h) d[l] = void 0; v(d, K[m || f].prototype); t(q, function (a) { d[a] = q[a] }); d.init(e, a); a.zIndex !== k.zIndex && t(r, function (b) { d[b] && d[b].attr({ zIndex: a.zIndex }) });
          d.oldType = f; e.linkSeries(); g(b, !0) && e.redraw(!1)
        }
      }); v(G.prototype, {
        update: function (a, b) { var d = this.chart; a = d.options[this.coll][this.options.index] = c(this.userOptions, a); this.destroy(!0); this.init(d, v(a, { events: void 0 })); d.isDirtyBox = !0; g(b, !0) && d.redraw() }, remove: function (a) {
          for (var b = this.chart, c = this.coll, d = this.series, k = d.length; k--;)d[k] && d[k].remove(!1); q(b.axes, this); q(b[c], this); e(b.options[c]) ? b.options[c].splice(this.options.index, 1) : delete b.options[c]; t(b[c], function (a, b) {
            a.options.index =
            b
          }); this.destroy(); b.isDirtyBox = !0; g(a, !0) && b.redraw()
        }, setTitle: function (a, b) { this.update({ title: a }, b) }, setCategories: function (a, b) { this.update({ categories: a }, b) }
      })
  })(L); (function (a) {
    var B = a.color, H = a.each, G = a.map, n = a.pick, l = a.Series, f = a.seriesType; f("area", "line", { softThreshold: !1, threshold: 0 }, {
      singleStacks: !1, getStackPoints: function (f) {
        var l = [], t = [], u = this.xAxis, b = this.yAxis, d = b.stacks[this.stackKey], k = {}, e = this.index, c = b.series, m = c.length, g, r = n(b.options.reversedStacks, !0) ? 1 : -1, z; f = f || this.points;
        if (this.options.stacking) {
          for (z = 0; z < f.length; z++)f[z].leftNull = f[z].rightNull = null, k[f[z].x] = f[z]; a.objectEach(d, function (a, b) { null !== a.total && t.push(b) }); t.sort(function (a, b) { return a - b }); g = G(c, function () { return this.visible }); H(t, function (a, c) {
            var f = 0, q, n; if (k[a] && !k[a].isNull) l.push(k[a]), H([-1, 1], function (b) {
              var f = 1 === b ? "rightNull" : "leftNull", l = 0, y = d[t[c + b]]; if (y) for (z = e; 0 <= z && z < m;)q = y.points[z], q || (z === e ? k[a][f] = !0 : g[z] && (n = d[a].points[z]) && (l -= n[1] - n[0])), z += r; k[a][1 === b ? "rightCliff" : "leftCliff"] =
                l
            }); else { for (z = e; 0 <= z && z < m;) { if (q = d[a].points[z]) { f = q[1]; break } z += r } f = b.translate(f, 0, 1, 0, 1); l.push({ isNull: !0, plotX: u.translate(a, 0, 0, 0, 1), x: a, plotY: f, yBottom: f }) }
          })
        } return l
      }, getGraphPath: function (a) {
        var f = l.prototype.getGraphPath, t = this.options, u = t.stacking, b = this.yAxis, d, k, e = [], c = [], m = this.index, g, r = b.stacks[this.stackKey], z = t.threshold, B = b.getThreshold(t.threshold), y, t = t.connectNulls || "percent" === u, I = function (d, f, k) {
          var l = a[d]; d = u && r[l.x].points[m]; var q = l[k + "Null"] || 0; k = l[k + "Cliff"] || 0; var n,
            y, l = !0; k || q ? (n = (q ? d[0] : d[1]) + k, y = d[0] + k, l = !!q) : !u && a[f] && a[f].isNull && (n = y = z); void 0 !== n && (c.push({ plotX: g, plotY: null === n ? B : b.getThreshold(n), isNull: l, isCliff: !0 }), e.push({ plotX: g, plotY: null === y ? B : b.getThreshold(y), doCurve: !1 }))
        }; a = a || this.points; u && (a = this.getStackPoints(a)); for (d = 0; d < a.length; d++)if (k = a[d].isNull, g = n(a[d].rectPlotX, a[d].plotX), y = n(a[d].yBottom, B), !k || t) t || I(d, d - 1, "left"), k && !u && t || (c.push(a[d]), e.push({ x: d, plotX: g, plotY: y })), t || I(d, d + 1, "right"); d = f.call(this, c, !0, !0); e.reversed =
          !0; k = f.call(this, e, !0, !0); k.length && (k[0] = "L"); k = d.concat(k); f = f.call(this, c, !1, t); k.xMap = d.xMap; this.areaPath = k; return f
      }, drawGraph: function () {
        this.areaPath = []; l.prototype.drawGraph.apply(this); var a = this, f = this.areaPath, v = this.options, u = [["area", "highcharts-area", this.color, v.fillColor]]; H(this.zones, function (b, d) { u.push(["zone-area-" + d, "highcharts-area highcharts-zone-area-" + d + " " + b.className, b.color || a.color, b.fillColor || v.fillColor]) }); H(u, function (b) {
          var d = b[0], k = a[d]; k ? (k.endX = a.preventGraphAnimation ?
            null : f.xMap, k.animate({ d: f })) : (k = a[d] = a.chart.renderer.path(f).addClass(b[1]).attr({ fill: n(b[3], B(b[2]).setOpacity(n(v.fillOpacity, .75)).get()), zIndex: 0 }).add(a.group), k.isArea = !0); k.startX = f.xMap; k.shiftUnit = v.step ? 2 : 1
        })
      }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
    })
  })(L); (function (a) {
    var B = a.pick; a = a.seriesType; a("spline", "line", {}, {
      getPointSpline: function (a, G, n) {
        var l = G.plotX, f = G.plotY, t = a[n - 1]; n = a[n + 1]; var q, v, u, b; if (t && !t.isNull && !1 !== t.doCurve && !G.isCliff && n && !n.isNull && !1 !== n.doCurve &&
          !G.isCliff) { a = t.plotY; u = n.plotX; n = n.plotY; var d = 0; q = (1.5 * l + t.plotX) / 2.5; v = (1.5 * f + a) / 2.5; u = (1.5 * l + u) / 2.5; b = (1.5 * f + n) / 2.5; u !== q && (d = (b - v) * (u - l) / (u - q) + f - b); v += d; b += d; v > a && v > f ? (v = Math.max(a, f), b = 2 * f - v) : v < a && v < f && (v = Math.min(a, f), b = 2 * f - v); b > n && b > f ? (b = Math.max(n, f), v = 2 * f - b) : b < n && b < f && (b = Math.min(n, f), v = 2 * f - b); G.rightContX = u; G.rightContY = b } G = ["C", B(t.rightContX, t.plotX), B(t.rightContY, t.plotY), B(q, l), B(v, f), l, f]; t.rightContX = t.rightContY = null; return G
      }
    })
  })(L); (function (a) {
    var B = a.seriesTypes.area.prototype,
    H = a.seriesType; H("areaspline", "spline", a.defaultPlotOptions.area, { getStackPoints: B.getStackPoints, getGraphPath: B.getGraphPath, drawGraph: B.drawGraph, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle })
  })(L); (function (a) {
    var B = a.animObject, H = a.color, G = a.each, n = a.extend, l = a.isNumber, f = a.merge, t = a.pick, q = a.Series, v = a.seriesType, u = a.svg; v("column", "line", {
      borderRadius: 0, crisp: !0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: {
        hover: { halo: !1, brightness: .1 },
        select: { color: "#cccccc", borderColor: "#000000" }
      }, dataLabels: { align: null, verticalAlign: null, y: null }, softThreshold: !1, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff"
    }, {
      cropShoulder: 0, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function () { q.prototype.init.apply(this, arguments); var a = this, d = a.chart; d.hasRendered && G(d.series, function (b) { b.type === a.type && (b.isDirty = !0) }) }, getColumnMetrics: function () {
        var a = this, d = a.options, f = a.xAxis,
        e = a.yAxis, c = f.reversed, m, g = {}, l = 0; !1 === d.grouping ? l = 1 : G(a.chart.series, function (b) { var c = b.options, d = b.yAxis, f; b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || e.len !== d.len || e.pos !== d.pos || (c.stacking ? (m = b.stackKey, void 0 === g[m] && (g[m] = l++), f = g[m]) : !1 !== c.grouping && (f = l++), b.columnIndex = f) }); var q = Math.min(Math.abs(f.transA) * (f.ordinalSlope || d.pointRange || f.closestPointRange || f.tickInterval || 1), f.len), n = q * d.groupPadding, y = (q - 2 * n) / (l || 1), d = Math.min(d.maxPointWidth || f.len, t(d.pointWidth,
          y * (1 - 2 * d.pointPadding))); a.columnMetrics = { width: d, offset: (y - d) / 2 + (n + ((a.columnIndex || 0) + (c ? 1 : 0)) * y - q / 2) * (c ? -1 : 1) }; return a.columnMetrics
      }, crispCol: function (a, d, f, e) { var b = this.chart, k = this.borderWidth, g = -(k % 2 ? .5 : 0), k = k % 2 ? .5 : 1; b.inverted && b.renderer.isVML && (k += 1); this.options.crisp && (f = Math.round(a + f) + g, a = Math.round(a) + g, f -= a); e = Math.round(d + e) + k; g = .5 >= Math.abs(d) && .5 < e; d = Math.round(d) + k; e -= d; g && e && (--d, e += 1); return { x: a, y: d, width: f, height: e } }, translate: function () {
        var a = this, d = a.chart, f = a.options, e =
          a.dense = 2 > a.closestPointRange * a.xAxis.transA, e = a.borderWidth = t(f.borderWidth, e ? 0 : 1), c = a.yAxis, l = f.threshold, g = a.translatedThreshold = c.getThreshold(l), r = t(f.minPointLength, 5), n = a.getColumnMetrics(), u = n.width, y = a.barW = Math.max(u, 1 + 2 * e), v = a.pointXOffset = n.offset; d.inverted && (g -= .5); f.pointPadding && (y = Math.ceil(y)); q.prototype.translate.apply(a); G(a.points, function (b) {
            var e = t(b.yBottom, g), f = 999 + Math.abs(e), f = Math.min(Math.max(-f, b.plotY), c.len + f), k = b.plotX + v, m = y, q = Math.min(f, e), n, h = Math.max(f, e) - q; r &&
              Math.abs(h) < r && (h = r, n = !c.reversed && !b.negative || c.reversed && b.negative, b.y === l && a.dataMax <= l && c.min < l && (n = !n), q = Math.abs(q - g) > r ? e - r : g - (n ? r : 0)); b.barX = k; b.pointWidth = u; b.tooltipPos = d.inverted ? [c.len + c.pos - d.plotLeft - f, a.xAxis.len - k - m / 2, h] : [k + m / 2, f + c.pos - d.plotTop, h]; b.shapeType = "rect"; b.shapeArgs = a.crispCol.apply(a, b.isNull ? [k, g, m, 0] : [k, q, m, h])
          })
      }, getSymbol: a.noop, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, drawGraph: function () { this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data") },
      pointAttribs: function (a, d) {
        var b = this.options, e, c = this.pointAttrToOptions || {}; e = c.stroke || "borderColor"; var l = c["stroke-width"] || "borderWidth", g = a && a.color || this.color, r = a && a[e] || b[e] || this.color || g, q = a && a[l] || b[l] || this[l] || 0, c = b.dashStyle; a && this.zones.length && (g = a.getZone(), g = a.options.color || g && g.color || this.color); d && (a = f(b.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, g = a.color || void 0 !== d && H(g).brighten(a.brightness).get() || g, r = a[e] || r, q = a[l] || q, c = a.dashStyle || c); e = {
          fill: g,
          stroke: r, "stroke-width": q
        }; c && (e.dashstyle = c); return e
      }, drawPoints: function () {
        var a = this, d = this.chart, k = a.options, e = d.renderer, c = k.animationLimit || 250, m; G(a.points, function (b) {
          var g = b.graphic; if (l(b.plotY) && null !== b.y) {
            m = b.shapeArgs; if (g) g[d.pointCount < c ? "animate" : "attr"](f(m)); else b.graphic = g = e[b.shapeType](m).add(b.group || a.group); k.borderRadius && g.attr({ r: k.borderRadius }); g.attr(a.pointAttribs(b, b.selected && "select")).shadow(k.shadow, null, k.stacking && !k.borderRadius); g.addClass(b.getClassName(),
              !0)
          } else g && (b.graphic = g.destroy())
        })
      }, animate: function (a) { var b = this, f = this.yAxis, e = b.options, c = this.chart.inverted, l = {}, g = c ? "translateX" : "translateY", r; u && (a ? (l.scaleY = .001, a = Math.min(f.pos + f.len, Math.max(f.pos, f.toPixels(e.threshold))), c ? l.translateX = a - f.len : l.translateY = a, b.group.attr(l)) : (r = b.group.attr(g), b.group.animate({ scaleY: 1 }, n(B(b.options.animation), { step: function (a, c) { l[g] = r + c.pos * (f.pos - r); b.group.attr(l) } })), b.animate = null)) }, remove: function () {
        var a = this, d = a.chart; d.hasRendered && G(d.series,
          function (b) { b.type === a.type && (b.isDirty = !0) }); q.prototype.remove.apply(a, arguments)
      }
    })
  })(L); (function (a) { a = a.seriesType; a("bar", "column", null, { inverted: !0 }) })(L); (function (a) {
    var B = a.Series; a = a.seriesType; a("scatter", "line", { lineWidth: 0, findNearestPointBy: "xy", marker: { enabled: !0 }, tooltip: { headerFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e', pointFormat: "x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e" } },
      { sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: !1, drawGraph: function () { this.options.lineWidth && B.prototype.drawGraph.call(this) } })
  })(L); (function (a) {
    var B = a.deg2rad, H = a.isNumber, G = a.pick, n = a.relativeLength; a.CenteredSeriesMixin = {
      getCenter: function () {
        var a = this.options, f = this.chart, t = 2 * (a.slicedOffset || 0), q = f.plotWidth - 2 * t, f = f.plotHeight - 2 * t, v = a.center, v = [G(v[0], "50%"), G(v[1], "50%"), a.size || "100%", a.innerSize || 0], u = Math.min(q,
          f), b, d; for (b = 0; 4 > b; ++b)d = v[b], a = 2 > b || 2 === b && /%$/.test(d), v[b] = n(d, [q, f, u, v[2]][b]) + (a ? t : 0); v[3] > v[2] && (v[3] = v[2]); return v
      }, getStartAndEndRadians: function (a, f) { a = H(a) ? a : 0; f = H(f) && f > a && 360 > f - a ? f : a + 360; return { start: B * (a + -90), end: B * (f + -90) } }
    }
  })(L); (function (a) {
    var B = a.addEvent, H = a.CenteredSeriesMixin, G = a.defined, n = a.each, l = a.extend, f = H.getStartAndEndRadians, t = a.inArray, q = a.noop, v = a.pick, u = a.Point, b = a.Series, d = a.seriesType, k = a.setAnimation; d("pie", "line", {
      center: [null, null], clip: !1, colorByPoint: !0, dataLabels: {
        distance: 30,
        enabled: !0, formatter: function () { return this.point.isNull ? void 0 : this.point.name }, x: 0
      }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, stickyTracking: !1, tooltip: { followPointer: !0 }, borderColor: "#ffffff", borderWidth: 1, states: { hover: { brightness: .1 } }
    }, {
      isCartesian: !1, requireSorting: !1, directTouch: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttribs: a.seriesTypes.column.prototype.pointAttribs, animate: function (a) {
        var b = this,
        d = b.points, e = b.startAngleRad; a || (n(d, function (a) { var c = a.graphic, d = a.shapeArgs; c && (c.attr({ r: a.startR || b.center[3] / 2, start: e, end: e }), c.animate({ r: d.r, start: d.start, end: d.end }, b.options.animation)) }), b.animate = null)
      }, updateTotals: function () { var a, b = 0, d = this.points, g = d.length, f, k = this.options.ignoreHiddenPoint; for (a = 0; a < g; a++)f = d[a], b += k && !f.visible ? 0 : f.isNull ? 0 : f.y; this.total = b; for (a = 0; a < g; a++)f = d[a], f.percentage = 0 < b && (f.visible || !k) ? f.y / b * 100 : 0, f.total = b }, generatePoints: function () {
        b.prototype.generatePoints.call(this);
        this.updateTotals()
      }, translate: function (a) {
        this.generatePoints(); var b = 0, d = this.options, e = d.slicedOffset, k = e + (d.borderWidth || 0), l, q, n, t = f(d.startAngle, d.endAngle), u = this.startAngleRad = t.start, t = (this.endAngleRad = t.end) - u, D = this.points, x, E = d.dataLabels.distance, d = d.ignoreHiddenPoint, C, B = D.length, F; a || (this.center = a = this.getCenter()); this.getX = function (b, c, d) { n = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + d.labelDistance), 1)); return a[0] + (c ? -1 : 1) * Math.cos(n) * (a[2] / 2 + d.labelDistance) }; for (C = 0; C < B; C++) {
          F = D[C];
          F.labelDistance = v(F.options.dataLabels && F.options.dataLabels.distance, E); this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, F.labelDistance); l = u + b * t; if (!d || F.visible) b += F.percentage / 100; q = u + b * t; F.shapeType = "arc"; F.shapeArgs = { x: a[0], y: a[1], r: a[2] / 2, innerR: a[3] / 2, start: Math.round(1E3 * l) / 1E3, end: Math.round(1E3 * q) / 1E3 }; n = (q + l) / 2; n > 1.5 * Math.PI ? n -= 2 * Math.PI : n < -Math.PI / 2 && (n += 2 * Math.PI); F.slicedTranslation = { translateX: Math.round(Math.cos(n) * e), translateY: Math.round(Math.sin(n) * e) }; q = Math.cos(n) * a[2] /
            2; x = Math.sin(n) * a[2] / 2; F.tooltipPos = [a[0] + .7 * q, a[1] + .7 * x]; F.half = n < -Math.PI / 2 || n > Math.PI / 2 ? 1 : 0; F.angle = n; l = Math.min(k, F.labelDistance / 5); F.labelPos = [a[0] + q + Math.cos(n) * F.labelDistance, a[1] + x + Math.sin(n) * F.labelDistance, a[0] + q + Math.cos(n) * l, a[1] + x + Math.sin(n) * l, a[0] + q, a[1] + x, 0 > F.labelDistance ? "center" : F.half ? "right" : "left", n]
        }
      }, drawGraph: null, drawPoints: function () {
        var a = this, b = a.chart.renderer, d, g, f, k, q = a.options.shadow; q && !a.shadowGroup && (a.shadowGroup = b.g("shadow").add(a.group)); n(a.points, function (c) {
          g =
          c.graphic; if (c.isNull) g && (c.graphic = g.destroy()); else { k = c.shapeArgs; d = c.getTranslate(); var e = c.shadowGroup; q && !e && (e = c.shadowGroup = b.g("shadow").add(a.shadowGroup)); e && e.attr(d); f = a.pointAttribs(c, c.selected && "select"); g ? g.setRadialReference(a.center).attr(f).animate(l(k, d)) : (c.graphic = g = b[c.shapeType](k).setRadialReference(a.center).attr(d).add(a.group), c.visible || g.attr({ visibility: "hidden" }), g.attr(f).attr({ "stroke-linejoin": "round" }).shadow(q, e)); g.addClass(c.getClassName()) }
        })
      }, searchPoint: q,
      sortByAngle: function (a, b) { a.sort(function (a, c) { return void 0 !== a.angle && (c.angle - a.angle) * b }) }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, getCenter: H.getCenter, getSymbol: q
    }, {
      init: function () { u.prototype.init.apply(this, arguments); var a = this, b; a.name = v(a.name, "Slice"); b = function (b) { a.slice("select" === b.type) }; B(a, "select", b); B(a, "unselect", b); return a }, isValid: function () { return a.isNumber(this.y, !0) && 0 <= this.y }, setVisible: function (a, b) {
        var c = this, d = c.series, e = d.chart, f = d.options.ignoreHiddenPoint;
        b = v(b, f); a !== c.visible && (c.visible = c.options.visible = a = void 0 === a ? !c.visible : a, d.options.data[t(c, d.data)] = c.options, n(["graphic", "dataLabel", "connector", "shadowGroup"], function (b) { if (c[b]) c[b][a ? "show" : "hide"](!0) }), c.legendItem && e.legend.colorizeItem(c, a), a || "hover" !== c.state || c.setState(""), f && (d.isDirty = !0), b && e.redraw())
      }, slice: function (a, b, d) {
        var c = this.series; k(d, c.chart); v(b, !0); this.sliced = this.options.sliced = G(a) ? a : !this.sliced; c.options.data[t(this, c.data)] = this.options; this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate())
      }, getTranslate: function () { return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 } }, haloPath: function (a) { var b = this.shapeArgs; return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(b.x, b.y, b.r + a, b.r + a, { innerR: this.shapeArgs.r - 1, start: b.start, end: b.end }) }
    })
  })(L); (function (a) {
    var B = a.addEvent, H = a.arrayMax, G = a.defined, n = a.each, l = a.extend, f = a.format, t = a.map, q = a.merge, v = a.noop, u = a.pick, b = a.relativeLength, d =
      a.Series, k = a.seriesTypes, e = a.stableSort; a.distribute = function (a, b) {
        function c(a, b) { return a.target - b.target } var d, f = !0, k = a, l = [], m; m = 0; for (d = a.length; d--;)m += a[d].size; if (m > b) { e(a, function (a, b) { return (b.rank || 0) - (a.rank || 0) }); for (m = d = 0; m <= b;)m += a[d].size, d++; l = a.splice(d - 1, a.length) } e(a, c); for (a = t(a, function (a) { return { size: a.size, targets: [a.target], align: u(a.align, .5) } }); f;) {
          for (d = a.length; d--;)f = a[d], m = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2, f.pos = Math.min(Math.max(0, m - f.size *
            f.align), b - f.size); d = a.length; for (f = !1; d--;)0 < d && a[d - 1].pos + a[d - 1].size > a[d].pos && (a[d - 1].size += a[d].size, a[d - 1].targets = a[d - 1].targets.concat(a[d].targets), a[d - 1].align = .5, a[d - 1].pos + a[d - 1].size > b && (a[d - 1].pos = b - a[d - 1].size), a.splice(d, 1), f = !0)
        } d = 0; n(a, function (a) { var b = 0; n(a.targets, function () { k[d].pos = a.pos + b; b += k[d].size; d++ }) }); k.push.apply(k, l); e(k, c)
      }; d.prototype.drawDataLabels = function () {
        function b(a, b) {
          var c = b.filter; return c ? (b = c.operator, a = a[c.property], c = c.value, "\x3e" === b && a > c || "\x3c" ===
            b && a < c || "\x3e\x3d" === b && a >= c || "\x3c\x3d" === b && a <= c || "\x3d\x3d" === b && a == c || "\x3d\x3d\x3d" === b && a === c ? !0 : !1) : !0
        } var d = this, e = d.chart, k = d.options, l = k.dataLabels, t = d.points, y, v, A = d.hasRendered || 0, D, x, E = u(l.defer, !!k.animation), C = e.renderer; if (l.enabled || d._hasPointLabels) d.dlProcessOptions && d.dlProcessOptions(l), x = d.plotGroup("dataLabelsGroup", "data-labels", E && !A ? "hidden" : "visible", l.zIndex || 6), E && (x.attr({ opacity: +A }), A || B(d, "afterAnimate", function () {
          d.visible && x.show(!0); x[k.animation ? "animate" : "attr"]({ opacity: 1 },
            { duration: 200 })
        })), v = l, n(t, function (c) {
          var g, h = c.dataLabel, m, n, r = c.connector, t = !h, A; y = c.dlOptions || c.options && c.options.dataLabels; (g = u(y && y.enabled, v.enabled) && !c.isNull) && (g = !0 === b(c, y || l)); g && (l = q(v, y), m = c.getLabelConfig(), A = l[c.formatPrefix + "Format"] || l.format, D = G(A) ? f(A, m, e.time) : (l[c.formatPrefix + "Formatter"] || l.formatter).call(m, l), A = l.style, m = l.rotation, A.color = u(l.color, A.color, d.color, "#000000"), "contrast" === A.color && (c.contrastColor = C.getContrast(c.color || d.color), A.color = l.inside || 0 > u(c.labelDistance,
            l.distance) || k.stacking ? c.contrastColor : "#000000"), k.cursor && (A.cursor = k.cursor), n = { fill: l.backgroundColor, stroke: l.borderColor, "stroke-width": l.borderWidth, r: l.borderRadius || 0, rotation: m, padding: l.padding, zIndex: 1 }, a.objectEach(n, function (a, b) { void 0 === a && delete n[b] })); !h || g && G(D) ? g && G(D) && (h ? n.text = D : (h = c.dataLabel = m ? C.text(D, 0, -9999).addClass("highcharts-data-label") : C.label(D, 0, -9999, l.shape, null, null, l.useHTML, null, "data-label"), h.addClass(" highcharts-data-label-color-" + c.colorIndex + " " + (l.className ||
              "") + (l.useHTML ? "highcharts-tracker" : ""))), h.attr(n), h.css(A).shadow(l.shadow), h.added || h.add(x), d.alignDataLabel(c, h, l, null, t)) : (c.dataLabel = h = h.destroy(), r && (c.connector = r.destroy()))
        })
      }; d.prototype.alignDataLabel = function (a, b, d, e, f) {
        var c = this.chart, g = c.inverted, k = u(a.dlBox && a.dlBox.centerX, a.plotX, -9999), m = u(a.plotY, -9999), n = b.getBBox(), q, r = d.rotation, t = d.align, v = this.visible && (a.series.forceDL || c.isInsidePlot(k, Math.round(m), g) || e && c.isInsidePlot(k, g ? e.x + 1 : e.y + e.height - 1, g)), z = "justify" === u(d.overflow,
          "justify"); if (v && (q = d.style.fontSize, q = c.renderer.fontMetrics(q, b).b, e = l({ x: g ? this.yAxis.len - m : k, y: Math.round(g ? this.xAxis.len - k : m), width: 0, height: 0 }, e), l(d, { width: n.width, height: n.height }), r ? (z = !1, k = c.renderer.rotCorr(q, r), k = { x: e.x + d.x + e.width / 2 + k.x, y: e.y + d.y + { top: 0, middle: .5, bottom: 1 }[d.verticalAlign] * e.height }, b[f ? "attr" : "animate"](k).attr({ align: t }), m = (r + 720) % 360, m = 180 < m && 360 > m, "left" === t ? k.y -= m ? n.height : 0 : "center" === t ? (k.x -= n.width / 2, k.y -= n.height / 2) : "right" === t && (k.x -= n.width, k.y -= m ? 0 : n.height)) :
            (b.align(d, null, e), k = b.alignAttr), z ? a.isLabelJustified = this.justifyDataLabel(b, d, k, n, e, f) : u(d.crop, !0) && (v = c.isInsidePlot(k.x, k.y) && c.isInsidePlot(k.x + n.width, k.y + n.height)), d.shape && !r)) b[f ? "attr" : "animate"]({ anchorX: g ? c.plotWidth - a.plotY : a.plotX, anchorY: g ? c.plotHeight - a.plotX : a.plotY }); v || (b.attr({ y: -9999 }), b.placed = !1)
      }; d.prototype.justifyDataLabel = function (a, b, d, e, f, k) {
        var c = this.chart, g = b.align, l = b.verticalAlign, m, n, q = a.box ? 0 : a.padding || 0; m = d.x + q; 0 > m && ("right" === g ? b.align = "left" : b.x = -m, n = !0);
        m = d.x + e.width - q; m > c.plotWidth && ("left" === g ? b.align = "right" : b.x = c.plotWidth - m, n = !0); m = d.y + q; 0 > m && ("bottom" === l ? b.verticalAlign = "top" : b.y = -m, n = !0); m = d.y + e.height - q; m > c.plotHeight && ("top" === l ? b.verticalAlign = "bottom" : b.y = c.plotHeight - m, n = !0); n && (a.placed = !k, a.align(b, null, f)); return n
      }; k.pie && (k.pie.prototype.drawDataLabels = function () {
        var b = this, e = b.data, g, f = b.chart, k = b.options.dataLabels, l = u(k.connectorPadding, 10), q = u(k.connectorWidth, 1), t = f.plotWidth, v = f.plotHeight, D, x = b.center, E = x[2] / 2, C = x[1], B, F,
        h, p, M = [[], []], O, N, P, L, w = [0, 0, 0, 0]; b.visible && (k.enabled || b._hasPointLabels) && (n(e, function (a) { a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), a.dataLabel.shortened = !1) }), d.prototype.drawDataLabels.apply(b), n(e, function (a) { a.dataLabel && a.visible && (M[a.half].push(a), a.dataLabel._pos = null) }), n(M, function (c, d) {
          var e, m, q = c.length, r = [], y; if (q) for (b.sortByAngle(c, d - .5), 0 < b.maxLabelDistance && (e = Math.max(0, C - E - b.maxLabelDistance), m = Math.min(C +
            E + b.maxLabelDistance, f.plotHeight), n(c, function (a) { 0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, C - E - a.labelDistance), a.bottom = Math.min(C + E + a.labelDistance, f.plotHeight), y = a.dataLabel.getBBox().height || 21, a.positionsIndex = r.push({ target: a.labelPos[1] - a.top + y / 2, size: y, rank: a.y }) - 1) }), a.distribute(r, m + y - e)), L = 0; L < q; L++)g = c[L], m = g.positionsIndex, h = g.labelPos, B = g.dataLabel, P = !1 === g.visible ? "hidden" : "inherit", N = e = h[1], r && G(r[m]) && (void 0 === r[m].pos ? P = "hidden" : (p = r[m].size, N = g.top + r[m].pos)), delete g.positionIndex,
              O = k.justify ? x[0] + (d ? -1 : 1) * (E + g.labelDistance) : b.getX(N < g.top + 2 || N > g.bottom - 2 ? e : N, d, g), B._attr = { visibility: P, align: h[6] }, B._pos = { x: O + k.x + ({ left: l, right: -l }[h[6]] || 0), y: N + k.y - 10 }, h.x = O, h.y = N, u(k.crop, !0) && (F = B.getBBox().width, e = null, O - F < l ? (e = Math.round(F - O + l), w[3] = Math.max(e, w[3])) : O + F > t - l && (e = Math.round(O + F - t + l), w[1] = Math.max(e, w[1])), 0 > N - p / 2 ? w[0] = Math.max(Math.round(-N + p / 2), w[0]) : N + p / 2 > v && (w[2] = Math.max(Math.round(N + p / 2 - v), w[2])), B.sideOverflow = e)
        }), 0 === H(w) || this.verifyDataLabelOverflow(w)) && (this.placeDataLabels(),
          q && n(this.points, function (a) { var c; D = a.connector; if ((B = a.dataLabel) && B._pos && a.visible && 0 < a.labelDistance) { P = B._attr.visibility; if (c = !D) a.connector = D = f.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex).add(b.dataLabelsGroup), D.attr({ "stroke-width": q, stroke: k.connectorColor || a.color || "#666666" }); D[c ? "attr" : "animate"]({ d: b.connectorPath(a.labelPos) }); D.attr("visibility", P) } else D && (a.connector = D.destroy()) }))
      }, k.pie.prototype.connectorPath = function (a) {
        var b =
          a.x, c = a.y; return u(this.options.dataLabels.softConnector, !0) ? ["M", b + ("left" === a[6] ? 5 : -5), c, "C", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], "L", a[4], a[5]] : ["M", b + ("left" === a[6] ? 5 : -5), c, "L", a[2], a[3], "L", a[4], a[5]]
      }, k.pie.prototype.placeDataLabels = function () {
        n(this.points, function (a) {
          var b = a.dataLabel; b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({ width: b._attr.width + "px", textOverflow: "ellipsis" }), b.shortened = !0), b.attr(b._attr), b[b.moved ? "animate" : "attr"](a),
            b.moved = !0) : b && b.attr({ y: -9999 }))
        }, this)
      }, k.pie.prototype.alignDataLabel = v, k.pie.prototype.verifyDataLabelOverflow = function (a) {
        var c = this.center, d = this.options, e = d.center, f = d.minSize || 80, k, l = null !== d.size; l || (null !== e[0] ? k = Math.max(c[2] - Math.max(a[1], a[3]), f) : (k = Math.max(c[2] - a[1] - a[3], f), c[0] += (a[3] - a[1]) / 2), null !== e[1] ? k = Math.max(Math.min(k, c[2] - Math.max(a[0], a[2])), f) : (k = Math.max(Math.min(k, c[2] - a[0] - a[2]), f), c[1] += (a[0] - a[2]) / 2), k < c[2] ? (c[2] = k, c[3] = Math.min(b(d.innerSize || 0, k), k), this.translate(c),
          this.drawDataLabels && this.drawDataLabels()) : l = !0); return l
      }); k.column && (k.column.prototype.alignDataLabel = function (a, b, e, f, k) {
        var c = this.chart.inverted, g = a.series, l = a.dlBox || a.shapeArgs, m = u(a.below, a.plotY > u(this.translatedThreshold, g.yAxis.len)), n = u(e.inside, !!this.options.stacking); l && (f = q(l), 0 > f.y && (f.height += f.y, f.y = 0), l = f.y + f.height - g.yAxis.len, 0 < l && (f.height -= l), c && (f = { x: g.yAxis.len - f.y - f.height, y: g.xAxis.len - f.x - f.width, width: f.height, height: f.width }), n || (c ? (f.x += m ? 0 : f.width, f.width = 0) : (f.y +=
          m ? f.height : 0, f.height = 0))); e.align = u(e.align, !c || n ? "center" : m ? "right" : "left"); e.verticalAlign = u(e.verticalAlign, c || n ? "middle" : m ? "top" : "bottom"); d.prototype.alignDataLabel.call(this, a, b, e, f, k); a.isLabelJustified && a.contrastColor && a.dataLabel.css({ color: a.contrastColor })
      })
  })(L); (function (a) {
    var B = a.Chart, H = a.each, G = a.objectEach, n = a.pick; a = a.addEvent; a(B.prototype, "render", function () {
      var a = []; H(this.labelCollectors || [], function (f) { a = a.concat(f()) }); H(this.yAxis || [], function (f) {
        f.options.stackLabels &&
        !f.options.stackLabels.allowOverlap && G(f.stacks, function (f) { G(f, function (f) { a.push(f.label) }) })
      }); H(this.series || [], function (f) { var l = f.options.dataLabels, q = f.dataLabelCollections || ["dataLabel"]; (l.enabled || f._hasPointLabels) && !l.allowOverlap && f.visible && H(q, function (l) { H(f.points, function (f) { f[l] && (f[l].labelrank = n(f.labelrank, f.shapeArgs && f.shapeArgs.height), a.push(f[l])) }) }) }); this.hideOverlappingLabels(a)
    }); B.prototype.hideOverlappingLabels = function (a) {
      var f = a.length, l, n, v, u, b, d, k, e, c, m = function (a,
        b, c, d, e, f, k, l) { return !(e > a + c || e + k < a || f > b + d || f + l < b) }; for (n = 0; n < f; n++)if (l = a[n]) l.oldOpacity = l.opacity, l.newOpacity = 1, l.width || (v = l.getBBox(), l.width = v.width, l.height = v.height); a.sort(function (a, b) { return (b.labelrank || 0) - (a.labelrank || 0) }); for (n = 0; n < f; n++)for (v = a[n], l = n + 1; l < f; ++l)if (u = a[l], v && u && v !== u && v.placed && u.placed && 0 !== v.newOpacity && 0 !== u.newOpacity && (b = v.alignAttr, d = u.alignAttr, k = v.parentGroup, e = u.parentGroup, c = 2 * (v.box ? 0 : v.padding || 0), b = m(b.x + k.translateX, b.y + k.translateY, v.width - c, v.height -
          c, d.x + e.translateX, d.y + e.translateY, u.width - c, u.height - c))) (v.labelrank < u.labelrank ? v : u).newOpacity = 0; H(a, function (a) { var b, c; a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function () { a.hide() }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)), a.isOld = !0) })
    }
  })(L); (function (a) {
    var B = a.addEvent, H = a.Chart, G = a.createElement, n = a.css, l = a.defaultOptions, f = a.defaultPlotOptions, t = a.each, q = a.extend, v = a.fireEvent, u = a.hasTouch, b = a.inArray, d = a.isObject, k = a.Legend, e = a.merge,
    c = a.pick, m = a.Point, g = a.Series, r = a.seriesTypes, z = a.svg, K; K = a.TrackerMixin = {
      drawTrackerPoint: function () {
        var a = this, b = a.chart.pointer, c = function (a) { var c = b.getPointFromEvent(a); void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a)) }; t(a.points, function (a) { a.graphic && (a.graphic.element.point = a); a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a) }); a._hasTracking || (t(a.trackerGroups, function (d) {
          if (a[d]) {
            a[d].addClass("highcharts-tracker").on("mouseover", c).on("mouseout", function (a) { b.onTrackerMouseOut(a) });
            if (u) a[d].on("touchstart", c); a.options.cursor && a[d].css(n).css({ cursor: a.options.cursor })
          }
        }), a._hasTracking = !0)
      }, drawTrackerGraph: function () {
        var a = this, b = a.options, c = b.trackByArea, d = [].concat(c ? a.areaPath : a.graphPath), e = d.length, f = a.chart, g = f.pointer, k = f.renderer, l = f.options.tooltip.snap, h = a.tracker, m, n = function () { if (f.hoverSeries !== a) a.onMouseOver() }, q = "rgba(192,192,192," + (z ? .0001 : .002) + ")"; if (e && !c) for (m = e + 1; m--;)"M" === d[m] && d.splice(m + 1, 0, d[m + 1] - l, d[m + 2], "L"), (m && "M" === d[m] || m === e) && d.splice(m,
          0, "L", d[m - 2] + l, d[m - 1]); h ? h.attr({ d: d }) : a.graph && (a.tracker = k.path(d).attr({ "stroke-linejoin": "round", visibility: a.visible ? "visible" : "hidden", stroke: q, fill: c ? q : "none", "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * l), zIndex: 2 }).add(a.group), t([a.tracker, a.markerGroup], function (a) { a.addClass("highcharts-tracker").on("mouseover", n).on("mouseout", function (a) { g.onTrackerMouseOut(a) }); b.cursor && a.css({ cursor: b.cursor }); if (u) a.on("touchstart", n) }))
      }
    }; r.column && (r.column.prototype.drawTracker = K.drawTrackerPoint);
    r.pie && (r.pie.prototype.drawTracker = K.drawTrackerPoint); r.scatter && (r.scatter.prototype.drawTracker = K.drawTrackerPoint); q(k.prototype, {
      setItemEvents: function (a, b, c) {
        var d = this, f = d.chart.renderer.boxWrapper, g = "highcharts-legend-" + (a instanceof m ? "point" : "series") + "-active"; (c ? b : a.legendGroup).on("mouseover", function () { a.setState("hover"); f.addClass(g); b.css(d.options.itemHoverStyle) }).on("mouseout", function () { b.css(e(a.visible ? d.itemStyle : d.itemHiddenStyle)); f.removeClass(g); a.setState() }).on("click",
          function (b) { var c = function () { a.setVisible && a.setVisible() }; f.removeClass(g); b = { browserEvent: b }; a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : v(a, "legendItemClick", b, c) })
      }, createCheckboxForItem: function (a) { a.checkbox = G("input", { type: "checkbox", checked: a.selected, defaultChecked: a.selected }, this.options.itemCheckboxStyle, this.chart.container); B(a.checkbox, "click", function (b) { v(a.series || a, "checkboxClick", { checked: b.target.checked, item: a }, function () { a.select() }) }) }
    }); l.legend.itemStyle.cursor =
      "pointer"; q(H.prototype, {
        showResetZoom: function () { var a = this, b = l.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo ? null : "plotBox"; this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function () { a.zoomOut() }, d, e && e.hover).attr({ align: c.position.align, title: b.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(c.position, !1, f) }, zoomOut: function () { var a = this; v(a, "selection", { resetSelection: !0 }, function () { a.zoom() }) }, zoom: function (a) {
          var b, e = this.pointer,
          f = !1, g; !a || a.resetSelection ? (t(this.axes, function (a) { b = a.zoom() }), e.initiated = !1) : t(a.xAxis.concat(a.yAxis), function (a) { var c = a.axis; e[c.isXAxis ? "zoomX" : "zoomY"] && (b = c.zoom(a.min, a.max), c.displayBtn && (f = !0)) }); g = this.resetZoomButton; f && !g ? this.showResetZoom() : !f && d(g) && (this.resetZoomButton = g.destroy()); b && this.redraw(c(this.options.chart.animation, a && a.animation, 100 > this.pointCount))
        }, pan: function (a, b) {
          var c = this, d = c.hoverPoints, e; d && t(d, function (a) { a.setState() }); t("xy" === b ? [1, 0] : [1], function (b) {
            b =
            c[b ? "xAxis" : "yAxis"][0]; var d = b.horiz, f = a[d ? "chartX" : "chartY"], d = d ? "mouseDownX" : "mouseDownY", g = c[d], h = (b.pointRange || 0) / 2, k = b.getExtremes(), l = b.toValue(g - f, !0) + h, m = b.toValue(g + b.len - f, !0) - h, n = m < l, g = n ? m : l, l = n ? l : m, m = Math.min(k.dataMin, h ? k.min : b.toValue(b.toPixels(k.min) - b.minPixelPadding)), h = Math.max(k.dataMax, h ? k.max : b.toValue(b.toPixels(k.max) + b.minPixelPadding)), n = m - g; 0 < n && (l += n, g = m); n = l - h; 0 < n && (l = h, g -= n); b.series.length && g !== k.min && l !== k.max && (b.setExtremes(g, l, !1, !1, { trigger: "pan" }), e = !0); c[d] =
              f
          }); e && c.redraw(!1); n(c.container, { cursor: "move" })
        }
      }); q(m.prototype, {
        select: function (a, d) { var e = this, f = e.series, g = f.chart; a = c(a, !e.selected); e.firePointEvent(a ? "select" : "unselect", { accumulate: d }, function () { e.selected = e.options.selected = a; f.options.data[b(e, f.data)] = e.options; e.setState(a && "select"); d || t(g.getSelectedPoints(), function (a) { a.selected && a !== e && (a.selected = a.options.selected = !1, f.options.data[b(a, f.data)] = a.options, a.setState(""), a.firePointEvent("unselect")) }) }) }, onMouseOver: function (a) {
          var b =
            this.series.chart, c = b.pointer; a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted); c.runPointActions(a, this)
        }, onMouseOut: function () { var a = this.series.chart; this.firePointEvent("mouseOut"); t(a.hoverPoints || [], function (a) { a.setState() }); a.hoverPoints = a.hoverPoint = null }, importEvents: function () { if (!this.hasImportedEvents) { var b = this, c = e(b.series.options.point, b.options).events; b.events = c; a.objectEach(c, function (a, c) { B(b, c, a) }); this.hasImportedEvents = !0 } }, setState: function (a, b) {
          var d = Math.floor(this.plotX),
          e = this.plotY, g = this.series, k = g.options.states[a || "normal"] || {}, l = f[g.type].marker && g.options.marker, m = l && !1 === l.enabled, n = l && l.states && l.states[a || "normal"] || {}, h = !1 === n.enabled, p = g.stateMarkerGraphic, r = this.marker || {}, t = g.chart, u = g.halo, v, y = l && g.markerAttribs; a = a || ""; if (!(a === this.state && !b || this.selected && "select" !== a || !1 === k.enabled || a && (h || m && !1 === n.enabled) || a && r.states && r.states[a] && !1 === r.states[a].enabled)) {
            y && (v = g.markerAttribs(this, a)); if (this.graphic) this.state && this.graphic.removeClass("highcharts-point-" +
              this.state), a && this.graphic.addClass("highcharts-point-" + a), this.graphic.animate(g.pointAttribs(this, a), c(t.options.chart.animation, k.animation)), v && this.graphic.animate(v, c(t.options.chart.animation, n.animation, l.animation)), p && p.hide(); else {
                if (a && n) {
                  l = r.symbol || g.symbol; p && p.currentSymbol !== l && (p = p.destroy()); if (p) p[b ? "animate" : "attr"]({ x: v.x, y: v.y }); else l && (g.stateMarkerGraphic = p = t.renderer.symbol(l, v.x, v.y, v.width, v.height).add(g.markerGroup), p.currentSymbol = l); p && p.attr(g.pointAttribs(this,
                    a))
                } p && (p[a && t.isInsidePlot(d, e, t.inverted) ? "show" : "hide"](), p.element.point = this)
            } (d = k.halo) && d.size ? (u || (g.halo = u = t.renderer.path().add((this.graphic || p).parentGroup)), u.show()[b ? "animate" : "attr"]({ d: this.haloPath(d.size) }), u.attr({ "class": "highcharts-halo highcharts-color-" + c(this.colorIndex, g.colorIndex) }), u.point = this, u.attr(q({ fill: this.color || g.color, "fill-opacity": d.opacity, zIndex: -1 }, d.attributes))) : u && u.point && u.point.haloPath && u.animate({ d: u.point.haloPath(0) }, null, u.hide); this.state = a
          }
        },
        haloPath: function (a) { return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a) }
      }); q(g.prototype, {
        onMouseOver: function () { var a = this.chart, b = a.hoverSeries; if (b && b !== this) b.onMouseOut(); this.options.events.mouseOver && v(this, "mouseOver"); this.setState("hover"); a.hoverSeries = this }, onMouseOut: function () {
          var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint; b.hoverSeries = null; if (d) d.onMouseOut(); this && a.events.mouseOut && v(this, "mouseOut"); !c || this.stickyTracking ||
            c.shared && !this.noSharedTooltip || c.hide(); this.setState()
        }, setState: function (a) {
          var b = this, d = b.options, e = b.graph, f = d.states, g = d.lineWidth, d = 0; a = a || ""; if (b.state !== a && (t([b.group, b.markerGroup, b.dataLabelsGroup], function (c) { c && (b.state && c.removeClass("highcharts-series-" + b.state), a && c.addClass("highcharts-series-" + a)) }), b.state = a, !f[a] || !1 !== f[a].enabled) && (a && (g = f[a].lineWidth || g + (f[a].lineWidthPlus || 0)), e && !e.dashstyle)) for (g = { "stroke-width": g }, e.animate(g, c(f[a || "normal"] && f[a || "normal"].animation,
            b.chart.options.chart.animation)); b["zone-graph-" + d];)b["zone-graph-" + d].attr(g), d += 1
        }, setVisible: function (a, b) {
          var c = this, d = c.chart, e = c.legendItem, f, g = d.options.chart.ignoreHiddenSeries, k = c.visible; f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !k : a) ? "show" : "hide"; t(["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"], function (a) { if (c[a]) c[a][f]() }); if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut(); e && d.legend.colorizeItem(c, a); c.isDirty = !0; c.options.stacking &&
            t(d.series, function (a) { a.options.stacking && a.visible && (a.isDirty = !0) }); t(c.linkedSeries, function (b) { b.setVisible(a, !1) }); g && (d.isDirtyBox = !0); !1 !== b && d.redraw(); v(c, f)
        }, show: function () { this.setVisible(!0) }, hide: function () { this.setVisible(!1) }, select: function (a) { this.selected = a = void 0 === a ? !this.selected : a; this.checkbox && (this.checkbox.checked = a); v(this, a ? "select" : "unselect") }, drawTracker: K.drawTrackerGraph
      })
  })(L); (function (a) {
    var B = a.Chart, H = a.each, G = a.inArray, n = a.isArray, l = a.isObject, f = a.pick, t = a.splat;
    B.prototype.setResponsive = function (f) {
      var l = this.options.responsive, n = [], b = this.currentResponsive; l && l.rules && H(l.rules, function (b) { void 0 === b._id && (b._id = a.uniqueKey()); this.matchResponsiveRule(b, n, f) }, this); var d = a.merge.apply(0, a.map(n, function (b) { return a.find(l.rules, function (a) { return a._id === b }).chartOptions })), n = n.toString() || void 0; n !== (b && b.ruleIds) && (b && this.update(b.undoOptions, f), n ? (this.currentResponsive = { ruleIds: n, mergedOptions: d, undoOptions: this.currentOptions(d) }, this.update(d, f)) :
        this.currentResponsive = void 0)
    }; B.prototype.matchResponsiveRule = function (a, l) { var n = a.condition; (n.callback || function () { return this.chartWidth <= f(n.maxWidth, Number.MAX_VALUE) && this.chartHeight <= f(n.maxHeight, Number.MAX_VALUE) && this.chartWidth >= f(n.minWidth, 0) && this.chartHeight >= f(n.minHeight, 0) }).call(this) && l.push(a._id) }; B.prototype.currentOptions = function (f) {
      function q(b, d, f, e) {
        var c; a.objectEach(b, function (a, b) {
          if (!e && -1 < G(b, ["series", "xAxis", "yAxis"])) for (a = t(a), f[b] = [], c = 0; c < a.length; c++)d[b][c] &&
            (f[b][c] = {}, q(a[c], d[b][c], f[b][c], e + 1)); else l(a) ? (f[b] = n(a) ? [] : {}, q(a, d[b] || {}, f[b], e + 1)) : f[b] = d[b] || null
        })
      } var u = {}; q(f, this.options, u, 0); return u
    }
  })(L); return L
});
;
/*
 Highcharts JS v6.0.6 (2018-02-05)

 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (x) { "object" === typeof module && module.exports ? module.exports = x : x(Highcharts) })(function (x) {
  (function (a) {
    var r = a.deg2rad, u = a.isNumber, w = a.pick, p = a.relativeLength; a.CenteredSeriesMixin = {
      getCenter: function () {
        var a = this.options, f = this.chart, h = 2 * (a.slicedOffset || 0), c = f.plotWidth - 2 * h, f = f.plotHeight - 2 * h, b = a.center, b = [w(b[0], "50%"), w(b[1], "50%"), a.size || "100%", a.innerSize || 0], l = Math.min(c, f), g, d; for (g = 0; 4 > g; ++g)d = b[g], a = 2 > g || 2 === g && /%$/.test(d), b[g] = p(d, [c, f, l, b[2]][g]) + (a ? h : 0); b[3] > b[2] && (b[3] = b[2]);
        return b
      }, getStartAndEndRadians: function (a, f) { a = u(a) ? a : 0; f = u(f) && f > a && 360 > f - a ? f : a + 360; return { start: r * (a + -90), end: r * (f + -90) } }
    }
  })(x); (function (a) {
    function r(a, c) { this.init(a, c) } var u = a.CenteredSeriesMixin, w = a.each, p = a.extend, m = a.merge, f = a.splat; p(r.prototype, {
      coll: "pane", init: function (a, c) { this.chart = c; this.background = []; c.pane.push(this); this.setOptions(a) }, setOptions: function (a) { this.options = m(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, a) }, render: function () {
        var a = this.options, c =
          this.options.background, b = this.chart.renderer; this.group || (this.group = b.g("pane-group").attr({ zIndex: a.zIndex || 0 }).add()); this.updateCenter(); if (c) for (c = f(c), a = Math.max(c.length, this.background.length || 0), b = 0; b < a; b++)c[b] && this.axis ? this.renderBackground(m(this.defaultBackgroundOptions, c[b]), b) : this.background[b] && (this.background[b] = this.background[b].destroy(), this.background.splice(b, 1))
      }, renderBackground: function (a, c) {
        var b = "animate"; this.background[c] || (this.background[c] = this.chart.renderer.path().add(this.group),
          b = "attr"); this.background[c][b]({ d: this.axis.getPlotBandPath(a.from, a.to, a) }).attr({ fill: a.backgroundColor, stroke: a.borderColor, "stroke-width": a.borderWidth, "class": "highcharts-pane " + (a.className || "") })
      }, defaultOptions: { center: ["50%", "50%"], size: "85%", startAngle: 0 }, defaultBackgroundOptions: { shape: "circle", borderWidth: 1, borderColor: "#cccccc", backgroundColor: { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, "#ffffff"], [1, "#e6e6e6"]] }, from: -Number.MAX_VALUE, innerRadius: 0, to: Number.MAX_VALUE, outerRadius: "105%" },
      updateCenter: function (a) { this.center = (a || this.axis || {}).center = u.getCenter.call(this) }, update: function (a, c) { m(!0, this.options, a); this.setOptions(this.options); this.render(); w(this.chart.axes, function (b) { b.pane === this && (b.pane = null, b.update({}, c)) }, this) }
    }); a.Pane = r
  })(x); (function (a) {
    var r = a.each, u = a.extend, w = a.map, p = a.merge, m = a.noop, f = a.pick, h = a.pInt, c = a.wrap, b, l, g = a.Axis.prototype; a = a.Tick.prototype; b = {
      getOffset: m, redraw: function () { this.isDirty = !1 }, render: function () { this.isDirty = !1 }, setScale: m, setCategories: m,
      setTitle: m
    }; l = {
      defaultRadialGaugeOptions: { labels: { align: "center", x: 0, y: null }, minorGridLineWidth: 0, minorTickInterval: "auto", minorTickLength: 10, minorTickPosition: "inside", minorTickWidth: 1, tickLength: 10, tickPosition: "inside", tickWidth: 2, title: { rotation: 0 }, zIndex: 2 }, defaultRadialXOptions: { gridLineWidth: 1, labels: { align: null, distance: 15, x: 0, y: null, style: { textOverflow: "none" } }, maxPadding: 0, minPadding: 0, showLastLabel: !1, tickLength: 0 }, defaultRadialYOptions: {
        gridLineInterpolation: "circle", labels: {
          align: "right",
          x: -3, y: -2
        }, showLastLabel: !1, title: { x: 4, text: null, rotation: 90 }
      }, setOptions: function (b) { b = this.options = p(this.defaultOptions, this.defaultRadialOptions, b); b.plotBands || (b.plotBands = []) }, getOffset: function () { g.getOffset.call(this); this.chart.axisOffset[this.side] = 0 }, getLinePath: function (b, c) {
        b = this.center; var d = this.chart, e = f(c, b[2] / 2 - this.offset); this.isCircular || void 0 !== c ? (c = this.chart.renderer.symbols.arc(this.left + b[0], this.top + b[1], e, e, { start: this.startAngleRad, end: this.endAngleRad, open: !0, innerR: 0 }),
          c.xBounds = [this.left + b[0]], c.yBounds = [this.top + b[1] - e]) : (c = this.postTranslate(this.angleRad, e), c = ["M", b[0] + d.plotLeft, b[1] + d.plotTop, "L", c.x, c.y]); return c
      }, setAxisTranslation: function () { g.setAxisTranslation.call(this); this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.center[2] / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0) }, beforeSetTickPositions: function () {
        if (this.autoConnect = this.isCircular &&
          void 0 === f(this.userMax, this.options.max) && this.endAngleRad - this.startAngleRad === 2 * Math.PI) this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0
      }, setAxisSize: function () { g.setAxisSize.call(this); this.isRadial && (this.pane.updateCenter(this), this.isCircular && (this.sector = this.endAngleRad - this.startAngleRad), this.len = this.width = this.height = this.center[2] * f(this.sector, 1) / 2) }, getPosition: function (b, c) {
        return this.postTranslate(this.isCircular ? this.translate(b) : this.angleRad, f(this.isCircular ?
          c : this.translate(b), this.center[2] / 2) - this.offset)
      }, postTranslate: function (b, c) { var d = this.chart, e = this.center; b = this.startAngleRad + b; return { x: d.plotLeft + e[0] + Math.cos(b) * c, y: d.plotTop + e[1] + Math.sin(b) * c } }, getPlotBandPath: function (b, c, a) {
        var d = this.center, e = this.startAngleRad, l = d[2] / 2, k = [f(a.outerRadius, "100%"), a.innerRadius, f(a.thickness, 10)], g = Math.min(this.offset, 0), t = /%$/, m, p = this.isCircular; "polygon" === this.options.gridLineInterpolation ? d = this.getPlotLinePath(b).concat(this.getPlotLinePath(c,
          !0)) : (b = Math.max(b, this.min), c = Math.min(c, this.max), p || (k[0] = this.translate(b), k[1] = this.translate(c)), k = w(k, function (b) { t.test(b) && (b = h(b, 10) * l / 100); return b }), "circle" !== a.shape && p ? (b = e + this.translate(b), c = e + this.translate(c)) : (b = -Math.PI / 2, c = 1.5 * Math.PI, m = !0), k[0] -= g, k[2] -= g, d = this.chart.renderer.symbols.arc(this.left + d[0], this.top + d[1], k[0], k[0], { start: Math.min(b, c), end: Math.max(b, c), innerR: f(k[1], k[0] - k[2]), open: m })); return d
      }, getPlotLinePath: function (b, c) {
        var d = this, e = d.center, a = d.chart, l = d.getPosition(b),
        g, f, t; d.isCircular ? t = ["M", e[0] + a.plotLeft, e[1] + a.plotTop, "L", l.x, l.y] : "circle" === d.options.gridLineInterpolation ? (b = d.translate(b)) && (t = d.getLinePath(0, b)) : (r(a.xAxis, function (b) { b.pane === d.pane && (g = b) }), t = [], b = d.translate(b), e = g.tickPositions, g.autoConnect && (e = e.concat([e[0]])), c && (e = [].concat(e).reverse()), r(e, function (c, d) { f = g.getPosition(c, b); t.push(d ? "L" : "M", f.x, f.y) })); return t
      }, getTitlePosition: function () {
        var b = this.center, c = this.chart, a = this.options.title; return {
          x: c.plotLeft + b[0] + (a.x || 0),
          y: c.plotTop + b[1] - { high: .5, middle: .25, low: 0 }[a.align] * b[2] + (a.y || 0)
        }
      }
    }; c(g, "init", function (c, e, a) {
      var d = e.angular, k = e.polar, g = a.isX, y = d && g, m, t = e.options, h = a.pane || 0, r = this.pane = e.pane && e.pane[h], h = r && r.options; if (d) { if (u(this, y ? b : l), m = !g) this.defaultRadialOptions = this.defaultRadialGaugeOptions } else k && (u(this, l), this.defaultRadialOptions = (m = g) ? this.defaultRadialXOptions : p(this.defaultYAxisOptions, this.defaultRadialYOptions)); d || k ? (this.isRadial = !0, e.inverted = !1, t.chart.zoomType = null) : this.isRadial =
        !1; r && m && (r.axis = this); c.call(this, e, a); !y && r && (d || k) && (c = this.options, this.angleRad = (c.angle || 0) * Math.PI / 180, this.startAngleRad = (h.startAngle - 90) * Math.PI / 180, this.endAngleRad = (f(h.endAngle, h.startAngle + 360) - 90) * Math.PI / 180, this.offset = c.offset || 0, this.isCircular = m)
    }); c(g, "autoLabelAlign", function (b) { if (!this.isRadial) return b.apply(this, [].slice.call(arguments, 1)) }); c(a, "getPosition", function (b, c, a, l, g) { var d = this.axis; return d.getPosition ? d.getPosition(a) : b.call(this, c, a, l, g) }); c(a, "getLabelPosition",
      function (b, c, a, l, g, q, y, m, t) {
        var d = this.axis, e = q.y, k = 20, n = q.align, v = (d.translate(this.pos) + d.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360; d.isRadial ? (b = d.getPosition(this.pos, d.center[2] / 2 + f(q.distance, -25)), "auto" === q.rotation ? l.attr({ rotation: v }) : null === e && (e = d.chart.renderer.fontMetrics(l.styles.fontSize).b - l.getBBox().height / 2), null === n && (d.isCircular ? (this.label.getBBox().width > d.len * d.tickInterval / (d.max - d.min) && (k = 0), n = v > k && v < 180 - k ? "left" : v > 180 + k && v < 360 - k ? "right" : "center") : n = "center", l.attr({ align: n })),
          b.x += q.x, b.y += e) : b = b.call(this, c, a, l, g, q, y, m, t); return b
      }); c(a, "getMarkPath", function (b, c, a, l, g, q, y) { var d = this.axis; d.isRadial ? (b = d.getPosition(this.pos, d.center[2] / 2 + l), c = ["M", c, a, "L", b.x, b.y]) : c = b.call(this, c, a, l, g, q, y); return c })
  })(x); (function (a) {
    var r = a.each, u = a.pick, w = a.defined, p = a.seriesType, m = a.seriesTypes, f = a.Series.prototype, h = a.Point.prototype; p("arearange", "area", {
      lineWidth: 1, threshold: null, tooltip: { pointFormat: '\x3cspan style\x3d"color:{series.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.low}\x3c/b\x3e - \x3cb\x3e{point.high}\x3c/b\x3e\x3cbr/\x3e' },
      trackByArea: !0, dataLabels: { align: null, verticalAlign: null, xLow: 0, xHigh: 0, yLow: 0, yHigh: 0 }
    }, {
      pointArrayMap: ["low", "high"], dataLabelCollections: ["dataLabel", "dataLabelUpper"], toYData: function (c) { return [c.low, c.high] }, pointValKey: "low", deferTranslatePolar: !0, highToXY: function (c) { var b = this.chart, a = this.xAxis.postTranslate(c.rectPlotX, this.yAxis.len - c.plotHigh); c.plotHighX = a.x - b.plotLeft; c.plotHigh = a.y - b.plotTop; c.plotLowX = c.plotX }, translate: function () {
        var c = this, b = c.yAxis, a = !!c.modifyValue; m.area.prototype.translate.apply(c);
        r(c.points, function (l) { var d = l.low, e = l.high, k = l.plotY; null === e || null === d ? (l.isNull = !0, l.plotY = null) : (l.plotLow = k, l.plotHigh = b.translate(a ? c.modifyValue(e, l) : e, 0, 1, 0, 1), a && (l.yBottom = l.plotHigh)) }); this.chart.polar && r(this.points, function (b) { c.highToXY(b); b.tooltipPos = [(b.plotHighX + b.plotLowX) / 2, (b.plotHigh + b.plotLow) / 2] })
      }, getGraphPath: function (c) {
        var b = [], a = [], g, d = m.area.prototype.getGraphPath, e, k, v; v = this.options; var n = this.chart.polar && !1 !== v.connectEnds, q = v.connectNulls, y = v.step; c = c || this.points;
        for (g = c.length; g--;)e = c[g], e.isNull || n || q || c[g + 1] && !c[g + 1].isNull || a.push({ plotX: e.plotX, plotY: e.plotY, doCurve: !1 }), k = { polarPlotY: e.polarPlotY, rectPlotX: e.rectPlotX, yBottom: e.yBottom, plotX: u(e.plotHighX, e.plotX), plotY: e.plotHigh, isNull: e.isNull }, a.push(k), b.push(k), e.isNull || n || q || c[g - 1] && !c[g - 1].isNull || a.push({ plotX: e.plotX, plotY: e.plotY, doCurve: !1 }); c = d.call(this, c); y && (!0 === y && (y = "left"), v.step = { left: "right", center: "center", right: "left" }[y]); b = d.call(this, b); a = d.call(this, a); v.step = y; v = [].concat(c,
          b); this.chart.polar || "M" !== a[0] || (a[0] = "L"); this.graphPath = v; this.areaPath = c.concat(a); v.isArea = !0; v.xMap = c.xMap; this.areaPath.xMap = c.xMap; return v
      }, drawDataLabels: function () {
        var c = this.data, b = c.length, a, g = [], d = this.options.dataLabels, e = d.align, k = d.verticalAlign, v = d.inside, n, q, y = this.chart.inverted; if (d.enabled || this._hasPointLabels) {
          for (a = b; a--;)if (n = c[a]) q = v ? n.plotHigh < n.plotLow : n.plotHigh > n.plotLow, n.y = n.high, n._plotY = n.plotY, n.plotY = n.plotHigh, g[a] = n.dataLabel, n.dataLabel = n.dataLabelUpper, n.below =
            q, y ? e || (d.align = q ? "right" : "left") : k || (d.verticalAlign = q ? "top" : "bottom"), d.x = d.xHigh, d.y = d.yHigh; f.drawDataLabels && f.drawDataLabels.apply(this, arguments); for (a = b; a--;)if (n = c[a]) q = v ? n.plotHigh < n.plotLow : n.plotHigh > n.plotLow, n.dataLabelUpper = n.dataLabel, n.dataLabel = g[a], n.y = n.low, n.plotY = n._plotY, n.below = !q, y ? e || (d.align = q ? "left" : "right") : k || (d.verticalAlign = q ? "bottom" : "top"), d.x = d.xLow, d.y = d.yLow; f.drawDataLabels && f.drawDataLabels.apply(this, arguments)
        } d.align = e; d.verticalAlign = k
      }, alignDataLabel: function () {
        m.column.prototype.alignDataLabel.apply(this,
          arguments)
      }, drawPoints: function () {
        var c = this.points.length, b, a; f.drawPoints.apply(this, arguments); for (a = 0; a < c;)b = this.points[a], b.lowerGraphic = b.graphic, b.graphic = b.upperGraphic, b._plotY = b.plotY, b._plotX = b.plotX, b.plotY = b.plotHigh, w(b.plotHighX) && (b.plotX = b.plotHighX), b._isInside = b.isInside, this.chart.polar || (b.isInside = b.isTopInside = void 0 !== b.plotY && 0 <= b.plotY && b.plotY <= this.yAxis.len && 0 <= b.plotX && b.plotX <= this.xAxis.len), a++; f.drawPoints.apply(this, arguments); for (a = 0; a < c;)b = this.points[a], b.upperGraphic =
          b.graphic, b.graphic = b.lowerGraphic, b.isInside = b._isInside, b.plotY = b._plotY, b.plotX = b._plotX, a++
      }, setStackedPoints: a.noop
    }, {
      setState: function () {
        var c = this.state, b = this.series, a = b.chart.polar; w(this.plotHigh) || (this.plotHigh = b.yAxis.toPixels(this.high, !0)); w(this.plotLow) || (this.plotLow = this.plotY = b.yAxis.toPixels(this.low, !0)); b.stateMarkerGraphic && (b.lowerStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.upperStateMarkerGraphic); this.graphic = this.upperGraphic; this.plotY = this.plotHigh;
        a && (this.plotX = this.plotHighX); h.setState.apply(this, arguments); this.state = c; this.plotY = this.plotLow; this.graphic = this.lowerGraphic; a && (this.plotX = this.plotLowX); b.stateMarkerGraphic && (b.upperStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.lowerStateMarkerGraphic, b.lowerStateMarkerGraphic = void 0); h.setState.apply(this, arguments)
      }, haloPath: function () {
        var c = this.series.chart.polar, b = []; this.plotY = this.plotLow; c && (this.plotX = this.plotLowX); this.isInside && (b = h.haloPath.apply(this, arguments));
        this.plotY = this.plotHigh; c && (this.plotX = this.plotHighX); this.isTopInside && (b = b.concat(h.haloPath.apply(this, arguments))); return b
      }, destroyElements: function () { r(["lowerGraphic", "upperGraphic"], function (c) { this[c] && (this[c] = this[c].destroy()) }, this); this.graphic = null; return h.destroyElements.apply(this, arguments) }
    })
  })(x); (function (a) { var r = a.seriesType; r("areasplinerange", "arearange", null, { getPointSpline: a.seriesTypes.spline.prototype.getPointSpline }) })(x); (function (a) {
    var r = a.defaultPlotOptions, u =
      a.each, w = a.merge, p = a.noop, m = a.pick, f = a.seriesType, h = a.seriesTypes.column.prototype; f("columnrange", "arearange", w(r.column, r.arearange, { pointRange: null, marker: null, states: { hover: { halo: !1 } } }), {
        translate: function () {
          var c = this, b = c.yAxis, a = c.xAxis, g = a.startAngleRad, d, e = c.chart, k = c.xAxis.isRadial, v = Math.max(e.chartWidth, e.chartHeight) + 999, n; h.translate.apply(c); u(c.points, function (l) {
            var q = l.shapeArgs, f = c.options.minPointLength, t, h; l.plotHigh = n = Math.min(Math.max(-v, b.translate(l.high, 0, 1, 0, 1)), v); l.plotLow =
              Math.min(Math.max(-v, l.plotY), v); h = n; t = m(l.rectPlotY, l.plotY) - n; Math.abs(t) < f ? (f -= t, t += f, h -= f / 2) : 0 > t && (t *= -1, h -= t); k ? (d = l.barX + g, l.shapeType = "path", l.shapeArgs = { d: c.polarArc(h + t, h, d, d + l.pointWidth) }) : (q.height = t, q.y = h, l.tooltipPos = e.inverted ? [b.len + b.pos - e.plotLeft - h - t / 2, a.len + a.pos - e.plotTop - q.x - q.width / 2, t] : [a.left - e.plotLeft + q.x + q.width / 2, b.pos - e.plotTop + h + t / 2, t])
          })
        }, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], drawGraph: p, getSymbol: p, crispCol: h.crispCol, drawPoints: h.drawPoints, drawTracker: h.drawTracker,
        getColumnMetrics: h.getColumnMetrics, pointAttribs: h.pointAttribs, animate: function () { return h.animate.apply(this, arguments) }, polarArc: function () { return h.polarArc.apply(this, arguments) }, translate3dPoints: function () { return h.translate3dPoints.apply(this, arguments) }, translate3dShapes: function () { return h.translate3dShapes.apply(this, arguments) }
      }, { setState: h.pointClass.prototype.setState })
  })(x); (function (a) {
    var r = a.each, u = a.isNumber, w = a.merge, p = a.pick, m = a.pInt, f = a.Series, h = a.seriesType, c = a.TrackerMixin;
    h("gauge", "line", { dataLabels: { enabled: !0, defer: !1, y: 15, borderRadius: 3, crop: !1, verticalAlign: "top", zIndex: 2, borderWidth: 1, borderColor: "#cccccc" }, dial: {}, pivot: {}, tooltip: { headerFormat: "" }, showInLegend: !1 }, {
      angular: !0, directTouch: !0, drawGraph: a.noop, fixedBox: !0, forceDL: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], translate: function () {
        var b = this.yAxis, c = this.options, a = b.center; this.generatePoints(); r(this.points, function (d) {
          var e = w(c.dial, d.dial), l = m(p(e.radius, 80)) * a[2] / 200, g = m(p(e.baseLength,
            70)) * l / 100, n = m(p(e.rearLength, 10)) * l / 100, q = e.baseWidth || 3, f = e.topWidth || 1, h = c.overshoot, t = b.startAngleRad + b.translate(d.y, null, null, null, !0); u(h) ? (h = h / 180 * Math.PI, t = Math.max(b.startAngleRad - h, Math.min(b.endAngleRad + h, t))) : !1 === c.wrap && (t = Math.max(b.startAngleRad, Math.min(b.endAngleRad, t))); t = 180 * t / Math.PI; d.shapeType = "path"; d.shapeArgs = { d: e.path || ["M", -n, -q / 2, "L", g, -q / 2, l, -f / 2, l, f / 2, g, q / 2, -n, q / 2, "z"], translateX: a[0], translateY: a[1], rotation: t }; d.plotX = a[0]; d.plotY = a[1]
        })
      }, drawPoints: function () {
        var b =
          this, c = b.yAxis.center, a = b.pivot, d = b.options, e = d.pivot, k = b.chart.renderer; r(b.points, function (c) { var a = c.graphic, e = c.shapeArgs, l = e.d, g = w(d.dial, c.dial); a ? (a.animate(e), e.d = l) : (c.graphic = k[c.shapeType](e).attr({ rotation: e.rotation, zIndex: 1 }).addClass("highcharts-dial").add(b.group), c.graphic.attr({ stroke: g.borderColor || "none", "stroke-width": g.borderWidth || 0, fill: g.backgroundColor || "#000000" })) }); a ? a.animate({ translateX: c[0], translateY: c[1] }) : (b.pivot = k.circle(0, 0, p(e.radius, 5)).attr({ zIndex: 2 }).addClass("highcharts-pivot").translate(c[0],
            c[1]).add(b.group), b.pivot.attr({ "stroke-width": e.borderWidth || 0, stroke: e.borderColor || "#cccccc", fill: e.backgroundColor || "#000000" }))
      }, animate: function (b) { var c = this; b || (r(c.points, function (b) { var a = b.graphic; a && (a.attr({ rotation: 180 * c.yAxis.startAngleRad / Math.PI }), a.animate({ rotation: b.shapeArgs.rotation }, c.options.animation)) }), c.animate = null) }, render: function () {
        this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup); f.prototype.render.call(this);
        this.group.clip(this.chart.clipRect)
      }, setData: function (b, c) { f.prototype.setData.call(this, b, !1); this.processData(); this.generatePoints(); p(c, !0) && this.chart.redraw() }, drawTracker: c && c.drawTrackerPoint
    }, { setState: function (b) { this.state = b } })
  })(x); (function (a) {
    var r = a.each, u = a.noop, w = a.pick, p = a.seriesType, m = a.seriesTypes; p("boxplot", "column", {
      threshold: null, tooltip: { pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cb\x3e {series.name}\x3c/b\x3e\x3cbr/\x3eMaximum: {point.high}\x3cbr/\x3eUpper quartile: {point.q3}\x3cbr/\x3eMedian: {point.median}\x3cbr/\x3eLower quartile: {point.q1}\x3cbr/\x3eMinimum: {point.low}\x3cbr/\x3e' },
      whiskerLength: "50%", fillColor: "#ffffff", lineWidth: 1, medianWidth: 2, whiskerWidth: 2
    }, {
      pointArrayMap: ["low", "q1", "median", "q3", "high"], toYData: function (a) { return [a.low, a.q1, a.median, a.q3, a.high] }, pointValKey: "high", pointAttribs: function () { return {} }, drawDataLabels: u, translate: function () { var a = this.yAxis, h = this.pointArrayMap; m.column.prototype.translate.apply(this); r(this.points, function (c) { r(h, function (b) { null !== c[b] && (c[b + "Plot"] = a.translate(c[b], 0, 1, 0, 1)) }) }) }, drawPoints: function () {
        var a = this, h = a.options,
        c = a.chart.renderer, b, l, g, d, e, k, v = 0, n, q, m, p, t = !1 !== a.doQuartiles, u, A = a.options.whiskerLength; r(a.points, function (f) {
          var y = f.graphic, r = y ? "animate" : "attr", K = f.shapeArgs, x = {}, C = {}, I = {}, J = {}, B = f.color || a.color; void 0 !== f.plotY && (n = K.width, q = Math.floor(K.x), m = q + n, p = Math.round(n / 2), b = Math.floor(t ? f.q1Plot : f.lowPlot), l = Math.floor(t ? f.q3Plot : f.lowPlot), g = Math.floor(f.highPlot), d = Math.floor(f.lowPlot), y || (f.graphic = y = c.g("point").add(a.group), f.stem = c.path().addClass("highcharts-boxplot-stem").add(y), A && (f.whiskers =
            c.path().addClass("highcharts-boxplot-whisker").add(y)), t && (f.box = c.path(void 0).addClass("highcharts-boxplot-box").add(y)), f.medianShape = c.path(void 0).addClass("highcharts-boxplot-median").add(y)), C.stroke = f.stemColor || h.stemColor || B, C["stroke-width"] = w(f.stemWidth, h.stemWidth, h.lineWidth), C.dashstyle = f.stemDashStyle || h.stemDashStyle, f.stem.attr(C), A && (I.stroke = f.whiskerColor || h.whiskerColor || B, I["stroke-width"] = w(f.whiskerWidth, h.whiskerWidth, h.lineWidth), f.whiskers.attr(I)), t && (x.fill = f.fillColor ||
              h.fillColor || B, x.stroke = h.lineColor || B, x["stroke-width"] = h.lineWidth || 0, f.box.attr(x)), J.stroke = f.medianColor || h.medianColor || B, J["stroke-width"] = w(f.medianWidth, h.medianWidth, h.lineWidth), f.medianShape.attr(J), k = f.stem.strokeWidth() % 2 / 2, v = q + p + k, f.stem[r]({ d: ["M", v, l, "L", v, g, "M", v, b, "L", v, d] }), t && (k = f.box.strokeWidth() % 2 / 2, b = Math.floor(b) + k, l = Math.floor(l) + k, q += k, m += k, f.box[r]({ d: ["M", q, l, "L", q, b, "L", m, b, "L", m, l, "L", q, l, "z"] })), A && (k = f.whiskers.strokeWidth() % 2 / 2, g += k, d += k, u = /%$/.test(A) ? p * parseFloat(A) /
                100 : A / 2, f.whiskers[r]({ d: ["M", v - u, g, "L", v + u, g, "M", v - u, d, "L", v + u, d] })), e = Math.round(f.medianPlot), k = f.medianShape.strokeWidth() % 2 / 2, e += k, f.medianShape[r]({ d: ["M", q, e, "L", m, e] }))
        })
      }, setStackedPoints: u
    })
  })(x); (function (a) {
    var r = a.each, u = a.noop, w = a.seriesType, p = a.seriesTypes; w("errorbar", "boxplot", {
      color: "#000000", grouping: !1, linkedTo: ":previous", tooltip: { pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.low}\x3c/b\x3e - \x3cb\x3e{point.high}\x3c/b\x3e\x3cbr/\x3e' },
      whiskerWidth: null
    }, { type: "errorbar", pointArrayMap: ["low", "high"], toYData: function (a) { return [a.low, a.high] }, pointValKey: "high", doQuartiles: !1, drawDataLabels: p.arearange ? function () { var a = this.pointValKey; p.arearange.prototype.drawDataLabels.call(this); r(this.data, function (f) { f.y = f[a] }) } : u, getColumnMetrics: function () { return this.linkedParent && this.linkedParent.columnMetrics || p.column.prototype.getColumnMetrics.call(this) } })
  })(x); (function (a) {
    var r = a.correctFloat, u = a.isNumber, w = a.pick, p = a.Point, m = a.Series,
    f = a.seriesType, h = a.seriesTypes; f("waterfall", "column", { dataLabels: { inside: !0 }, lineWidth: 1, lineColor: "#333333", dashStyle: "dot", borderColor: "#333333", states: { hover: { lineWidthPlus: 0 } } }, {
      pointValKey: "y", translate: function () {
        var c = this.options, b = this.yAxis, a, g, d, e, k, f, n, q, m, p, t = w(c.minPointLength, 5), u = t / 2, x = c.threshold, E = c.stacking, z; h.column.prototype.translate.apply(this); q = m = x; g = this.points; a = 0; for (c = g.length; a < c; a++)d = g[a], n = this.processedYData[a], e = d.shapeArgs, k = E && b.stacks[(this.negStacks && n < x ? "-" :
          "") + this.stackKey], z = this.getStackIndicator(z, d.x, this.index), p = w(k && k[d.x].points[z.key], [0, n]), d.isSum ? d.y = r(n) : d.isIntermediateSum && (d.y = r(n - m)), f = Math.max(q, q + d.y) + p[0], e.y = b.translate(f, 0, 1, 0, 1), d.isSum ? (e.y = b.translate(p[1], 0, 1, 0, 1), e.height = Math.min(b.translate(p[0], 0, 1, 0, 1), b.len) - e.y) : d.isIntermediateSum ? (e.y = b.translate(p[1], 0, 1, 0, 1), e.height = Math.min(b.translate(m, 0, 1, 0, 1), b.len) - e.y, m = p[1]) : (e.height = 0 < n ? b.translate(q, 0, 1, 0, 1) - e.y : b.translate(q, 0, 1, 0, 1) - b.translate(q - n, 0, 1, 0, 1), q += k &&
            k[d.x] ? k[d.x].total : n), 0 > e.height && (e.y += e.height, e.height *= -1), d.plotY = e.y = Math.round(e.y) - this.borderWidth % 2 / 2, e.height = Math.max(Math.round(e.height), .001), d.yBottom = e.y + e.height, e.height <= t && !d.isNull ? (e.height = t, e.y -= u, d.plotY = e.y, d.minPointLengthOffset = 0 > d.y ? -u : u) : d.minPointLengthOffset = 0, e = d.plotY + (d.negative ? e.height : 0), this.chart.inverted ? d.tooltipPos[0] = b.len - e : d.tooltipPos[1] = e
      }, processData: function (c) {
        var b = this.yData, a = this.options.data, g, d = b.length, e, k, f, n, q, h; k = e = f = n = this.options.threshold ||
          0; for (h = 0; h < d; h++)q = b[h], g = a && a[h] ? a[h] : {}, "sum" === q || g.isSum ? b[h] = r(k) : "intermediateSum" === q || g.isIntermediateSum ? b[h] = r(e) : (k += q, e += q), f = Math.min(k, f), n = Math.max(k, n); m.prototype.processData.call(this, c); this.options.stacking || (this.dataMin = f, this.dataMax = n)
      }, toYData: function (c) { return c.isSum ? 0 === c.x ? null : "sum" : c.isIntermediateSum ? 0 === c.x ? null : "intermediateSum" : c.y }, pointAttribs: function (c, b) {
        var a = this.options.upColor; a && !c.options.color && (c.color = 0 < c.y ? a : null); c = h.column.prototype.pointAttribs.call(this,
          c, b); delete c.dashstyle; return c
      }, getGraphPath: function () { return ["M", 0, 0] }, getCrispPath: function () { var c = this.data, b = c.length, a = this.graph.strokeWidth() + this.borderWidth, a = Math.round(a) % 2 / 2, g = this.xAxis.reversed, d = this.yAxis.reversed, e = [], k, f, n; for (n = 1; n < b; n++) { f = c[n].shapeArgs; k = c[n - 1].shapeArgs; f = ["M", k.x + (g ? 0 : k.width), k.y + c[n - 1].minPointLengthOffset + a, "L", f.x + (g ? k.width : 0), k.y + c[n - 1].minPointLengthOffset + a]; if (0 > c[n - 1].y && !d || 0 < c[n - 1].y && d) f[2] += k.height, f[5] += k.height; e = e.concat(f) } return e },
      drawGraph: function () { m.prototype.drawGraph.call(this); this.graph.attr({ d: this.getCrispPath() }) }, setStackedPoints: function () { var c = this.options, b, a; m.prototype.setStackedPoints.apply(this, arguments); b = this.stackedYData ? this.stackedYData.length : 0; for (a = 1; a < b; a++)c.data[a].isSum || c.data[a].isIntermediateSum || (this.stackedYData[a] += this.stackedYData[a - 1]) }, getExtremes: function () { if (this.options.stacking) return m.prototype.getExtremes.apply(this, arguments) }
    }, {
      getClassName: function () {
        var c = p.prototype.getClassName.call(this);
        this.isSum ? c += " highcharts-sum" : this.isIntermediateSum && (c += " highcharts-intermediate-sum"); return c
      }, isValid: function () { return u(this.y, !0) || this.isSum || this.isIntermediateSum }
    })
  })(x); (function (a) {
    var r = a.Series, u = a.seriesType, w = a.seriesTypes; u("polygon", "scatter", { marker: { enabled: !1, states: { hover: { enabled: !1 } } }, stickyTracking: !1, tooltip: { followPointer: !0, pointFormat: "" }, trackByArea: !0 }, {
      type: "polygon", getGraphPath: function () {
        for (var a = r.prototype.getGraphPath.call(this), m = a.length + 1; m--;)(m === a.length ||
          "M" === a[m]) && 0 < m && a.splice(m, 0, "z"); return this.areaPath = a
      }, drawGraph: function () { this.options.fillColor = this.color; w.area.prototype.drawGraph.call(this) }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, drawTracker: r.prototype.drawTracker, setStackedPoints: a.noop
    })
  })(x); (function (a) {
    var r = a.arrayMax, u = a.arrayMin, w = a.Axis, p = a.color, m = a.each, f = a.isNumber, h = a.noop, c = a.pick, b = a.pInt, l = a.Point, g = a.Series, d = a.seriesType, e = a.seriesTypes; d("bubble", "scatter", {
      dataLabels: {
        formatter: function () { return this.point.z },
        inside: !0, verticalAlign: "middle"
      }, marker: { lineColor: null, lineWidth: 1, fillOpacity: .5, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" }, minSize: 8, maxSize: "20%", softThreshold: !1, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z"
    }, {
      pointArrayMap: ["y", "z"], parallelArrays: ["x", "y", "z"], trackerGroups: ["group", "dataLabelsGroup"], specialGroup: "group", bubblePadding: !0, zoneAxis: "z", directTouch: !0, pointAttribs: function (b,
        c) { var a = this.options.marker.fillOpacity; b = g.prototype.pointAttribs.call(this, b, c); 1 !== a && (b.fill = p(b.fill).setOpacity(a).get("rgba")); return b }, getRadii: function (b, c, a, d) { var e, f, k, g = this.zData, n = [], l = this.options, q = "width" !== l.sizeBy, h = l.zThreshold, m = c - b; f = 0; for (e = g.length; f < e; f++)k = g[f], l.sizeByAbsoluteValue && null !== k && (k = Math.abs(k - h), c = Math.max(c - h, Math.abs(b - h)), b = 0), null === k ? k = null : k < b ? k = a / 2 - 1 : (k = 0 < m ? (k - b) / m : .5, q && 0 <= k && (k = Math.sqrt(k)), k = Math.ceil(a + k * (d - a)) / 2), n.push(k); this.radii = n }, animate: function (b) {
          var c =
            this.options.animation; b || (m(this.points, function (b) { var a = b.graphic, d; a && a.width && (d = { x: a.x, y: a.y, width: a.width, height: a.height }, a.attr({ x: b.plotX, y: b.plotY, width: 1, height: 1 }), a.animate(d, c)) }), this.animate = null)
        }, translate: function () {
          var b, c = this.data, d, g, l = this.radii; e.scatter.prototype.translate.call(this); for (b = c.length; b--;)d = c[b], g = l ? l[b] : 0, f(g) && g >= this.minPxSize / 2 ? (d.marker = a.extend(d.marker, { radius: g, width: 2 * g, height: 2 * g }), d.dlBox = { x: d.plotX - g, y: d.plotY - g, width: 2 * g, height: 2 * g }) : d.shapeArgs =
            d.plotY = d.dlBox = void 0
        }, alignDataLabel: e.column.prototype.alignDataLabel, buildKDTree: h, applyZones: h
    }, { haloPath: function (b) { return l.prototype.haloPath.call(this, 0 === b ? 0 : (this.marker ? this.marker.radius || 0 : 0) + b) }, ttBelow: !1 }); w.prototype.beforePadding = function () {
      var a = this, d = this.len, e = this.chart, g = 0, l = d, h = this.isXAxis, p = h ? "xData" : "yData", w = this.min, x = {}, E = Math.min(e.plotWidth, e.plotHeight), z = Number.MAX_VALUE, F = -Number.MAX_VALUE, G = this.max - w, D = d / G, H = []; m(this.series, function (d) {
        var g = d.options; !d.bubblePadding ||
          !d.visible && e.options.chart.ignoreHiddenSeries || (a.allowZoomOutside = !0, H.push(d), h && (m(["minSize", "maxSize"], function (a) { var c = g[a], d = /%$/.test(c), c = b(c); x[a] = d ? E * c / 100 : c }), d.minPxSize = x.minSize, d.maxPxSize = Math.max(x.maxSize, x.minSize), d = d.zData, d.length && (z = c(g.zMin, Math.min(z, Math.max(u(d), !1 === g.displayNegative ? g.zThreshold : -Number.MAX_VALUE))), F = c(g.zMax, Math.max(F, r(d))))))
      }); m(H, function (b) {
        var c = b[p], d = c.length, e; h && b.getRadii(z, F, b.minPxSize, b.maxPxSize); if (0 < G) for (; d--;)f(c[d]) && a.dataMin <=
          c[d] && c[d] <= a.dataMax && (e = b.radii[d], g = Math.min((c[d] - w) * D - e, g), l = Math.max((c[d] - w) * D + e, l))
      }); H.length && 0 < G && !this.isLog && (l -= d, D *= (d + g - l) / d, m([["min", "userMin", g], ["max", "userMax", l]], function (b) { void 0 === c(a.options[b[0]], a[b[1]]) && (a[b[0]] += b[2] / D) }))
    }
  })(x); (function (a) {
    function r(c, b) {
      var a = this.chart, g = this.options.animation, d = this.group, e = this.markerGroup, f = this.xAxis.center, h = a.plotLeft, n = a.plotTop; a.polar ? a.renderer.isSVG && (!0 === g && (g = {}), b ? (c = {
        translateX: f[0] + h, translateY: f[1] + n, scaleX: .001,
        scaleY: .001
      }, d.attr(c), e && e.attr(c)) : (c = { translateX: h, translateY: n, scaleX: 1, scaleY: 1 }, d.animate(c, g), e && e.animate(c, g), this.animate = null)) : c.call(this, b)
    } var u = a.each, w = a.pick, p = a.seriesTypes, m = a.wrap, f = a.Series.prototype, h = a.Pointer.prototype; f.searchPointByAngle = function (a) { var b = this.chart, c = this.xAxis.pane.center; return this.searchKDTree({ clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - c[0] - b.plotLeft, a.chartY - c[1] - b.plotTop) }) }; f.getConnectors = function (a, b, f, g) {
      var c, e, k, l, h, m, p, r; e = g ? 1 : 0; c = 0 <=
        b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0; b = 0 > c - 1 ? a.length - (1 + e) : c - 1; e = c + 1 > a.length - 1 ? e : c + 1; k = a[b]; e = a[e]; l = k.plotX; k = k.plotY; h = e.plotX; m = e.plotY; e = a[c].plotX; c = a[c].plotY; l = (1.5 * e + l) / 2.5; k = (1.5 * c + k) / 2.5; h = (1.5 * e + h) / 2.5; p = (1.5 * c + m) / 2.5; m = Math.sqrt(Math.pow(l - e, 2) + Math.pow(k - c, 2)); r = Math.sqrt(Math.pow(h - e, 2) + Math.pow(p - c, 2)); l = Math.atan2(k - c, l - e); p = Math.PI / 2 + (l + Math.atan2(p - c, h - e)) / 2; Math.abs(l - p) > Math.PI / 2 && (p -= Math.PI); l = e + Math.cos(p) * m; k = c + Math.sin(p) * m; h = e + Math.cos(Math.PI + p) * r; p = c + Math.sin(Math.PI +
          p) * r; e = { rightContX: h, rightContY: p, leftContX: l, leftContY: k, plotX: e, plotY: c }; f && (e.prevPointCont = this.getConnectors(a, b, !1, g)); return e
    }; m(f, "buildKDTree", function (a) { this.chart.polar && (this.kdByAngle ? this.searchPoint = this.searchPointByAngle : this.options.findNearestPointBy = "xy"); a.apply(this) }); f.toXY = function (a) {
      var b, c = this.chart, g = a.plotX; b = a.plotY; a.rectPlotX = g; a.rectPlotY = b; b = this.xAxis.postTranslate(a.plotX, this.yAxis.len - b); a.plotX = a.polarPlotX = b.x - c.plotLeft; a.plotY = a.polarPlotY = b.y - c.plotTop;
      this.kdByAngle ? (c = (g / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360, 0 > c && (c += 360), a.clientX = c) : a.clientX = a.plotX
    }; p.spline && (m(p.spline.prototype, "getPointSpline", function (a, b, f, g) { this.chart.polar ? g ? (a = this.getConnectors(b, g, !0, this.connectEnds), a = ["C", a.prevPointCont.rightContX, a.prevPointCont.rightContY, a.leftContX, a.leftContY, a.plotX, a.plotY]) : a = ["M", f.plotX, f.plotY] : a = a.call(this, b, f, g); return a }), p.areasplinerange && (p.areasplinerange.prototype.getPointSpline = p.spline.prototype.getPointSpline));
    m(f, "translate", function (a) { var b = this.chart; a.call(this); if (b.polar && (this.kdByAngle = b.tooltip && b.tooltip.shared, !this.preventPostTranslate)) for (a = this.points, b = a.length; b--;)this.toXY(a[b]) }); m(f, "getGraphPath", function (a, b) {
      var c = this, g, d, e; if (this.chart.polar) { b = b || this.points; for (g = 0; g < b.length; g++)if (!b[g].isNull) { d = g; break } !1 !== this.options.connectEnds && void 0 !== d && (this.connectEnds = !0, b.splice(b.length, 0, b[d]), e = !0); u(b, function (a) { void 0 === a.polarPlotY && c.toXY(a) }) } g = a.apply(this, [].slice.call(arguments,
        1)); e && b.pop(); return g
    }); m(f, "animate", r); p.column && (p = p.column.prototype, p.polarArc = function (a, b, f, g) { var c = this.xAxis.center, e = this.yAxis.len; return this.chart.renderer.symbols.arc(c[0], c[1], e - b, null, { start: f, end: g, innerR: e - w(a, e) }) }, m(p, "animate", r), m(p, "translate", function (a) {
      var b = this.xAxis, c = b.startAngleRad, g, d, e; this.preventPostTranslate = !0; a.call(this); if (b.isRadial) for (g = this.points, e = g.length; e--;)d = g[e], a = d.barX + c, d.shapeType = "path", d.shapeArgs = {
        d: this.polarArc(d.yBottom, d.plotY, a, a +
          d.pointWidth)
      }, this.toXY(d), d.tooltipPos = [d.plotX, d.plotY], d.ttBelow = d.plotY > b.center[1]
    }), m(p, "alignDataLabel", function (a, b, h, g, d, e) { this.chart.polar ? (a = b.rectPlotX / Math.PI * 180, null === g.align && (g.align = 20 < a && 160 > a ? "left" : 200 < a && 340 > a ? "right" : "center"), null === g.verticalAlign && (g.verticalAlign = 45 > a || 315 < a ? "bottom" : 135 < a && 225 > a ? "top" : "middle"), f.alignDataLabel.call(this, b, h, g, d, e)) : a.call(this, b, h, g, d, e) })); m(h, "getCoordinates", function (a, b) {
      var c = this.chart, g = { xAxis: [], yAxis: [] }; c.polar ? u(c.axes, function (a) {
        var d =
          a.isXAxis, f = a.center, h = b.chartX - f[0] - c.plotLeft, f = b.chartY - f[1] - c.plotTop; g[d ? "xAxis" : "yAxis"].push({ axis: a, value: a.translate(d ? Math.PI - Math.atan2(h, f) : Math.sqrt(Math.pow(h, 2) + Math.pow(f, 2)), !0) })
      }) : g = a.call(this, b); return g
    }); m(a.Chart.prototype, "getAxes", function (c) { this.pane || (this.pane = []); u(a.splat(this.options.pane), function (b) { new a.Pane(b, this) }, this); c.call(this) }); m(a.Chart.prototype, "drawChartBox", function (a) { a.call(this); u(this.pane, function (a) { a.render() }) }); m(a.Chart.prototype, "get",
      function (c, b) { return a.find(this.pane, function (a) { return a.options.id === b }) || c.call(this, b) })
  })(x)
});
;
/*!
 * jquery.sumoselect - v3.0.2
 * http://hemantnegi.github.io/jquery.sumoselect
 */

!function (e) { "namespace sumo"; e.fn.SumoSelect = function (t) { var l = e.extend({ placeholder: "Select Here", csvDispCount: 3, captionFormat: "{0} Selected", captionFormatAllSelected: "{0} all selected!", floatWidth: 400, forceCustomRendering: !1, nativeOnDevice: ["Android", "BlackBerry", "iPhone", "iPad", "iPod", "Opera Mini", "IEMobile", "Silk"], outputAsCSV: !1, csvSepChar: ",", okCancelInMulti: !1, triggerChangeCombined: !0, selectAll: !1, search: !1, searchText: "Search...", noMatch: 'No matches for "{0}"', prefix: "", locale: ["OK", "Cancel", "Select All"], up: !1 }, t), s = this.each(function () { var t = this; !this.sumo && e(this).is("select") && (this.sumo = { E: e(t), is_multi: e(t).attr("multiple"), select: "", caption: "", placeholder: "", optDiv: "", CaptionCont: "", ul: "", is_floating: !1, is_opened: !1, mob: !1, Pstate: [], createElems: function () { var t = this; return t.E.wrap('<div class="SumoSelect" tabindex="0">'), t.select = t.E.parent(), t.caption = e("<span>"), t.CaptionCont = e('<p class="CaptionCont"><label><i></i></label></p>').addClass("SelectBox").attr("style", t.E.attr("style")).prepend(t.caption), t.select.append(t.CaptionCont), t.is_multi || (l.okCancelInMulti = !1), t.E.attr("disabled") && t.select.addClass("disabled").removeAttr("tabindex"), l.outputAsCSV && t.is_multi && t.E.attr("name") && (t.select.append(e('<input class="HEMANT123" type="hidden" />').attr("name", t.E.attr("name")).val(t.getSelStr())), t.E.removeAttr("name")), t.isMobile() && !l.forceCustomRendering ? void t.setNativeMobile() : (t.E.attr("name") && t.select.addClass("sumo_" + t.E.attr("name")), t.E.addClass("SumoUnder").attr("tabindex", "-1"), t.optDiv = e('<div class="optWrapper ' + (l.up ? "up" : "") + '">'), t.floatingList(), t.ul = e('<ul class="options">'), t.optDiv.append(t.ul), l.selectAll && t.SelAll(), l.search && t.Search(), t.ul.append(t.prepItems(t.E.children())), t.is_multi && t.multiSelelect(), t.select.append(t.optDiv), t.basicEvents(), void t.selAllState()) }, prepItems: function (t, l) { var i = [], s = this; return e(t).each(function (t, n) { n = e(n), i.push(n.is("optgroup") ? e('<li class="group ' + (n[0].disabled ? "disabled" : "") + '"><label>' + n.attr("label") + "</label><ul></ul><li>").find("ul").append(s.prepItems(n.children(), n[0].disabled)).end() : s.createLi(n, l)) }), i }, createLi: function (t, l) { var i = this; return t.attr("value") || t.attr("value", t.val()), li = e('<li class="opt"><label>' + t.text() + "</label></li>"), li.data("opt", t), t.data("li", li), i.is_multi && li.prepend("<span><i></i></span>"), (t[0].disabled || l) && (li = li.addClass("disabled")), i.onOptClick(li), t[0].selected && li.addClass("selected"), t.attr("class") && li.addClass(t.attr("class")), li }, getSelStr: function () { return sopt = [], this.E.find("option:selected").each(function () { sopt.push(e(this).val()) }), sopt.join(l.csvSepChar) }, multiSelelect: function () { var t = this; t.optDiv.addClass("multiple"), t.okbtn = e('<p class="btnOk">' + l.locale[0] + "</p>").click(function () { l.triggerChangeCombined && (changed = !1, t.E.find("option:selected").length != t.Pstate.length ? changed = !0 : t.E.find("option").each(function (e, l) { l.selected && t.Pstate.indexOf(e) < 0 && (changed = !0) }), changed && (t.callChange(), t.setText())), t.hideOpts() }), t.cancelBtn = e('<p class="btnCancel">' + l.locale[1] + "</p>").click(function () { t._cnbtn(), t.hideOpts() }), t.optDiv.append(e('<div class="MultiControls">').append(t.okbtn).append(t.cancelBtn)) }, _cnbtn: function () { var e = this; e.E.find("option:selected").each(function () { this.selected = !1 }), e.optDiv.find("li.selected").removeClass("selected"); for (var t = 0; t < e.Pstate.length; t++)e.E.find("option")[e.Pstate[t]].selected = !0, e.ul.find("li.opt").eq(e.Pstate[t]).addClass("selected"); e.selAllState() }, SelAll: function () { var t = this; t.is_multi && (t.selAll = e('<p class="select-all"><span><i></i></span><label>' + l.locale[2] + "</label></p>"), t.selAll.on("click", function () { t.selAll.toggleClass("selected"), t.optDiv.find("li.opt").not(".hidden").each(function (l, i) { i = e(i), t.selAll.hasClass("selected") ? i.hasClass("selected") || i.trigger("click") : i.hasClass("selected") && i.trigger("click") }) }), t.optDiv.prepend(t.selAll)) }, Search: function () { var t = this, i = t.CaptionCont.addClass("search"), s = e('<p class="no-match">'); t.ftxt = e('<input type="text" class="search-txt" value="" placeholder="' + l.searchText + '">').on("click", function (e) { e.stopPropagation() }), i.append(t.ftxt), t.optDiv.children("ul").after(s), t.ftxt.on("keyup.sumo", function () { var i = t.optDiv.find("ul.options li.opt").each(function (l, i) { i = e(i), i.text().toLowerCase().indexOf(t.ftxt.val().toLowerCase()) > -1 ? i.removeClass("hidden") : i.addClass("hidden") }).not(".hidden"); s.html(l.noMatch.replace(/\{0\}/g, t.ftxt.val())).toggle(!i.length), t.selAllState() }) }, selAllState: function () { var t = this; if (l.selectAll) { var i = 0, s = 0; t.optDiv.find("li.opt").not(".hidden").each(function (t, l) { e(l).hasClass("selected") && i++, e(l).hasClass("disabled") || s++ }), i == s ? t.selAll.removeClass("partial").addClass("selected") : 0 == i ? t.selAll.removeClass("selected partial") : t.selAll.addClass("partial") } }, showOpts: function () { var t = this; t.E.attr("disabled") || (t.is_opened = !0, t.select.addClass("open"), t.ftxt ? t.ftxt.focus() : t.select.focus(), e(document).on("click.sumo", function (e) { if (!t.select.is(e.target) && 0 === t.select.has(e.target).length) { if (!t.is_opened) return; t.hideOpts(), l.okCancelInMulti && t._cnbtn() } }), t.is_floating && (H = t.optDiv.children("ul").outerHeight() + 2, t.is_multi && (H += parseInt(t.optDiv.css("padding-bottom"))), t.optDiv.css("height", H), e("body").addClass("sumoStopScroll")), t.setPstate()) }, setPstate: function () { var e = this; e.is_multi && (e.is_floating || l.okCancelInMulti) && (e.Pstate = [], e.E.find("option").each(function (t, l) { l.selected && e.Pstate.push(t) })) }, callChange: function () { this.E.trigger("change").trigger("click") }, hideOpts: function () { var t = this; t.is_opened && (t.is_opened = !1, t.select.removeClass("open").find("ul li.sel").removeClass("sel"), e(document).off("click.sumo"), t.select.focus(), e("body").removeClass("sumoStopScroll"), l.search && (t.ftxt.val(""), t.optDiv.find("ul.options li").removeClass("hidden"), t.optDiv.find(".no-match").toggle(!1))) }, setOnOpen: function () { var e = this, t = e.optDiv.find("li.opt:not(.hidden)").eq(l.search ? 0 : e.E[0].selectedIndex); e.optDiv.find("li.sel").removeClass("sel"), t.addClass("sel"), e.showOpts() }, nav: function (e) { var t, l = this, i = l.ul.find("li.opt:not(.disabled, .hidden)"), s = l.ul.find("li.opt.sel:not(.hidden)"), n = i.index(s); if (l.is_opened && s.length) { if (e && n > 0) t = i.eq(n - 1); else { if (!(!e && n < i.length - 1 && n > -1)) return; t = i.eq(n + 1) } s.removeClass("sel"), s = t.addClass("sel"); var o = l.ul, a = o.scrollTop(), c = s.position().top + a; c >= a + o.height() - s.outerHeight() && o.scrollTop(c - o.height() + s.outerHeight()), a > c && o.scrollTop(c) } else l.setOnOpen() }, basicEvents: function () { var t = this; t.CaptionCont.click(function (e) { t.E.trigger("click"), t.is_opened ? t.hideOpts() : t.showOpts(), e.stopPropagation() }), t.select.on("keydown.sumo", function (e) { switch (e.which) { case 38: t.nav(!0); break; case 40: t.nav(!1); break; case 32: if (l.search && t.ftxt.is(e.target)) return; case 13: t.is_opened ? t.optDiv.find("ul li.sel").trigger("click") : t.setOnOpen(); break; case 9: case 27: return l.okCancelInMulti && t._cnbtn(), void t.hideOpts(); default: return }e.preventDefault() }), e(window).on("resize.sumo", function () { t.floatingList() }) }, onOptClick: function (t) { var i = this; t.click(function () { var t = e(this); t.hasClass("disabled") || (txt = "", i.is_multi ? (t.toggleClass("selected"), t.data("opt")[0].selected = t.hasClass("selected"), i.selAllState()) : (t.parent().find("li.selected").removeClass("selected"), t.toggleClass("selected"), t.data("opt")[0].selected = !0), i.is_multi && l.triggerChangeCombined && (i.is_floating || l.okCancelInMulti) || (i.setText(), i.callChange()), i.is_multi || i.hideOpts()) }) }, setText: function () { var t = this; if (t.placeholder = "", t.is_multi) { for (sels = t.E.find(":selected").not(":disabled"), i = 0; i < sels.length; i++) { if (i + 1 >= l.csvDispCount && l.csvDispCount) { sels.length == t.E.find("option").length && l.captionFormatAllSelected ? t.placeholder = l.captionFormatAllSelected.replace(/\{0\}/g, sels.length) + "," : t.placeholder = l.captionFormat.replace(/\{0\}/g, sels.length) + ","; break } t.placeholder += e(sels[i]).text() + ", " } t.placeholder = t.placeholder.replace(/,([^,]*)$/, "$1") } else t.placeholder = t.E.find(":selected").not(":disabled").text(); return is_placeholder = !1, t.placeholder || (is_placeholder = !0, t.placeholder = t.E.attr("placeholder"), t.placeholder || (t.placeholder = t.E.find("option:disabled:selected").text())), t.placeholder = t.placeholder ? l.prefix + " " + t.placeholder : l.placeholder, t.caption.html(t.placeholder), t.CaptionCont.attr("title", t.placeholder), csvField = t.select.find("input.HEMANT123"), csvField.length && csvField.val(t.getSelStr()), is_placeholder ? t.caption.addClass("placeholder") : t.caption.removeClass("placeholder"), t.placeholder }, isMobile: function () { for (var e = navigator.userAgent || navigator.vendor || window.opera, t = 0; t < l.nativeOnDevice.length; t++)if (e.toString().toLowerCase().indexOf(l.nativeOnDevice[t].toLowerCase()) > 0) return l.nativeOnDevice[t]; return !1 }, setNativeMobile: function () { var e = this; e.E.addClass("SelectClass"), e.mob = !0, e.E.change(function () { e.setText() }) }, floatingList: function () { var t = this; t.is_floating = e(window).width() <= l.floatWidth, t.optDiv.toggleClass("isFloating", t.is_floating), t.is_floating || t.optDiv.css("height", ""), t.optDiv.toggleClass("okCancelInMulti", l.okCancelInMulti && !t.is_floating) }, vRange: function (e) { var t = this; if (opts = t.E.find("option"), opts.length <= e || 0 > e) throw "index out of bounds"; return t }, toggSel: function (t, l) { var i = this; "number" == typeof l ? (i.vRange(l), opt = i.E.find("option")[l]) : opt = i.E.find('option[value="' + l + '"]')[0] || 0, opt && !opt.disabled && opt.selected != t && (opt.selected = t, i.mob || e(opt).data("li").toggleClass("selected", t), i.callChange(), i.setPstate(), i.setText(), i.selAllState()) }, toggDis: function (e, t) { var l = this.vRange(t); l.E.find("option")[t].disabled = e, e && (l.E.find("option")[t].selected = !1), l.mob || l.optDiv.find("ul.options li").eq(t).toggleClass("disabled", e).removeClass("selected"), l.setText() }, toggSumo: function (e) { var t = this; return t.enabled = e, t.select.toggleClass("disabled", e), e ? (t.E.attr("disabled", "disabled"), t.select.removeAttr("tabindex")) : (t.E.removeAttr("disabled"), t.select.attr("tabindex", "0")), t }, toggSelAll: function (t) { var l = this; l.E.find("option").each(function () { l.E.find("option")[e(this).index()].disabled || (l.E.find("option")[e(this).index()].selected = t, l.mob || l.optDiv.find("ul.options li").eq(e(this).index()).toggleClass("selected", t), l.setText()) }), !l.mob && l.selAll && l.selAll.removeClass("partial").toggleClass("selected", t), l.callChange(), l.setPstate() }, reload: function () { var t = this.unload(); return e(t).SumoSelect(l) }, unload: function () { var e = this; return e.select.before(e.E), e.E.show(), l.outputAsCSV && e.is_multi && e.select.find("input.HEMANT123").length && e.E.attr("name", e.select.find("input.HEMANT123").attr("name")), e.select.remove(), delete t.sumo, t }, add: function (l, i, s) { if ("undefined" == typeof l) throw "No value to add"; var n = this; if (opts = n.E.find("option"), "number" == typeof i && (s = i, i = l), "undefined" == typeof i && (i = l), opt = e("<option></option>").val(l).html(i), opts.length < s) throw "index out of bounds"; return "undefined" == typeof s || opts.length == s ? (n.E.append(opt), n.mob || n.ul.append(n.createLi(opt))) : (opts.eq(s).before(opt), n.mob || n.ul.find("li.opt").eq(s).before(n.createLi(opt))), t }, remove: function (e) { var t = this.vRange(e); t.E.find("option").eq(e).remove(), t.mob || t.optDiv.find("ul.options li").eq(e).remove(), t.setText() }, selectItem: function (e) { this.toggSel(!0, e) }, unSelectItem: function (e) { this.toggSel(!1, e) }, selectAll: function () { this.toggSelAll(!0) }, unSelectAll: function () { this.toggSelAll(!1) }, disableItem: function (e) { this.toggDis(!0, e) }, enableItem: function (e) { this.toggDis(!1, e) }, enabled: !0, enable: function () { return this.toggSumo(!1) }, disable: function () { return this.toggSumo(!0) }, init: function () { var e = this; return e.createElems(), e.setText(), e } }, t.sumo.init()) }); return 1 == s.length ? s[0] : s } }(jQuery);
Highcharts.setOptions({

  global: {
    useUTC: false,
    timezoneOffset: 4
  },

  lang: {
    months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
    shortMonths: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
    weekdays: ['Воскресение', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'],
    resetZoom: 'Сбросить увеличение'
  }
});

(function ($) {
  $(document).ready(function ($) {
    if ($('#sector_id').length) $('#sector_id').SumoSelect({ placeholder: 'Все сектора' });
    $('#dividends_filter').find('input[name="year"]').datepicker({ format: "yyyy", startView: 'years', minViewMode: 'years', maxViewMode: 'years', autoclose: true }).on('hide', function (e) { e.preventDefault(); });

    if ($('#dividends_search_form').length) {
      $('input:text', '#dividends_search_form').autocomplete({
        serviceUrl: '/forum/ajaxsearchticker/',
        type: 'POST',
        dataType: 'json',
        paramName: 'value',
        preventBadQueries: false,
        transformResult: function (response) {
          return { suggestions: response['results'] };
        },
        onSelect: function (suggestion) {
          document.location = '/q/' + encodeURIComponent(suggestion.company_url) + '/dividend/';
        }
      });

      $('#dividends_search_form').on('submit', function (e) {
        var sTicker = encodeURIComponent($('input:text', '#dividends_search_form').val().toUpperCase());
        if (sTicker) {
          document.location = '/q/' + sTicker + '/dividend/';
          return false;
        }
      });
    }


    $('.dd_controls').on('click', '.report_bug', function (e) {
      if (LIVESTREET_SECURITY_KEY == undefined) return;
      if ($('#dividendMistakeDialog').length) return;

      var ptr = $(this).parents('tr').find('td');
      var ttr = ptr.parents('table').find('tr').first().find('th');
      var text = '';

      $.each(ttr, function (i, el) {
        if (i - 1 < ttr.length) {
          if (!($.trim($(el).text())).length) return;
          text += $.trim($(el).text()) + ': ' + $.trim($(ptr[i]).text()) + "\r\n";
        }
      });

      e.stopPropagation();


      options =
      {
        id: 'dividendMistakeDialog',
        title: 'Сообщить об обнаружении ошибки в дивиденде',
        confirmButton: 'Отправить',
        cancelButton: 'Отмена',
        content: '<label for="dividendText">Дивиденд:</label><br/><textarea id="dividendText" disabled="true"></textarea><br/><label for="commentText">Обоснуйте почему вы не согласны с дивидендом или его оценкой:</label><br/><textarea id="commentText"></textarea>',

        confirm: function () {
          var data = { url: document.location.href.toString(), text: dialog.wrapper.find('#dividendText').val(), comment: dialog.wrapper.find('#commentText').val(), security_ls_key: LIVESTREET_SECURITY_KEY };
          $.post('/abuse/bug_ajax/', data, function (result) {
            if (!result) {
              msgErrorBox.alert('Error', 'Please try again later');
            }

            if (result.bStateError) {
              msgErrorBox.alert(result.sMsgTitle, result.sMsg);
            } else {
              msgNoticeBox.alert(result.sMsgTitle, result.sMsg);
            }
          });
        },

        onOpen: function () {
          this.wrapper.find('#dividendText').val(text);
        },

        onCloseComplete: function () {
          this.destroy();
        }
      };

      var dialog = new jBox('Confirm', options);
      dialog.open();
    });

    if ($('#yield_graph').length) {
      Highcharts.chart('yield_graph', {
        chart: {
          type: 'column'
        },
        title: {
          text: null
        },
        xAxis: {
          categories: aYieldData['titles'],
          type: 'category',
          labels: {
            rotation: -90,
            style: {
              fontSize: '13px',
              fontFamily: 'Verdana, sans-serif'
            }
          }
        },
        yAxis: {
          title: {
            text: 'Дивидендная доходность, %'
          }
        },
        legend: {
          enabled: false
        },
        tooltip: {
          formatter: function () {

            var s = '<span style="font-weight: bold">' + this.point.title + '</span><hr/><table>';
            s += '<tr><td style="padding:0">Тикер: </td><td style="padding:0"><b>' + this.x + '</b></td></tr>';
            s += '<tr><td style="padding:0">Тип: </td><td style="padding:0"><b>' + (this.point.pref ? 'привилегированная' : 'обычная') + '</b></td></tr>';
            s += '<tr><td style="color:' + this.series.color + ';padding:0">' + this.series.name + ': </td><td style="padding:0"><b>' + Number(this.y).toFixed(2) + '%</b></td></tr>';
            s += '</table>';
            return s;
          },

          shared: false,
          useHTML: true
        },
        plotOptions: {
          series: {
            cursor: 'pointer',
            point: {
              events:
              {
                click: function () {
                  document.location.href = '/q/' + this.company_url + '/dividend/';
                }
              }
            }
          }
        },

        series: [{
          name: 'Доходность',
          data: aYieldData['data'],

          dataLabels: {
            enabled: true,
            rotation: -90,
            align: 'right',
            format: '{point.y:.1f}%',
            y: -50,
            style: {
              fontSize: '10px',
              fontFamily: 'Verdana, sans-serif'
            }
          }

        }],
        credits: {
          enabled: false
        }
      });
    }

    if ($('#bubble_graph').length) {
      $.each(aBubbleData, function (i, e) {
        e.x = Date.parse(e.x);
      });

      Highcharts.chart('bubble_graph',
        {
          chart: {
            type: 'bubble',
            plotBorderWidth: 1,
            zoomType: 'xy'
          },
          title: {
            text: null
          },
          xAxis: {
            type: 'datetime',
            gridLineWidth: 1,
            title: {
              text: 'Факт. дата (Т-2)'
            }
          },
          yAxis: {
            startOnTick: false,
            endOnTick: false,
            title: {
              text: 'Див.доходность, %'
            },
            maxPadding: 0.2
          },

          tooltip: {
            useHTML: true,
            headerFormat: '<table>',
            pointFormat: '<tr><th>Название:</th><td>{point.name} ({point.secid})</td></tr>' +
              '<tr><th>Дата отсечки Т+2:</th><td>{point.x:%e %b %Y} г.</td></tr>' +
              '<tr><th>Дивиденд:</th><td>{point.dividend} руб.</td></tr>' +
              '<tr><th>Дивидендный доход:</th><td>{point.y:.2f}%</td></tr>' +
              '<tr><th>Сектор:</th><td>{point.sector_name}</td></tr>' +
              '<tr><th>Сумма на дивиденды:</th><td>{point.z:,.0f} млн. руб.</td></tr>',
            footerFormat: '</table>',
            followPointer: true
          },
          plotOptions: {
            series: {
              dataLabels: {
                enabled: true,
                format: '{point.name}'
              },
              cursor: 'pointer',
              point:
              {
                events:
                {
                  click: function (e) {
                    document.location.href = aRouter['q'] + this.company_url + '/dividend/';
                  }
                }
              }
            }
          },

          series: [{
            data: aBubbleData,
            sizeByAbsoluteValue: true
          }],

          legend: {
            enabled: false
          },

          credits: {
            enabled: false
          }
        });
    }



    $('.close-button').on('click', function (e) {
      var btn = $(e.target);

      $.ajax({

        url: '/settings/some_settings_ajax/' + '?JsHttpRequest=' + (new Date()).getTime() + '-xml',
        type: 'POST',
        data: { bDisplayDividendGraph: btn.hasClass('hidden') ? 1 : 0, security_ls_key: LIVESTREET_SECURITY_KEY }
      }).then(function (result) {
        try {
          result = JSON.parse(result);
          if (result.js.bStateError) {
            msgErrorBox.alert(result.js.sMsgTitle, result.js.sMsg);
            return;
          }

        } catch (e) { }
        document.location.reload();

      });
    });
  });

})(jQuery);;